"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "_ssr_app_lib_polaroid-cursor_ts";
exports.ids = ["_ssr_app_lib_polaroid-cursor_ts"];
exports.modules = {

/***/ "(ssr)/./app/lib/polaroid-cursor.ts":
/*!************************************!*\
  !*** ./app/lib/polaroid-cursor.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cleanupPolaroidCursor: () => (/* binding */ cleanupPolaroidCursor),\n/* harmony export */   initPolaroidCursor: () => (/* binding */ initPolaroidCursor)\n/* harmony export */ });\n// Polaroid Cursor Effect\n// Creates polaroid photos that follow mouse movement\nlet polaroidInitialized = false;\nlet photosLoaded = false;\nlet container = null;\nlet polaroids = [];\nlet mouseX = 0;\nlet mouseY = 0;\nlet lastMouseX = 0;\nlet lastMouseY = 0;\nlet spawnTimer = 0; // Timer for consistent spawning\nlet wasMouseMoving = false;\nlet resumeDelay = 0; // frames to delay after movement resumes\nconst RESUME_DELAY_FRAMES = 5; // ~0.1s at 60fps\nlet resumeUntilMs = 0; // timestamp until which we delay spawning after resume\nlet idleFrames = 0; // frames not moving\nconst IDLE_ARM_FRAMES = 20; // require ~0.33s idle before arming resume delay\n// Tiny images for better performance\nconst photoList = [\n    '/photos/tiny/AngelHoldingChalice.jpg',\n    '/photos/tiny/AStreetInHaarlem.jpg',\n    '/photos/tiny/Autopark.jpg',\n    '/photos/tiny/CafeHetWapenVanBlo.jpg',\n    '/photos/tiny/Caritasbronden.jpg',\n    '/photos/tiny/CatLaying.jpg',\n    '/photos/tiny/CatWithLargeCollar.jpg',\n    '/photos/tiny/ChurchInTheDistance.jpg',\n    '/photos/tiny/Cows.jpg',\n    '/photos/tiny/CowsCurious.jpg',\n    '/photos/tiny/DeBurcht.jpg',\n    '/photos/tiny/FrederiksbergSlot.jpg',\n    '/photos/tiny/GrassPlane.jpg',\n    '/photos/tiny/Lake.jpg',\n    '/photos/tiny/Maan.jpg',\n    '/photos/tiny/Mermaid.jpg',\n    '/photos/tiny/Office.jpg',\n    '/photos/tiny/SAIL.jpg',\n    '/photos/tiny/SintBonifatiuskerk.jpg',\n    '/photos/tiny/Stairs.jpg',\n    '/photos/tiny/ZaanRiver.jpg'\n];\nasync function preloadPhotos(urls) {\n    const loaders = urls.map((src)=>new Promise((resolve)=>{\n            const img = new Image();\n            img.onload = ()=>resolve();\n            img.onerror = ()=>resolve(); // treat errors as resolved to avoid blocking\n            img.src = src;\n        }));\n    await Promise.all(loaders);\n}\nconst config = {\n    maxPolaroids: 20,\n    polaroidLife: 60,\n    spawnInterval: 8,\n    fadeOutDuration: 30,\n    minMovementThreshold: 1,\n    polaroidSize: 140\n};\nlet photoIndex = 0;\nfunction getNextPhoto() {\n    const src = photoList[photoIndex];\n    photoIndex = (photoIndex + 1) % photoList.length;\n    return src;\n}\nfunction createPolaroidElement(x, y) {\n    const element = document.createElement('div');\n    const image = getNextPhoto();\n    element.className = 'polaroid-photo';\n    element.innerHTML = `\n    <div class=\"polaroid-inner\">\n      <img src=\"${image}\" alt=\"Random photo\" />\n      <div class=\"polaroid-caption\"></div>\n    </div>\n  `;\n    // Random rotation and slight scale variation\n    const rotation = (Math.random() - 0.5) * 30; // -15 to 15 degrees\n    const scale = 0.8 + Math.random() * 0.4; // 0.8 to 1.2\n    element.style.cssText = `\n    position: fixed;\n    pointer-events: none;\n    z-index: 1000;\n    transform: translate(-50%, -50%) rotate(${rotation}deg) scale(${scale});\n    transition: none;\n  `;\n    // Set initial position immediately so it doesn't flash at (0,0)\n    element.style.left = `${x}px`;\n    element.style.top = `${y}px`;\n    const polaroidElement = {\n        element,\n        x,\n        y,\n        rotation,\n        scale,\n        opacity: 1,\n        life: config.polaroidLife,\n        maxLife: config.polaroidLife,\n        vx: (Math.random() - 0.5) * 2,\n        vy: (Math.random() - 0.5) * 2,\n        image\n    };\n    if (container) {\n        container.appendChild(element);\n    }\n    return polaroidElement;\n}\nfunction updatePolaroids() {\n    // If images aren't ready, skip updates (prevents blank placeholders)\n    if (!photosLoaded) return;\n    // Update existing polaroids\n    for(let i = polaroids.length - 1; i >= 0; i--){\n        const polaroid = polaroids[i];\n        // Update position with slight drift\n        polaroid.x += polaroid.vx;\n        polaroid.y += polaroid.vy;\n        // Apply slight drag\n        polaroid.vx *= 0.98;\n        polaroid.vy *= 0.98;\n        // Update life\n        polaroid.life--;\n        // Calculate opacity based on remaining life\n        if (polaroid.life < config.fadeOutDuration) {\n            polaroid.opacity = polaroid.life / config.fadeOutDuration;\n        }\n        // Update element position and opacity\n        polaroid.element.style.left = `${polaroid.x}px`;\n        polaroid.element.style.top = `${polaroid.y}px`;\n        polaroid.element.style.opacity = polaroid.opacity.toString();\n        // Remove dead polaroids\n        if (polaroid.life <= 0) {\n            if (container && polaroid.element.parentNode) {\n                container.removeChild(polaroid.element);\n            }\n            polaroids.splice(i, 1);\n        }\n    }\n    // Movement metrics and gating\n    const dx = mouseX - lastMouseX;\n    const dy = mouseY - lastMouseY;\n    const movement = Math.sqrt(dx * dx + dy * dy);\n    const isMoving = movement > config.minMovementThreshold;\n    // Track idle vs moving frames to avoid re-arming delay on micro pauses\n    if (isMoving) {\n        // Only arm a delay if we were truly idle for a bit\n        if (!wasMouseMoving && idleFrames >= IDLE_ARM_FRAMES) {\n            resumeDelay = RESUME_DELAY_FRAMES;\n            spawnTimer = 0; // reset cadence\n            resumeUntilMs = typeof performance !== 'undefined' ? performance.now() + 120 : 0; // ~120ms\n        }\n        idleFrames = 0;\n    } else {\n        idleFrames++;\n    }\n    // Time-based guard (more robust across frame rates)\n    if (resumeUntilMs && typeof performance !== 'undefined' && performance.now() < resumeUntilMs) {\n        wasMouseMoving = isMoving;\n        // DO NOT update lastMouse here; keep delta non-zero after delay\n        spawnTimer++; // advance cadence during delay so first spawn can happen right after\n        return;\n    } else {\n        resumeUntilMs = 0;\n    }\n    // Fallback frame-based guard\n    if (resumeDelay > 0) {\n        resumeDelay--;\n        wasMouseMoving = isMoving;\n        // DO NOT update lastMouse here; keep delta non-zero after delay\n        spawnTimer++; // advance cadence during frame-based delay\n        return;\n    }\n    // Advance cadence\n    spawnTimer++;\n    // Continuous spawning while moving\n    if (isMoving) {\n        if (spawnTimer >= config.spawnInterval) {\n            // Spawn away from the cursor to avoid covering it\n            const spawnDistance = 70 + Math.random() * 30; // 70-100px\n            const spawnAngle = Math.random() * Math.PI * 2;\n            const ringX = mouseX + Math.cos(spawnAngle) * spawnDistance;\n            const ringY = mouseY + Math.sin(spawnAngle) * spawnDistance;\n            // Spawn; replace oldest if at capacity\n            if (polaroids.length < config.maxPolaroids) {\n                polaroids.push(createPolaroidElement(ringX, ringY));\n            } else {\n                // Remove oldest polaroid and add new one for continuous flow\n                const oldest = polaroids.shift();\n                if (oldest && container && oldest.element.parentNode) {\n                    container.removeChild(oldest.element);\n                }\n                polaroids.push(createPolaroidElement(ringX, ringY));\n            }\n            spawnTimer = 0;\n        }\n    }\n    lastMouseX = mouseX;\n    lastMouseY = mouseY;\n    wasMouseMoving = isMoving;\n}\nfunction animate() {\n    updatePolaroids();\n    requestAnimationFrame(animate);\n}\n// Event handlers\nfunction attachEventListeners() {\n    if (true) return;\n    const mouseMoveHandler = (e)=>{\n        mouseX = e.clientX;\n        mouseY = e.clientY;\n    };\n    const mouseEnterHandler = (e)=>{\n        // Initialize mouse position when entering the page\n        mouseX = e.clientX;\n        mouseY = e.clientY;\n        lastMouseX = mouseX;\n        lastMouseY = mouseY;\n    };\n    const touchMoveHandler = (e)=>{\n        e.preventDefault();\n        if (e.touches.length > 0) {\n            const touch = e.touches[0];\n            mouseX = touch.clientX;\n            mouseY = touch.clientY;\n        }\n    };\n    const touchStartHandler = (e)=>{\n        if (e.touches.length > 0) {\n            const touch = e.touches[0];\n            mouseX = touch.clientX;\n            mouseY = touch.clientY;\n            lastMouseX = mouseX;\n            lastMouseY = mouseY;\n        }\n    };\n    document.addEventListener(\"mousemove\", mouseMoveHandler);\n    document.addEventListener(\"mouseenter\", mouseEnterHandler);\n    document.addEventListener(\"touchmove\", touchMoveHandler, {\n        passive: false\n    });\n    document.addEventListener(\"touchstart\", touchStartHandler, {\n        passive: true\n    });\n}\n// Main initialization function\nasync function initPolaroidCursor() {\n    if (true) return;\n    if (polaroidInitialized) {\n        console.log('Polaroid cursor already initialized');\n        return;\n    }\n    console.log('Initializing polaroid cursor effect...');\n    // Create container for polaroids\n    container = document.createElement('div');\n    container.id = 'polaroid-container';\n    container.style.cssText = `\n    position: fixed;\n    top: 0;\n    left: 0;\n    width: 100vw;\n    height: 100vh;\n    pointer-events: none;\n    z-index: 1000;\n  `;\n    document.body.appendChild(container);\n    // Initialize mouse position to center, but will be updated on first mouse move\n    mouseX = window.innerWidth / 2;\n    mouseY = window.innerHeight / 2;\n    lastMouseX = mouseX;\n    lastMouseY = mouseY;\n    // Get actual mouse position if available\n    document.addEventListener('mousemove', (e)=>{\n        if (mouseX === window.innerWidth / 2 && mouseY === window.innerHeight / 2) {\n            // First mouse move - initialize properly\n            mouseX = e.clientX;\n            mouseY = e.clientY;\n            lastMouseX = mouseX;\n            lastMouseY = mouseY;\n        }\n    }, {\n        once: true\n    });\n    // Attach event listeners immediately\n    attachEventListeners();\n    // Preload photos before starting the effect\n    try {\n        await preloadPhotos(photoList);\n        photosLoaded = true;\n    } catch (_) {\n        photosLoaded = true; // don't block in case of unexpected errors\n    }\n    // Start animation loop only after photos are loaded\n    animate();\n    polaroidInitialized = true;\n    console.log('Polaroid cursor effect initialized successfully!');\n}\n// Cleanup function\nfunction cleanupPolaroidCursor() {\n    if (container && container.parentNode) {\n        document.body.removeChild(container);\n    }\n    polaroids.forEach((polaroid)=>{\n        if (polaroid.element.parentNode) {\n            polaroid.element.parentNode.removeChild(polaroid.element);\n        }\n    });\n    polaroids = [];\n    container = null;\n    polaroidInitialized = false;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LEVBQUVDLE9BQU87WUFDbEJ0RixTQUFTcUYsRUFBRUUsT0FBTztZQUNsQnRGLGFBQWFGO1lBQ2JHLGFBQWFGO1FBQ2Y7SUFDRixHQUFHO1FBQUV3RyxNQUFNO0lBQUs7SUFFaEIscUNBQXFDO0lBQ3JDckI7SUFFQSw0Q0FBNEM7SUFDNUMsSUFBSTtRQUNGLE1BQU14RSxjQUFjRDtRQUNwQmQsZUFBZTtJQUNqQixFQUFFLE9BQU82RyxHQUFHO1FBQ1Y3RyxlQUFlLE1BQU0sMkNBQTJDO0lBQ2xFO0lBRUEsb0RBQW9EO0lBQ3BEcUY7SUFFQXRGLHNCQUFzQjtJQUN0QnNHLFFBQVFDLEdBQUcsQ0FBQztBQUNkO0FBRUEsbUJBQW1CO0FBQ1osU0FBU1E7SUFDZCxJQUFJN0csYUFBYUEsVUFBVWdFLFVBQVUsRUFBRTtRQUNyQ3hCLFNBQVMrRCxJQUFJLENBQUN0QyxXQUFXLENBQUNqRTtJQUM1QjtJQUVBQyxVQUFVNkcsT0FBTyxDQUFDaEQsQ0FBQUE7UUFDaEIsSUFBSUEsU0FBU3ZCLE9BQU8sQ0FBQ3lCLFVBQVUsRUFBRTtZQUMvQkYsU0FBU3ZCLE9BQU8sQ0FBQ3lCLFVBQVUsQ0FBQ0MsV0FBVyxDQUFDSCxTQUFTdkIsT0FBTztRQUMxRDtJQUNGO0lBRUF0QyxZQUFZLEVBQUU7SUFDZEQsWUFBWTtJQUNaRixzQkFBc0I7QUFDeEIiLCJzb3VyY2VzIjpbIi9Vc2Vycy95dmVzL1JlcG9zaXRvcmllcy95dmVzeWlsLnh5ei9hcHAvbGliL3BvbGFyb2lkLWN1cnNvci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBQb2xhcm9pZCBDdXJzb3IgRWZmZWN0XG4vLyBDcmVhdGVzIHBvbGFyb2lkIHBob3RvcyB0aGF0IGZvbGxvdyBtb3VzZSBtb3ZlbWVudFxuXG5sZXQgcG9sYXJvaWRJbml0aWFsaXplZCA9IGZhbHNlO1xubGV0IHBob3Rvc0xvYWRlZCA9IGZhbHNlO1xubGV0IGNvbnRhaW5lcjogSFRNTERpdkVsZW1lbnQgfCBudWxsID0gbnVsbDtcbmxldCBwb2xhcm9pZHM6IFBvbGFyb2lkRWxlbWVudFtdID0gW107XG5sZXQgbW91c2VYID0gMDtcbmxldCBtb3VzZVkgPSAwO1xubGV0IGxhc3RNb3VzZVggPSAwO1xubGV0IGxhc3RNb3VzZVkgPSAwO1xubGV0IHNwYXduVGltZXIgPSAwOyAvLyBUaW1lciBmb3IgY29uc2lzdGVudCBzcGF3bmluZ1xubGV0IHdhc01vdXNlTW92aW5nID0gZmFsc2U7XG5sZXQgcmVzdW1lRGVsYXkgPSAwOyAvLyBmcmFtZXMgdG8gZGVsYXkgYWZ0ZXIgbW92ZW1lbnQgcmVzdW1lc1xuY29uc3QgUkVTVU1FX0RFTEFZX0ZSQU1FUyA9IDU7IC8vIH4wLjFzIGF0IDYwZnBzXG5sZXQgcmVzdW1lVW50aWxNcyA9IDA7IC8vIHRpbWVzdGFtcCB1bnRpbCB3aGljaCB3ZSBkZWxheSBzcGF3bmluZyBhZnRlciByZXN1bWVcbmxldCBpZGxlRnJhbWVzID0gMDsgLy8gZnJhbWVzIG5vdCBtb3ZpbmdcbmNvbnN0IElETEVfQVJNX0ZSQU1FUyA9IDIwOyAvLyByZXF1aXJlIH4wLjMzcyBpZGxlIGJlZm9yZSBhcm1pbmcgcmVzdW1lIGRlbGF5XG5cbmludGVyZmFjZSBQb2xhcm9pZEVsZW1lbnQge1xuICBlbGVtZW50OiBIVE1MRGl2RWxlbWVudDtcbiAgeDogbnVtYmVyO1xuICB5OiBudW1iZXI7XG4gIHJvdGF0aW9uOiBudW1iZXI7XG4gIHNjYWxlOiBudW1iZXI7XG4gIG9wYWNpdHk6IG51bWJlcjtcbiAgbGlmZTogbnVtYmVyO1xuICBtYXhMaWZlOiBudW1iZXI7XG4gIHZ4OiBudW1iZXI7XG4gIHZ5OiBudW1iZXI7XG4gIGltYWdlOiBzdHJpbmc7XG59XG5cbi8vIFRpbnkgaW1hZ2VzIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2VcbmNvbnN0IHBob3RvTGlzdCA9IFtcbiAgJy9waG90b3MvdGlueS9BbmdlbEhvbGRpbmdDaGFsaWNlLmpwZycsXG4gICcvcGhvdG9zL3RpbnkvQVN0cmVldEluSGFhcmxlbS5qcGcnLFxuICAnL3Bob3Rvcy90aW55L0F1dG9wYXJrLmpwZycsXG4gICcvcGhvdG9zL3RpbnkvQ2FmZUhldFdhcGVuVmFuQmxvLmpwZycsXG4gICcvcGhvdG9zL3RpbnkvQ2FyaXRhc2Jyb25kZW4uanBnJyxcbiAgJy9waG90b3MvdGlueS9DYXRMYXlpbmcuanBnJyxcbiAgJy9waG90b3MvdGlueS9DYXRXaXRoTGFyZ2VDb2xsYXIuanBnJyxcbiAgJy9waG90b3MvdGlueS9DaHVyY2hJblRoZURpc3RhbmNlLmpwZycsXG4gICcvcGhvdG9zL3RpbnkvQ293cy5qcGcnLFxuICAnL3Bob3Rvcy90aW55L0Nvd3NDdXJpb3VzLmpwZycsXG4gICcvcGhvdG9zL3RpbnkvRGVCdXJjaHQuanBnJyxcbiAgJy9waG90b3MvdGlueS9GcmVkZXJpa3NiZXJnU2xvdC5qcGcnLFxuICAnL3Bob3Rvcy90aW55L0dyYXNzUGxhbmUuanBnJyxcbiAgJy9waG90b3MvdGlueS9MYWtlLmpwZycsXG4gICcvcGhvdG9zL3RpbnkvTWFhbi5qcGcnLFxuICAnL3Bob3Rvcy90aW55L01lcm1haWQuanBnJyxcbiAgJy9waG90b3MvdGlueS9PZmZpY2UuanBnJyxcbiAgJy9waG90b3MvdGlueS9TQUlMLmpwZycsXG4gICcvcGhvdG9zL3RpbnkvU2ludEJvbmlmYXRpdXNrZXJrLmpwZycsXG4gICcvcGhvdG9zL3RpbnkvU3RhaXJzLmpwZycsXG4gICcvcGhvdG9zL3RpbnkvWmFhblJpdmVyLmpwZycsXG5dO1xuXG5hc3luYyBmdW5jdGlvbiBwcmVsb2FkUGhvdG9zKHVybHM6IHN0cmluZ1tdKTogUHJvbWlzZTx2b2lkPiB7XG4gIGNvbnN0IGxvYWRlcnMgPSB1cmxzLm1hcCgoc3JjKSA9PlxuICAgIG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlKSA9PiB7XG4gICAgICBjb25zdCBpbWcgPSBuZXcgSW1hZ2UoKTtcbiAgICAgIGltZy5vbmxvYWQgPSAoKSA9PiByZXNvbHZlKCk7XG4gICAgICBpbWcub25lcnJvciA9ICgpID0+IHJlc29sdmUoKTsgLy8gdHJlYXQgZXJyb3JzIGFzIHJlc29sdmVkIHRvIGF2b2lkIGJsb2NraW5nXG4gICAgICBpbWcuc3JjID0gc3JjO1xuICAgIH0pXG4gICk7XG4gIGF3YWl0IFByb21pc2UuYWxsKGxvYWRlcnMpO1xufVxuXG5jb25zdCBjb25maWcgPSB7XG4gIG1heFBvbGFyb2lkczogMjAsIC8vIEhpZ2hlciBsaW1pdCB0byBwcmV2ZW50IHBhdXNlc1xuICBwb2xhcm9pZExpZmU6IDYwLCAvLyBTaG9ydGVyIGxpZmUgc28gcGhvdG9zIGN5Y2xlIGZhc3RlclxuICBzcGF3bkludGVydmFsOiA4LCAvLyBTcGF3biBldmVyeSA0IGZyYW1lcyAoMTUgdGltZXMgcGVyIHNlY29uZClcbiAgZmFkZU91dER1cmF0aW9uOiAzMCwgLy8gRmFzdGVyIGZhZGUgZm9yIHF1aWNrZXIgdHVybm92ZXJcbiAgbWluTW92ZW1lbnRUaHJlc2hvbGQ6IDEsIC8vIExvd2VyIHRocmVzaG9sZFxuICBwb2xhcm9pZFNpemU6IDE0MCwgLy8gQmlnZ2VyIHBob3Rvc1xufTtcblxubGV0IHBob3RvSW5kZXggPSAwO1xuZnVuY3Rpb24gZ2V0TmV4dFBob3RvKCk6IHN0cmluZyB7XG4gIGNvbnN0IHNyYyA9IHBob3RvTGlzdFtwaG90b0luZGV4XTtcbiAgcGhvdG9JbmRleCA9IChwaG90b0luZGV4ICsgMSkgJSBwaG90b0xpc3QubGVuZ3RoO1xuICByZXR1cm4gc3JjO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVQb2xhcm9pZEVsZW1lbnQoeDogbnVtYmVyLCB5OiBudW1iZXIpOiBQb2xhcm9pZEVsZW1lbnQge1xuICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGNvbnN0IGltYWdlID0gZ2V0TmV4dFBob3RvKCk7XG4gIFxuICBlbGVtZW50LmNsYXNzTmFtZSA9ICdwb2xhcm9pZC1waG90byc7XG4gIGVsZW1lbnQuaW5uZXJIVE1MID0gYFxuICAgIDxkaXYgY2xhc3M9XCJwb2xhcm9pZC1pbm5lclwiPlxuICAgICAgPGltZyBzcmM9XCIke2ltYWdlfVwiIGFsdD1cIlJhbmRvbSBwaG90b1wiIC8+XG4gICAgICA8ZGl2IGNsYXNzPVwicG9sYXJvaWQtY2FwdGlvblwiPjwvZGl2PlxuICAgIDwvZGl2PlxuICBgO1xuICBcbiAgLy8gUmFuZG9tIHJvdGF0aW9uIGFuZCBzbGlnaHQgc2NhbGUgdmFyaWF0aW9uXG4gIGNvbnN0IHJvdGF0aW9uID0gKE1hdGgucmFuZG9tKCkgLSAwLjUpICogMzA7IC8vIC0xNSB0byAxNSBkZWdyZWVzXG4gIGNvbnN0IHNjYWxlID0gMC44ICsgTWF0aC5yYW5kb20oKSAqIDAuNDsgLy8gMC44IHRvIDEuMlxuICBcbiAgZWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gYFxuICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgICB6LWluZGV4OiAxMDAwO1xuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKC01MCUsIC01MCUpIHJvdGF0ZSgke3JvdGF0aW9ufWRlZykgc2NhbGUoJHtzY2FsZX0pO1xuICAgIHRyYW5zaXRpb246IG5vbmU7XG4gIGA7XG4gIC8vIFNldCBpbml0aWFsIHBvc2l0aW9uIGltbWVkaWF0ZWx5IHNvIGl0IGRvZXNuJ3QgZmxhc2ggYXQgKDAsMClcbiAgZWxlbWVudC5zdHlsZS5sZWZ0ID0gYCR7eH1weGA7XG4gIGVsZW1lbnQuc3R5bGUudG9wID0gYCR7eX1weGA7XG4gIFxuICBjb25zdCBwb2xhcm9pZEVsZW1lbnQ6IFBvbGFyb2lkRWxlbWVudCA9IHtcbiAgICBlbGVtZW50LFxuICAgIHgsXG4gICAgeSxcbiAgICByb3RhdGlvbixcbiAgICBzY2FsZSxcbiAgICBvcGFjaXR5OiAxLFxuICAgIGxpZmU6IGNvbmZpZy5wb2xhcm9pZExpZmUsXG4gICAgbWF4TGlmZTogY29uZmlnLnBvbGFyb2lkTGlmZSxcbiAgICB2eDogKE1hdGgucmFuZG9tKCkgLSAwLjUpICogMixcbiAgICB2eTogKE1hdGgucmFuZG9tKCkgLSAwLjUpICogMixcbiAgICBpbWFnZVxuICB9O1xuICBcbiAgaWYgKGNvbnRhaW5lcikge1xuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChlbGVtZW50KTtcbiAgfVxuICBcbiAgcmV0dXJuIHBvbGFyb2lkRWxlbWVudDtcbn1cblxuZnVuY3Rpb24gdXBkYXRlUG9sYXJvaWRzKCkge1xuICAvLyBJZiBpbWFnZXMgYXJlbid0IHJlYWR5LCBza2lwIHVwZGF0ZXMgKHByZXZlbnRzIGJsYW5rIHBsYWNlaG9sZGVycylcbiAgaWYgKCFwaG90b3NMb2FkZWQpIHJldHVybjtcbiAgLy8gVXBkYXRlIGV4aXN0aW5nIHBvbGFyb2lkc1xuICBmb3IgKGxldCBpID0gcG9sYXJvaWRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgY29uc3QgcG9sYXJvaWQgPSBwb2xhcm9pZHNbaV07XG4gICAgXG4gICAgLy8gVXBkYXRlIHBvc2l0aW9uIHdpdGggc2xpZ2h0IGRyaWZ0XG4gICAgcG9sYXJvaWQueCArPSBwb2xhcm9pZC52eDtcbiAgICBwb2xhcm9pZC55ICs9IHBvbGFyb2lkLnZ5O1xuICAgIFxuICAgIC8vIEFwcGx5IHNsaWdodCBkcmFnXG4gICAgcG9sYXJvaWQudnggKj0gMC45ODtcbiAgICBwb2xhcm9pZC52eSAqPSAwLjk4O1xuICAgIFxuICAgIC8vIFVwZGF0ZSBsaWZlXG4gICAgcG9sYXJvaWQubGlmZS0tO1xuICAgIFxuICAgIC8vIENhbGN1bGF0ZSBvcGFjaXR5IGJhc2VkIG9uIHJlbWFpbmluZyBsaWZlXG4gICAgaWYgKHBvbGFyb2lkLmxpZmUgPCBjb25maWcuZmFkZU91dER1cmF0aW9uKSB7XG4gICAgICBwb2xhcm9pZC5vcGFjaXR5ID0gcG9sYXJvaWQubGlmZSAvIGNvbmZpZy5mYWRlT3V0RHVyYXRpb247XG4gICAgfVxuICAgIFxuICAgIC8vIFVwZGF0ZSBlbGVtZW50IHBvc2l0aW9uIGFuZCBvcGFjaXR5XG4gICAgcG9sYXJvaWQuZWxlbWVudC5zdHlsZS5sZWZ0ID0gYCR7cG9sYXJvaWQueH1weGA7XG4gICAgcG9sYXJvaWQuZWxlbWVudC5zdHlsZS50b3AgPSBgJHtwb2xhcm9pZC55fXB4YDtcbiAgICBwb2xhcm9pZC5lbGVtZW50LnN0eWxlLm9wYWNpdHkgPSBwb2xhcm9pZC5vcGFjaXR5LnRvU3RyaW5nKCk7XG4gICAgXG4gICAgLy8gUmVtb3ZlIGRlYWQgcG9sYXJvaWRzXG4gICAgaWYgKHBvbGFyb2lkLmxpZmUgPD0gMCkge1xuICAgICAgaWYgKGNvbnRhaW5lciAmJiBwb2xhcm9pZC5lbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgICAgY29udGFpbmVyLnJlbW92ZUNoaWxkKHBvbGFyb2lkLmVsZW1lbnQpO1xuICAgICAgfVxuICAgICAgcG9sYXJvaWRzLnNwbGljZShpLCAxKTtcbiAgICB9XG4gIH1cbiAgXG4gIC8vIE1vdmVtZW50IG1ldHJpY3MgYW5kIGdhdGluZ1xuICBjb25zdCBkeCA9IG1vdXNlWCAtIGxhc3RNb3VzZVg7XG4gIGNvbnN0IGR5ID0gbW91c2VZIC0gbGFzdE1vdXNlWTtcbiAgY29uc3QgbW92ZW1lbnQgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICBjb25zdCBpc01vdmluZyA9IG1vdmVtZW50ID4gY29uZmlnLm1pbk1vdmVtZW50VGhyZXNob2xkO1xuXG4gIC8vIFRyYWNrIGlkbGUgdnMgbW92aW5nIGZyYW1lcyB0byBhdm9pZCByZS1hcm1pbmcgZGVsYXkgb24gbWljcm8gcGF1c2VzXG4gIGlmIChpc01vdmluZykge1xuICAgIC8vIE9ubHkgYXJtIGEgZGVsYXkgaWYgd2Ugd2VyZSB0cnVseSBpZGxlIGZvciBhIGJpdFxuICAgIGlmICghd2FzTW91c2VNb3ZpbmcgJiYgaWRsZUZyYW1lcyA+PSBJRExFX0FSTV9GUkFNRVMpIHtcbiAgICAgIHJlc3VtZURlbGF5ID0gUkVTVU1FX0RFTEFZX0ZSQU1FUztcbiAgICAgIHNwYXduVGltZXIgPSAwOyAvLyByZXNldCBjYWRlbmNlXG4gICAgICByZXN1bWVVbnRpbE1zID0gdHlwZW9mIHBlcmZvcm1hbmNlICE9PSAndW5kZWZpbmVkJyA/IHBlcmZvcm1hbmNlLm5vdygpICsgMTIwIDogMDsgLy8gfjEyMG1zXG4gICAgfVxuICAgIGlkbGVGcmFtZXMgPSAwO1xuICB9IGVsc2Uge1xuICAgIGlkbGVGcmFtZXMrKztcbiAgfVxuXG4gIC8vIFRpbWUtYmFzZWQgZ3VhcmQgKG1vcmUgcm9idXN0IGFjcm9zcyBmcmFtZSByYXRlcylcbiAgaWYgKHJlc3VtZVVudGlsTXMgJiYgdHlwZW9mIHBlcmZvcm1hbmNlICE9PSAndW5kZWZpbmVkJyAmJiBwZXJmb3JtYW5jZS5ub3coKSA8IHJlc3VtZVVudGlsTXMpIHtcbiAgICB3YXNNb3VzZU1vdmluZyA9IGlzTW92aW5nO1xuICAgIC8vIERPIE5PVCB1cGRhdGUgbGFzdE1vdXNlIGhlcmU7IGtlZXAgZGVsdGEgbm9uLXplcm8gYWZ0ZXIgZGVsYXlcbiAgICBzcGF3blRpbWVyKys7IC8vIGFkdmFuY2UgY2FkZW5jZSBkdXJpbmcgZGVsYXkgc28gZmlyc3Qgc3Bhd24gY2FuIGhhcHBlbiByaWdodCBhZnRlclxuICAgIHJldHVybjtcbiAgfSBlbHNlIHtcbiAgICByZXN1bWVVbnRpbE1zID0gMDtcbiAgfVxuXG4gIC8vIEZhbGxiYWNrIGZyYW1lLWJhc2VkIGd1YXJkXG4gIGlmIChyZXN1bWVEZWxheSA+IDApIHtcbiAgICByZXN1bWVEZWxheS0tO1xuICAgIHdhc01vdXNlTW92aW5nID0gaXNNb3Zpbmc7XG4gICAgLy8gRE8gTk9UIHVwZGF0ZSBsYXN0TW91c2UgaGVyZTsga2VlcCBkZWx0YSBub24temVybyBhZnRlciBkZWxheVxuICAgIHNwYXduVGltZXIrKzsgLy8gYWR2YW5jZSBjYWRlbmNlIGR1cmluZyBmcmFtZS1iYXNlZCBkZWxheVxuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEFkdmFuY2UgY2FkZW5jZVxuICBzcGF3blRpbWVyKys7XG4gIFxuICAvLyBDb250aW51b3VzIHNwYXduaW5nIHdoaWxlIG1vdmluZ1xuICBpZiAoaXNNb3ZpbmcpIHtcbiAgICBpZiAoc3Bhd25UaW1lciA+PSBjb25maWcuc3Bhd25JbnRlcnZhbCkge1xuICAgICAgLy8gU3Bhd24gYXdheSBmcm9tIHRoZSBjdXJzb3IgdG8gYXZvaWQgY292ZXJpbmcgaXRcbiAgICAgIGNvbnN0IHNwYXduRGlzdGFuY2UgPSA3MCArIE1hdGgucmFuZG9tKCkgKiAzMDsgLy8gNzAtMTAwcHhcbiAgICAgIGNvbnN0IHNwYXduQW5nbGUgPSBNYXRoLnJhbmRvbSgpICogTWF0aC5QSSAqIDI7XG4gICAgICBjb25zdCByaW5nWCA9IG1vdXNlWCArIE1hdGguY29zKHNwYXduQW5nbGUpICogc3Bhd25EaXN0YW5jZTtcbiAgICAgIGNvbnN0IHJpbmdZID0gbW91c2VZICsgTWF0aC5zaW4oc3Bhd25BbmdsZSkgKiBzcGF3bkRpc3RhbmNlO1xuXG4gICAgICAvLyBTcGF3bjsgcmVwbGFjZSBvbGRlc3QgaWYgYXQgY2FwYWNpdHlcbiAgICAgIGlmIChwb2xhcm9pZHMubGVuZ3RoIDwgY29uZmlnLm1heFBvbGFyb2lkcykge1xuICAgICAgICBwb2xhcm9pZHMucHVzaChjcmVhdGVQb2xhcm9pZEVsZW1lbnQocmluZ1gsIHJpbmdZKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBSZW1vdmUgb2xkZXN0IHBvbGFyb2lkIGFuZCBhZGQgbmV3IG9uZSBmb3IgY29udGludW91cyBmbG93XG4gICAgICAgIGNvbnN0IG9sZGVzdCA9IHBvbGFyb2lkcy5zaGlmdCgpO1xuICAgICAgICBpZiAob2xkZXN0ICYmIGNvbnRhaW5lciAmJiBvbGRlc3QuZWxlbWVudC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgY29udGFpbmVyLnJlbW92ZUNoaWxkKG9sZGVzdC5lbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICBwb2xhcm9pZHMucHVzaChjcmVhdGVQb2xhcm9pZEVsZW1lbnQocmluZ1gsIHJpbmdZKSk7XG4gICAgICB9XG4gICAgICBzcGF3blRpbWVyID0gMDtcbiAgICB9XG4gIH1cbiAgXG4gIGxhc3RNb3VzZVggPSBtb3VzZVg7XG4gIGxhc3RNb3VzZVkgPSBtb3VzZVk7XG4gIHdhc01vdXNlTW92aW5nID0gaXNNb3Zpbmc7XG59XG5cbmZ1bmN0aW9uIGFuaW1hdGUoKSB7XG4gIHVwZGF0ZVBvbGFyb2lkcygpO1xuICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZSk7XG59XG5cbi8vIEV2ZW50IGhhbmRsZXJzXG5mdW5jdGlvbiBhdHRhY2hFdmVudExpc3RlbmVycygpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm47XG5cbiAgY29uc3QgbW91c2VNb3ZlSGFuZGxlciA9IChlOiBNb3VzZUV2ZW50KSA9PiB7XG4gICAgbW91c2VYID0gZS5jbGllbnRYO1xuICAgIG1vdXNlWSA9IGUuY2xpZW50WTtcbiAgfTtcblxuICBjb25zdCBtb3VzZUVudGVySGFuZGxlciA9IChlOiBNb3VzZUV2ZW50KSA9PiB7XG4gICAgLy8gSW5pdGlhbGl6ZSBtb3VzZSBwb3NpdGlvbiB3aGVuIGVudGVyaW5nIHRoZSBwYWdlXG4gICAgbW91c2VYID0gZS5jbGllbnRYO1xuICAgIG1vdXNlWSA9IGUuY2xpZW50WTtcbiAgICBsYXN0TW91c2VYID0gbW91c2VYO1xuICAgIGxhc3RNb3VzZVkgPSBtb3VzZVk7XG4gIH07XG5cbiAgY29uc3QgdG91Y2hNb3ZlSGFuZGxlciA9IChlOiBUb3VjaEV2ZW50KSA9PiB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGlmIChlLnRvdWNoZXMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgdG91Y2ggPSBlLnRvdWNoZXNbMF07XG4gICAgICBtb3VzZVggPSB0b3VjaC5jbGllbnRYO1xuICAgICAgbW91c2VZID0gdG91Y2guY2xpZW50WTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgdG91Y2hTdGFydEhhbmRsZXIgPSAoZTogVG91Y2hFdmVudCkgPT4ge1xuICAgIGlmIChlLnRvdWNoZXMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgdG91Y2ggPSBlLnRvdWNoZXNbMF07XG4gICAgICBtb3VzZVggPSB0b3VjaC5jbGllbnRYO1xuICAgICAgbW91c2VZID0gdG91Y2guY2xpZW50WTtcbiAgICAgIGxhc3RNb3VzZVggPSBtb3VzZVg7XG4gICAgICBsYXN0TW91c2VZID0gbW91c2VZO1xuICAgIH1cbiAgfTtcblxuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIG1vdXNlTW92ZUhhbmRsZXIpO1xuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2VlbnRlclwiLCBtb3VzZUVudGVySGFuZGxlcik7XG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgdG91Y2hNb3ZlSGFuZGxlciwgeyBwYXNzaXZlOiBmYWxzZSB9KTtcbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgdG91Y2hTdGFydEhhbmRsZXIsIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcbn1cblxuLy8gTWFpbiBpbml0aWFsaXphdGlvbiBmdW5jdGlvblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGluaXRQb2xhcm9pZEN1cnNvcigpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm47XG4gIFxuICBpZiAocG9sYXJvaWRJbml0aWFsaXplZCkge1xuICAgIGNvbnNvbGUubG9nKCdQb2xhcm9pZCBjdXJzb3IgYWxyZWFkeSBpbml0aWFsaXplZCcpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnNvbGUubG9nKCdJbml0aWFsaXppbmcgcG9sYXJvaWQgY3Vyc29yIGVmZmVjdC4uLicpO1xuXG4gIC8vIENyZWF0ZSBjb250YWluZXIgZm9yIHBvbGFyb2lkc1xuICBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgY29udGFpbmVyLmlkID0gJ3BvbGFyb2lkLWNvbnRhaW5lcic7XG4gIGNvbnRhaW5lci5zdHlsZS5jc3NUZXh0ID0gYFxuICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICB0b3A6IDA7XG4gICAgbGVmdDogMDtcbiAgICB3aWR0aDogMTAwdnc7XG4gICAgaGVpZ2h0OiAxMDB2aDtcbiAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgICB6LWluZGV4OiAxMDAwO1xuICBgO1xuICBcbiAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjb250YWluZXIpO1xuXG4gIC8vIEluaXRpYWxpemUgbW91c2UgcG9zaXRpb24gdG8gY2VudGVyLCBidXQgd2lsbCBiZSB1cGRhdGVkIG9uIGZpcnN0IG1vdXNlIG1vdmVcbiAgbW91c2VYID0gd2luZG93LmlubmVyV2lkdGggLyAyO1xuICBtb3VzZVkgPSB3aW5kb3cuaW5uZXJIZWlnaHQgLyAyO1xuICBsYXN0TW91c2VYID0gbW91c2VYO1xuICBsYXN0TW91c2VZID0gbW91c2VZO1xuXG4gIC8vIEdldCBhY3R1YWwgbW91c2UgcG9zaXRpb24gaWYgYXZhaWxhYmxlXG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIChlKSA9PiB7XG4gICAgaWYgKG1vdXNlWCA9PT0gd2luZG93LmlubmVyV2lkdGggLyAyICYmIG1vdXNlWSA9PT0gd2luZG93LmlubmVySGVpZ2h0IC8gMikge1xuICAgICAgLy8gRmlyc3QgbW91c2UgbW92ZSAtIGluaXRpYWxpemUgcHJvcGVybHlcbiAgICAgIG1vdXNlWCA9IGUuY2xpZW50WDtcbiAgICAgIG1vdXNlWSA9IGUuY2xpZW50WTtcbiAgICAgIGxhc3RNb3VzZVggPSBtb3VzZVg7XG4gICAgICBsYXN0TW91c2VZID0gbW91c2VZO1xuICAgIH1cbiAgfSwgeyBvbmNlOiB0cnVlIH0pO1xuXG4gIC8vIEF0dGFjaCBldmVudCBsaXN0ZW5lcnMgaW1tZWRpYXRlbHlcbiAgYXR0YWNoRXZlbnRMaXN0ZW5lcnMoKTtcblxuICAvLyBQcmVsb2FkIHBob3RvcyBiZWZvcmUgc3RhcnRpbmcgdGhlIGVmZmVjdFxuICB0cnkge1xuICAgIGF3YWl0IHByZWxvYWRQaG90b3MocGhvdG9MaXN0KTtcbiAgICBwaG90b3NMb2FkZWQgPSB0cnVlO1xuICB9IGNhdGNoIChfKSB7XG4gICAgcGhvdG9zTG9hZGVkID0gdHJ1ZTsgLy8gZG9uJ3QgYmxvY2sgaW4gY2FzZSBvZiB1bmV4cGVjdGVkIGVycm9yc1xuICB9XG5cbiAgLy8gU3RhcnQgYW5pbWF0aW9uIGxvb3Agb25seSBhZnRlciBwaG90b3MgYXJlIGxvYWRlZFxuICBhbmltYXRlKCk7XG5cbiAgcG9sYXJvaWRJbml0aWFsaXplZCA9IHRydWU7XG4gIGNvbnNvbGUubG9nKCdQb2xhcm9pZCBjdXJzb3IgZWZmZWN0IGluaXRpYWxpemVkIHN1Y2Nlc3NmdWxseSEnKTtcbn1cblxuLy8gQ2xlYW51cCBmdW5jdGlvblxuZXhwb3J0IGZ1bmN0aW9uIGNsZWFudXBQb2xhcm9pZEN1cnNvcigpIHtcbiAgaWYgKGNvbnRhaW5lciAmJiBjb250YWluZXIucGFyZW50Tm9kZSkge1xuICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoY29udGFpbmVyKTtcbiAgfVxuICBcbiAgcG9sYXJvaWRzLmZvckVhY2gocG9sYXJvaWQgPT4ge1xuICAgIGlmIChwb2xhcm9pZC5lbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgIHBvbGFyb2lkLmVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChwb2xhcm9pZC5lbGVtZW50KTtcbiAgICB9XG4gIH0pO1xuICBcbiAgcG9sYXJvaWRzID0gW107XG4gIGNvbnRhaW5lciA9IG51bGw7XG4gIHBvbGFyb2lkSW5pdGlhbGl6ZWQgPSBmYWxzZTtcbn1cbiJdLCJuYW1lcyI6WyJwb2xhcm9pZEluaXRpYWxpemVkIiwicGhvdG9zTG9hZGVkIiwiY29udGFpbmVyIiwicG9sYXJvaWRzIiwibW91c2VYIiwibW91c2VZIiwibGFzdE1vdXNlWCIsImxhc3RNb3VzZVkiLCJzcGF3blRpbWVyIiwid2FzTW91c2VNb3ZpbmciLCJyZXN1bWVEZWxheSIsIlJFU1VNRV9ERUxBWV9GUkFNRVMiLCJyZXN1bWVVbnRpbE1zIiwiaWRsZUZyYW1lcyIsIklETEVfQVJNX0ZSQU1FUyIsInBob3RvTGlzdCIsInByZWxvYWRQaG90b3MiLCJ1cmxzIiwibG9hZGVycyIsIm1hcCIsInNyYyIsIlByb21pc2UiLCJyZXNvbHZlIiwiaW1nIiwiSW1hZ2UiLCJvbmxvYWQiLCJvbmVycm9yIiwiYWxsIiwiY29uZmlnIiwibWF4UG9sYXJvaWRzIiwicG9sYXJvaWRMaWZlIiwic3Bhd25JbnRlcnZhbCIsImZhZGVPdXREdXJhdGlvbiIsIm1pbk1vdmVtZW50VGhyZXNob2xkIiwicG9sYXJvaWRTaXplIiwicGhvdG9JbmRleCIsImdldE5leHRQaG90byIsImxlbmd0aCIsImNyZWF0ZVBvbGFyb2lkRWxlbWVudCIsIngiLCJ5IiwiZWxlbWVudCIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImltYWdlIiwiY2xhc3NOYW1lIiwiaW5uZXJIVE1MIiwicm90YXRpb24iLCJNYXRoIiwicmFuZG9tIiwic2NhbGUiLCJzdHlsZSIsImNzc1RleHQiLCJsZWZ0IiwidG9wIiwicG9sYXJvaWRFbGVtZW50Iiwib3BhY2l0eSIsImxpZmUiLCJtYXhMaWZlIiwidngiLCJ2eSIsImFwcGVuZENoaWxkIiwidXBkYXRlUG9sYXJvaWRzIiwiaSIsInBvbGFyb2lkIiwidG9TdHJpbmciLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJzcGxpY2UiLCJkeCIsImR5IiwibW92ZW1lbnQiLCJzcXJ0IiwiaXNNb3ZpbmciLCJwZXJmb3JtYW5jZSIsIm5vdyIsInNwYXduRGlzdGFuY2UiLCJzcGF3bkFuZ2xlIiwiUEkiLCJyaW5nWCIsImNvcyIsInJpbmdZIiwic2luIiwicHVzaCIsIm9sZGVzdCIsInNoaWZ0IiwiYW5pbWF0ZSIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImF0dGFjaEV2ZW50TGlzdGVuZXJzIiwibW91c2VNb3ZlSGFuZGxlciIsImUiLCJjbGllbnRYIiwiY2xpZW50WSIsIm1vdXNlRW50ZXJIYW5kbGVyIiwidG91Y2hNb3ZlSGFuZGxlciIsInByZXZlbnREZWZhdWx0IiwidG91Y2hlcyIsInRvdWNoIiwidG91Y2hTdGFydEhhbmRsZXIiLCJhZGRFdmVudExpc3RlbmVyIiwicGFzc2l2ZSIsImluaXRQb2xhcm9pZEN1cnNvciIsImNvbnNvbGUiLCJsb2ciLCJpZCIsImJvZHkiLCJ3aW5kb3ciLCJpbm5lcldpZHRoIiwiaW5uZXJIZWlnaHQiLCJvbmNlIiwiXyIsImNsZWFudXBQb2xhcm9pZEN1cnNvciIsImZvckVhY2giXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./app/lib/polaroid-cursor.ts\n");

/***/ })

};
;