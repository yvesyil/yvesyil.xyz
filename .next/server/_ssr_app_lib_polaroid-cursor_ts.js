"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "_ssr_app_lib_polaroid-cursor_ts";
exports.ids = ["_ssr_app_lib_polaroid-cursor_ts"];
exports.modules = {

/***/ "(ssr)/./app/lib/polaroid-cursor.ts":
/*!************************************!*\
  !*** ./app/lib/polaroid-cursor.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cleanupPolaroidCursor: () => (/* binding */ cleanupPolaroidCursor),\n/* harmony export */   initPolaroidCursor: () => (/* binding */ initPolaroidCursor)\n/* harmony export */ });\n// Polaroid Cursor Effect\n// Creates polaroid photos that follow mouse movement\nlet polaroidInitialized = false;\nlet container = null;\nlet polaroids = [];\nlet mouseX = 0;\nlet mouseY = 0;\nlet lastMouseX = 0;\nlet lastMouseY = 0;\nlet spawnTimer = 0; // Timer for consistent spawning\nlet wasMouseMoving = false;\nlet resumeDelay = 0; // frames to delay after movement resumes\nconst RESUME_DELAY_FRAMES = 5; // ~0.1s at 60fps\nlet resumeUntilMs = 0; // timestamp until which we delay spawning after resume\nlet idleFrames = 0; // frames not moving\nconst IDLE_ARM_FRAMES = 20; // require ~0.33s idle before arming resume delay\n// Tiny images for better performance\nconst photoList = [\n    '/photos/tiny/AngelHoldingChalice.jpg',\n    '/photos/tiny/AStreetInHaarlem.jpg',\n    '/photos/tiny/Autopark.jpg',\n    '/photos/tiny/CafeHetWapenVanBlo.jpg',\n    '/photos/tiny/Caritasbronden.jpg',\n    '/photos/tiny/CatLaying.jpg',\n    '/photos/tiny/CatWithLargeCollar.jpg',\n    '/photos/tiny/ChurchInTheDistance.jpg',\n    '/photos/tiny/Cows.jpg',\n    '/photos/tiny/CowsCurious.jpg',\n    '/photos/tiny/DeBurcht.jpg',\n    '/photos/tiny/FrederiksbergSlot.jpg',\n    '/photos/tiny/GrassPlane.jpg',\n    '/photos/tiny/Lake.jpg',\n    '/photos/tiny/Maan.jpg',\n    '/photos/tiny/Mermaid.jpg',\n    '/photos/tiny/Office.jpg',\n    '/photos/tiny/SAIL.jpg',\n    '/photos/tiny/SintBonifatiuskerk.jpg',\n    '/photos/tiny/Stairs.jpg',\n    '/photos/tiny/ZaanRiver.jpg'\n];\nconst config = {\n    maxPolaroids: 20,\n    polaroidLife: 60,\n    spawnInterval: 8,\n    fadeOutDuration: 30,\n    minMovementThreshold: 1,\n    polaroidSize: 140\n};\nlet photoIndex = 0;\nfunction getNextPhoto() {\n    const src = photoList[photoIndex];\n    photoIndex = (photoIndex + 1) % photoList.length;\n    return src;\n}\nfunction createPolaroidElement(x, y) {\n    const element = document.createElement('div');\n    const image = getNextPhoto();\n    element.className = 'polaroid-photo';\n    element.innerHTML = `\n    <div class=\"polaroid-inner\">\n      <img src=\"${image}\" alt=\"Random photo\" />\n      <div class=\"polaroid-caption\"></div>\n    </div>\n  `;\n    // Random rotation and slight scale variation\n    const rotation = (Math.random() - 0.5) * 30; // -15 to 15 degrees\n    const scale = 0.8 + Math.random() * 0.4; // 0.8 to 1.2\n    element.style.cssText = `\n    position: fixed;\n    pointer-events: none;\n    z-index: 1000;\n    transform: translate(-50%, -50%) rotate(${rotation}deg) scale(${scale});\n    transition: none;\n  `;\n    // Set initial position immediately so it doesn't flash at (0,0)\n    element.style.left = `${x}px`;\n    element.style.top = `${y}px`;\n    const polaroidElement = {\n        element,\n        x,\n        y,\n        rotation,\n        scale,\n        opacity: 1,\n        life: config.polaroidLife,\n        maxLife: config.polaroidLife,\n        vx: (Math.random() - 0.5) * 2,\n        vy: (Math.random() - 0.5) * 2,\n        image\n    };\n    if (container) {\n        container.appendChild(element);\n    }\n    return polaroidElement;\n}\nfunction updatePolaroids() {\n    // Update existing polaroids\n    for(let i = polaroids.length - 1; i >= 0; i--){\n        const polaroid = polaroids[i];\n        // Update position with slight drift\n        polaroid.x += polaroid.vx;\n        polaroid.y += polaroid.vy;\n        // Apply slight drag\n        polaroid.vx *= 0.98;\n        polaroid.vy *= 0.98;\n        // Update life\n        polaroid.life--;\n        // Calculate opacity based on remaining life\n        if (polaroid.life < config.fadeOutDuration) {\n            polaroid.opacity = polaroid.life / config.fadeOutDuration;\n        }\n        // Update element position and opacity\n        polaroid.element.style.left = `${polaroid.x}px`;\n        polaroid.element.style.top = `${polaroid.y}px`;\n        polaroid.element.style.opacity = polaroid.opacity.toString();\n        // Remove dead polaroids\n        if (polaroid.life <= 0) {\n            if (container && polaroid.element.parentNode) {\n                container.removeChild(polaroid.element);\n            }\n            polaroids.splice(i, 1);\n        }\n    }\n    // Movement metrics and gating\n    const dx = mouseX - lastMouseX;\n    const dy = mouseY - lastMouseY;\n    const movement = Math.sqrt(dx * dx + dy * dy);\n    const isMoving = movement > config.minMovementThreshold;\n    // Track idle vs moving frames to avoid re-arming delay on micro pauses\n    if (isMoving) {\n        // Only arm a delay if we were truly idle for a bit\n        if (!wasMouseMoving && idleFrames >= IDLE_ARM_FRAMES) {\n            resumeDelay = RESUME_DELAY_FRAMES;\n            spawnTimer = 0; // reset cadence\n            resumeUntilMs = typeof performance !== 'undefined' ? performance.now() + 120 : 0; // ~120ms\n        }\n        idleFrames = 0;\n    } else {\n        idleFrames++;\n    }\n    // Time-based guard (more robust across frame rates)\n    if (resumeUntilMs && typeof performance !== 'undefined' && performance.now() < resumeUntilMs) {\n        wasMouseMoving = isMoving;\n        // DO NOT update lastMouse here; keep delta non-zero after delay\n        spawnTimer++; // advance cadence during delay so first spawn can happen right after\n        return;\n    } else {\n        resumeUntilMs = 0;\n    }\n    // Fallback frame-based guard\n    if (resumeDelay > 0) {\n        resumeDelay--;\n        wasMouseMoving = isMoving;\n        // DO NOT update lastMouse here; keep delta non-zero after delay\n        spawnTimer++; // advance cadence during frame-based delay\n        return;\n    }\n    // Advance cadence\n    spawnTimer++;\n    // Continuous spawning while moving\n    if (isMoving) {\n        if (spawnTimer >= config.spawnInterval) {\n            // Spawn away from the cursor to avoid covering it\n            const spawnDistance = 70 + Math.random() * 30; // 70-100px\n            const spawnAngle = Math.random() * Math.PI * 2;\n            const ringX = mouseX + Math.cos(spawnAngle) * spawnDistance;\n            const ringY = mouseY + Math.sin(spawnAngle) * spawnDistance;\n            // Spawn; replace oldest if at capacity\n            if (polaroids.length < config.maxPolaroids) {\n                polaroids.push(createPolaroidElement(ringX, ringY));\n            } else {\n                // Remove oldest polaroid and add new one for continuous flow\n                const oldest = polaroids.shift();\n                if (oldest && container && oldest.element.parentNode) {\n                    container.removeChild(oldest.element);\n                }\n                polaroids.push(createPolaroidElement(ringX, ringY));\n            }\n            spawnTimer = 0;\n        }\n    }\n    lastMouseX = mouseX;\n    lastMouseY = mouseY;\n    wasMouseMoving = isMoving;\n}\nfunction animate() {\n    updatePolaroids();\n    requestAnimationFrame(animate);\n}\n// Event handlers\nfunction attachEventListeners() {\n    if (true) return;\n    const mouseMoveHandler = (e)=>{\n        mouseX = e.clientX;\n        mouseY = e.clientY;\n    };\n    const mouseEnterHandler = (e)=>{\n        // Initialize mouse position when entering the page\n        mouseX = e.clientX;\n        mouseY = e.clientY;\n        lastMouseX = mouseX;\n        lastMouseY = mouseY;\n    };\n    const touchMoveHandler = (e)=>{\n        e.preventDefault();\n        if (e.touches.length > 0) {\n            const touch = e.touches[0];\n            mouseX = touch.clientX;\n            mouseY = touch.clientY;\n        }\n    };\n    const touchStartHandler = (e)=>{\n        if (e.touches.length > 0) {\n            const touch = e.touches[0];\n            mouseX = touch.clientX;\n            mouseY = touch.clientY;\n            lastMouseX = mouseX;\n            lastMouseY = mouseY;\n        }\n    };\n    document.addEventListener(\"mousemove\", mouseMoveHandler);\n    document.addEventListener(\"mouseenter\", mouseEnterHandler);\n    document.addEventListener(\"touchmove\", touchMoveHandler, {\n        passive: false\n    });\n    document.addEventListener(\"touchstart\", touchStartHandler, {\n        passive: true\n    });\n}\n// Main initialization function\nfunction initPolaroidCursor() {\n    if (true) return;\n    if (polaroidInitialized) {\n        console.log('Polaroid cursor already initialized');\n        return;\n    }\n    console.log('Initializing polaroid cursor effect...');\n    // Create container for polaroids\n    container = document.createElement('div');\n    container.id = 'polaroid-container';\n    container.style.cssText = `\n    position: fixed;\n    top: 0;\n    left: 0;\n    width: 100vw;\n    height: 100vh;\n    pointer-events: none;\n    z-index: 1000;\n  `;\n    document.body.appendChild(container);\n    // Initialize mouse position to center, but will be updated on first mouse move\n    mouseX = window.innerWidth / 2;\n    mouseY = window.innerHeight / 2;\n    lastMouseX = mouseX;\n    lastMouseY = mouseY;\n    // Get actual mouse position if available\n    document.addEventListener('mousemove', (e)=>{\n        if (mouseX === window.innerWidth / 2 && mouseY === window.innerHeight / 2) {\n            // First mouse move - initialize properly\n            mouseX = e.clientX;\n            mouseY = e.clientY;\n            lastMouseX = mouseX;\n            lastMouseY = mouseY;\n        }\n    }, {\n        once: true\n    });\n    // Attach event listeners\n    attachEventListeners();\n    // Start animation loop\n    animate();\n    polaroidInitialized = true;\n    console.log('Polaroid cursor effect initialized successfully!');\n}\n// Cleanup function\nfunction cleanupPolaroidCursor() {\n    if (container && container.parentNode) {\n        document.body.removeChild(container);\n    }\n    polaroids.forEach((polaroid)=>{\n        if (polaroid.element.parentNode) {\n            polaroid.element.parentNode.removeChild(polaroid.element);\n        }\n    });\n    polaroids = [];\n    container = null;\n    polaroidInitialized = false;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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L0MsQ0FBQUE7UUFDaEIsSUFBSUEsU0FBU3ZCLE9BQU8sQ0FBQ3lCLFVBQVUsRUFBRTtZQUMvQkYsU0FBU3ZCLE9BQU8sQ0FBQ3lCLFVBQVUsQ0FBQ0MsV0FBVyxDQUFDSCxTQUFTdkIsT0FBTztRQUMxRDtJQUNGO0lBRUEzQixZQUFZLEVBQUU7SUFDZEQsWUFBWTtJQUNaRCxzQkFBc0I7QUFDeEIiLCJzb3VyY2VzIjpbIi9Vc2Vycy95dmVzL1JlcG9zaXRvcmllcy95dmVzeWlsLnh5ei9hcHAvbGliL3BvbGFyb2lkLWN1cnNvci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBQb2xhcm9pZCBDdXJzb3IgRWZmZWN0XG4vLyBDcmVhdGVzIHBvbGFyb2lkIHBob3RvcyB0aGF0IGZvbGxvdyBtb3VzZSBtb3ZlbWVudFxuXG5sZXQgcG9sYXJvaWRJbml0aWFsaXplZCA9IGZhbHNlO1xubGV0IGNvbnRhaW5lcjogSFRNTERpdkVsZW1lbnQgfCBudWxsID0gbnVsbDtcbmxldCBwb2xhcm9pZHM6IFBvbGFyb2lkRWxlbWVudFtdID0gW107XG5sZXQgbW91c2VYID0gMDtcbmxldCBtb3VzZVkgPSAwO1xubGV0IGxhc3RNb3VzZVggPSAwO1xubGV0IGxhc3RNb3VzZVkgPSAwO1xubGV0IHNwYXduVGltZXIgPSAwOyAvLyBUaW1lciBmb3IgY29uc2lzdGVudCBzcGF3bmluZ1xubGV0IHdhc01vdXNlTW92aW5nID0gZmFsc2U7XG5sZXQgcmVzdW1lRGVsYXkgPSAwOyAvLyBmcmFtZXMgdG8gZGVsYXkgYWZ0ZXIgbW92ZW1lbnQgcmVzdW1lc1xuY29uc3QgUkVTVU1FX0RFTEFZX0ZSQU1FUyA9IDU7IC8vIH4wLjFzIGF0IDYwZnBzXG5sZXQgcmVzdW1lVW50aWxNcyA9IDA7IC8vIHRpbWVzdGFtcCB1bnRpbCB3aGljaCB3ZSBkZWxheSBzcGF3bmluZyBhZnRlciByZXN1bWVcbmxldCBpZGxlRnJhbWVzID0gMDsgLy8gZnJhbWVzIG5vdCBtb3ZpbmdcbmNvbnN0IElETEVfQVJNX0ZSQU1FUyA9IDIwOyAvLyByZXF1aXJlIH4wLjMzcyBpZGxlIGJlZm9yZSBhcm1pbmcgcmVzdW1lIGRlbGF5XG5cbmludGVyZmFjZSBQb2xhcm9pZEVsZW1lbnQge1xuICBlbGVtZW50OiBIVE1MRGl2RWxlbWVudDtcbiAgeDogbnVtYmVyO1xuICB5OiBudW1iZXI7XG4gIHJvdGF0aW9uOiBudW1iZXI7XG4gIHNjYWxlOiBudW1iZXI7XG4gIG9wYWNpdHk6IG51bWJlcjtcbiAgbGlmZTogbnVtYmVyO1xuICBtYXhMaWZlOiBudW1iZXI7XG4gIHZ4OiBudW1iZXI7XG4gIHZ5OiBudW1iZXI7XG4gIGltYWdlOiBzdHJpbmc7XG59XG5cbi8vIFRpbnkgaW1hZ2VzIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2VcbmNvbnN0IHBob3RvTGlzdCA9IFtcbiAgJy9waG90b3MvdGlueS9BbmdlbEhvbGRpbmdDaGFsaWNlLmpwZycsXG4gICcvcGhvdG9zL3RpbnkvQVN0cmVldEluSGFhcmxlbS5qcGcnLFxuICAnL3Bob3Rvcy90aW55L0F1dG9wYXJrLmpwZycsXG4gICcvcGhvdG9zL3RpbnkvQ2FmZUhldFdhcGVuVmFuQmxvLmpwZycsXG4gICcvcGhvdG9zL3RpbnkvQ2FyaXRhc2Jyb25kZW4uanBnJyxcbiAgJy9waG90b3MvdGlueS9DYXRMYXlpbmcuanBnJyxcbiAgJy9waG90b3MvdGlueS9DYXRXaXRoTGFyZ2VDb2xsYXIuanBnJyxcbiAgJy9waG90b3MvdGlueS9DaHVyY2hJblRoZURpc3RhbmNlLmpwZycsXG4gICcvcGhvdG9zL3RpbnkvQ293cy5qcGcnLFxuICAnL3Bob3Rvcy90aW55L0Nvd3NDdXJpb3VzLmpwZycsXG4gICcvcGhvdG9zL3RpbnkvRGVCdXJjaHQuanBnJyxcbiAgJy9waG90b3MvdGlueS9GcmVkZXJpa3NiZXJnU2xvdC5qcGcnLFxuICAnL3Bob3Rvcy90aW55L0dyYXNzUGxhbmUuanBnJyxcbiAgJy9waG90b3MvdGlueS9MYWtlLmpwZycsXG4gICcvcGhvdG9zL3RpbnkvTWFhbi5qcGcnLFxuICAnL3Bob3Rvcy90aW55L01lcm1haWQuanBnJyxcbiAgJy9waG90b3MvdGlueS9PZmZpY2UuanBnJyxcbiAgJy9waG90b3MvdGlueS9TQUlMLmpwZycsXG4gICcvcGhvdG9zL3RpbnkvU2ludEJvbmlmYXRpdXNrZXJrLmpwZycsXG4gICcvcGhvdG9zL3RpbnkvU3RhaXJzLmpwZycsXG4gICcvcGhvdG9zL3RpbnkvWmFhblJpdmVyLmpwZycsXG5dO1xuXG5jb25zdCBjb25maWcgPSB7XG4gIG1heFBvbGFyb2lkczogMjAsIC8vIEhpZ2hlciBsaW1pdCB0byBwcmV2ZW50IHBhdXNlc1xuICBwb2xhcm9pZExpZmU6IDYwLCAvLyBTaG9ydGVyIGxpZmUgc28gcGhvdG9zIGN5Y2xlIGZhc3RlclxuICBzcGF3bkludGVydmFsOiA4LCAvLyBTcGF3biBldmVyeSA0IGZyYW1lcyAoMTUgdGltZXMgcGVyIHNlY29uZClcbiAgZmFkZU91dER1cmF0aW9uOiAzMCwgLy8gRmFzdGVyIGZhZGUgZm9yIHF1aWNrZXIgdHVybm92ZXJcbiAgbWluTW92ZW1lbnRUaHJlc2hvbGQ6IDEsIC8vIExvd2VyIHRocmVzaG9sZFxuICBwb2xhcm9pZFNpemU6IDE0MCwgLy8gQmlnZ2VyIHBob3Rvc1xufTtcblxubGV0IHBob3RvSW5kZXggPSAwO1xuZnVuY3Rpb24gZ2V0TmV4dFBob3RvKCk6IHN0cmluZyB7XG4gIGNvbnN0IHNyYyA9IHBob3RvTGlzdFtwaG90b0luZGV4XTtcbiAgcGhvdG9JbmRleCA9IChwaG90b0luZGV4ICsgMSkgJSBwaG90b0xpc3QubGVuZ3RoO1xuICByZXR1cm4gc3JjO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVQb2xhcm9pZEVsZW1lbnQoeDogbnVtYmVyLCB5OiBudW1iZXIpOiBQb2xhcm9pZEVsZW1lbnQge1xuICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGNvbnN0IGltYWdlID0gZ2V0TmV4dFBob3RvKCk7XG4gIFxuICBlbGVtZW50LmNsYXNzTmFtZSA9ICdwb2xhcm9pZC1waG90byc7XG4gIGVsZW1lbnQuaW5uZXJIVE1MID0gYFxuICAgIDxkaXYgY2xhc3M9XCJwb2xhcm9pZC1pbm5lclwiPlxuICAgICAgPGltZyBzcmM9XCIke2ltYWdlfVwiIGFsdD1cIlJhbmRvbSBwaG90b1wiIC8+XG4gICAgICA8ZGl2IGNsYXNzPVwicG9sYXJvaWQtY2FwdGlvblwiPjwvZGl2PlxuICAgIDwvZGl2PlxuICBgO1xuICBcbiAgLy8gUmFuZG9tIHJvdGF0aW9uIGFuZCBzbGlnaHQgc2NhbGUgdmFyaWF0aW9uXG4gIGNvbnN0IHJvdGF0aW9uID0gKE1hdGgucmFuZG9tKCkgLSAwLjUpICogMzA7IC8vIC0xNSB0byAxNSBkZWdyZWVzXG4gIGNvbnN0IHNjYWxlID0gMC44ICsgTWF0aC5yYW5kb20oKSAqIDAuNDsgLy8gMC44IHRvIDEuMlxuICBcbiAgZWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gYFxuICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgICB6LWluZGV4OiAxMDAwO1xuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKC01MCUsIC01MCUpIHJvdGF0ZSgke3JvdGF0aW9ufWRlZykgc2NhbGUoJHtzY2FsZX0pO1xuICAgIHRyYW5zaXRpb246IG5vbmU7XG4gIGA7XG4gIC8vIFNldCBpbml0aWFsIHBvc2l0aW9uIGltbWVkaWF0ZWx5IHNvIGl0IGRvZXNuJ3QgZmxhc2ggYXQgKDAsMClcbiAgZWxlbWVudC5zdHlsZS5sZWZ0ID0gYCR7eH1weGA7XG4gIGVsZW1lbnQuc3R5bGUudG9wID0gYCR7eX1weGA7XG4gIFxuICBjb25zdCBwb2xhcm9pZEVsZW1lbnQ6IFBvbGFyb2lkRWxlbWVudCA9IHtcbiAgICBlbGVtZW50LFxuICAgIHgsXG4gICAgeSxcbiAgICByb3RhdGlvbixcbiAgICBzY2FsZSxcbiAgICBvcGFjaXR5OiAxLFxuICAgIGxpZmU6IGNvbmZpZy5wb2xhcm9pZExpZmUsXG4gICAgbWF4TGlmZTogY29uZmlnLnBvbGFyb2lkTGlmZSxcbiAgICB2eDogKE1hdGgucmFuZG9tKCkgLSAwLjUpICogMixcbiAgICB2eTogKE1hdGgucmFuZG9tKCkgLSAwLjUpICogMixcbiAgICBpbWFnZVxuICB9O1xuICBcbiAgaWYgKGNvbnRhaW5lcikge1xuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChlbGVtZW50KTtcbiAgfVxuICBcbiAgcmV0dXJuIHBvbGFyb2lkRWxlbWVudDtcbn1cblxuZnVuY3Rpb24gdXBkYXRlUG9sYXJvaWRzKCkge1xuICAvLyBVcGRhdGUgZXhpc3RpbmcgcG9sYXJvaWRzXG4gIGZvciAobGV0IGkgPSBwb2xhcm9pZHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBjb25zdCBwb2xhcm9pZCA9IHBvbGFyb2lkc1tpXTtcbiAgICBcbiAgICAvLyBVcGRhdGUgcG9zaXRpb24gd2l0aCBzbGlnaHQgZHJpZnRcbiAgICBwb2xhcm9pZC54ICs9IHBvbGFyb2lkLnZ4O1xuICAgIHBvbGFyb2lkLnkgKz0gcG9sYXJvaWQudnk7XG4gICAgXG4gICAgLy8gQXBwbHkgc2xpZ2h0IGRyYWdcbiAgICBwb2xhcm9pZC52eCAqPSAwLjk4O1xuICAgIHBvbGFyb2lkLnZ5ICo9IDAuOTg7XG4gICAgXG4gICAgLy8gVXBkYXRlIGxpZmVcbiAgICBwb2xhcm9pZC5saWZlLS07XG4gICAgXG4gICAgLy8gQ2FsY3VsYXRlIG9wYWNpdHkgYmFzZWQgb24gcmVtYWluaW5nIGxpZmVcbiAgICBpZiAocG9sYXJvaWQubGlmZSA8IGNvbmZpZy5mYWRlT3V0RHVyYXRpb24pIHtcbiAgICAgIHBvbGFyb2lkLm9wYWNpdHkgPSBwb2xhcm9pZC5saWZlIC8gY29uZmlnLmZhZGVPdXREdXJhdGlvbjtcbiAgICB9XG4gICAgXG4gICAgLy8gVXBkYXRlIGVsZW1lbnQgcG9zaXRpb24gYW5kIG9wYWNpdHlcbiAgICBwb2xhcm9pZC5lbGVtZW50LnN0eWxlLmxlZnQgPSBgJHtwb2xhcm9pZC54fXB4YDtcbiAgICBwb2xhcm9pZC5lbGVtZW50LnN0eWxlLnRvcCA9IGAke3BvbGFyb2lkLnl9cHhgO1xuICAgIHBvbGFyb2lkLmVsZW1lbnQuc3R5bGUub3BhY2l0eSA9IHBvbGFyb2lkLm9wYWNpdHkudG9TdHJpbmcoKTtcbiAgICBcbiAgICAvLyBSZW1vdmUgZGVhZCBwb2xhcm9pZHNcbiAgICBpZiAocG9sYXJvaWQubGlmZSA8PSAwKSB7XG4gICAgICBpZiAoY29udGFpbmVyICYmIHBvbGFyb2lkLmVsZW1lbnQucGFyZW50Tm9kZSkge1xuICAgICAgICBjb250YWluZXIucmVtb3ZlQ2hpbGQocG9sYXJvaWQuZWxlbWVudCk7XG4gICAgICB9XG4gICAgICBwb2xhcm9pZHMuc3BsaWNlKGksIDEpO1xuICAgIH1cbiAgfVxuICBcbiAgLy8gTW92ZW1lbnQgbWV0cmljcyBhbmQgZ2F0aW5nXG4gIGNvbnN0IGR4ID0gbW91c2VYIC0gbGFzdE1vdXNlWDtcbiAgY29uc3QgZHkgPSBtb3VzZVkgLSBsYXN0TW91c2VZO1xuICBjb25zdCBtb3ZlbWVudCA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gIGNvbnN0IGlzTW92aW5nID0gbW92ZW1lbnQgPiBjb25maWcubWluTW92ZW1lbnRUaHJlc2hvbGQ7XG5cbiAgLy8gVHJhY2sgaWRsZSB2cyBtb3ZpbmcgZnJhbWVzIHRvIGF2b2lkIHJlLWFybWluZyBkZWxheSBvbiBtaWNybyBwYXVzZXNcbiAgaWYgKGlzTW92aW5nKSB7XG4gICAgLy8gT25seSBhcm0gYSBkZWxheSBpZiB3ZSB3ZXJlIHRydWx5IGlkbGUgZm9yIGEgYml0XG4gICAgaWYgKCF3YXNNb3VzZU1vdmluZyAmJiBpZGxlRnJhbWVzID49IElETEVfQVJNX0ZSQU1FUykge1xuICAgICAgcmVzdW1lRGVsYXkgPSBSRVNVTUVfREVMQVlfRlJBTUVTO1xuICAgICAgc3Bhd25UaW1lciA9IDA7IC8vIHJlc2V0IGNhZGVuY2VcbiAgICAgIHJlc3VtZVVudGlsTXMgPSB0eXBlb2YgcGVyZm9ybWFuY2UgIT09ICd1bmRlZmluZWQnID8gcGVyZm9ybWFuY2Uubm93KCkgKyAxMjAgOiAwOyAvLyB+MTIwbXNcbiAgICB9XG4gICAgaWRsZUZyYW1lcyA9IDA7XG4gIH0gZWxzZSB7XG4gICAgaWRsZUZyYW1lcysrO1xuICB9XG5cbiAgLy8gVGltZS1iYXNlZCBndWFyZCAobW9yZSByb2J1c3QgYWNyb3NzIGZyYW1lIHJhdGVzKVxuICBpZiAocmVzdW1lVW50aWxNcyAmJiB0eXBlb2YgcGVyZm9ybWFuY2UgIT09ICd1bmRlZmluZWQnICYmIHBlcmZvcm1hbmNlLm5vdygpIDwgcmVzdW1lVW50aWxNcykge1xuICAgIHdhc01vdXNlTW92aW5nID0gaXNNb3Zpbmc7XG4gICAgLy8gRE8gTk9UIHVwZGF0ZSBsYXN0TW91c2UgaGVyZTsga2VlcCBkZWx0YSBub24temVybyBhZnRlciBkZWxheVxuICAgIHNwYXduVGltZXIrKzsgLy8gYWR2YW5jZSBjYWRlbmNlIGR1cmluZyBkZWxheSBzbyBmaXJzdCBzcGF3biBjYW4gaGFwcGVuIHJpZ2h0IGFmdGVyXG4gICAgcmV0dXJuO1xuICB9IGVsc2Uge1xuICAgIHJlc3VtZVVudGlsTXMgPSAwO1xuICB9XG5cbiAgLy8gRmFsbGJhY2sgZnJhbWUtYmFzZWQgZ3VhcmRcbiAgaWYgKHJlc3VtZURlbGF5ID4gMCkge1xuICAgIHJlc3VtZURlbGF5LS07XG4gICAgd2FzTW91c2VNb3ZpbmcgPSBpc01vdmluZztcbiAgICAvLyBETyBOT1QgdXBkYXRlIGxhc3RNb3VzZSBoZXJlOyBrZWVwIGRlbHRhIG5vbi16ZXJvIGFmdGVyIGRlbGF5XG4gICAgc3Bhd25UaW1lcisrOyAvLyBhZHZhbmNlIGNhZGVuY2UgZHVyaW5nIGZyYW1lLWJhc2VkIGRlbGF5XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gQWR2YW5jZSBjYWRlbmNlXG4gIHNwYXduVGltZXIrKztcbiAgXG4gIC8vIENvbnRpbnVvdXMgc3Bhd25pbmcgd2hpbGUgbW92aW5nXG4gIGlmIChpc01vdmluZykge1xuICAgIGlmIChzcGF3blRpbWVyID49IGNvbmZpZy5zcGF3bkludGVydmFsKSB7XG4gICAgICAvLyBTcGF3biBhd2F5IGZyb20gdGhlIGN1cnNvciB0byBhdm9pZCBjb3ZlcmluZyBpdFxuICAgICAgY29uc3Qgc3Bhd25EaXN0YW5jZSA9IDcwICsgTWF0aC5yYW5kb20oKSAqIDMwOyAvLyA3MC0xMDBweFxuICAgICAgY29uc3Qgc3Bhd25BbmdsZSA9IE1hdGgucmFuZG9tKCkgKiBNYXRoLlBJICogMjtcbiAgICAgIGNvbnN0IHJpbmdYID0gbW91c2VYICsgTWF0aC5jb3Moc3Bhd25BbmdsZSkgKiBzcGF3bkRpc3RhbmNlO1xuICAgICAgY29uc3QgcmluZ1kgPSBtb3VzZVkgKyBNYXRoLnNpbihzcGF3bkFuZ2xlKSAqIHNwYXduRGlzdGFuY2U7XG5cbiAgICAgIC8vIFNwYXduOyByZXBsYWNlIG9sZGVzdCBpZiBhdCBjYXBhY2l0eVxuICAgICAgaWYgKHBvbGFyb2lkcy5sZW5ndGggPCBjb25maWcubWF4UG9sYXJvaWRzKSB7XG4gICAgICAgIHBvbGFyb2lkcy5wdXNoKGNyZWF0ZVBvbGFyb2lkRWxlbWVudChyaW5nWCwgcmluZ1kpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFJlbW92ZSBvbGRlc3QgcG9sYXJvaWQgYW5kIGFkZCBuZXcgb25lIGZvciBjb250aW51b3VzIGZsb3dcbiAgICAgICAgY29uc3Qgb2xkZXN0ID0gcG9sYXJvaWRzLnNoaWZ0KCk7XG4gICAgICAgIGlmIChvbGRlc3QgJiYgY29udGFpbmVyICYmIG9sZGVzdC5lbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICBjb250YWluZXIucmVtb3ZlQ2hpbGQob2xkZXN0LmVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHBvbGFyb2lkcy5wdXNoKGNyZWF0ZVBvbGFyb2lkRWxlbWVudChyaW5nWCwgcmluZ1kpKTtcbiAgICAgIH1cbiAgICAgIHNwYXduVGltZXIgPSAwO1xuICAgIH1cbiAgfVxuICBcbiAgbGFzdE1vdXNlWCA9IG1vdXNlWDtcbiAgbGFzdE1vdXNlWSA9IG1vdXNlWTtcbiAgd2FzTW91c2VNb3ZpbmcgPSBpc01vdmluZztcbn1cblxuZnVuY3Rpb24gYW5pbWF0ZSgpIHtcbiAgdXBkYXRlUG9sYXJvaWRzKCk7XG4gIHJlcXVlc3RBbmltYXRpb25GcmFtZShhbmltYXRlKTtcbn1cblxuLy8gRXZlbnQgaGFuZGxlcnNcbmZ1bmN0aW9uIGF0dGFjaEV2ZW50TGlzdGVuZXJzKCkge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybjtcblxuICBjb25zdCBtb3VzZU1vdmVIYW5kbGVyID0gKGU6IE1vdXNlRXZlbnQpID0+IHtcbiAgICBtb3VzZVggPSBlLmNsaWVudFg7XG4gICAgbW91c2VZID0gZS5jbGllbnRZO1xuICB9O1xuXG4gIGNvbnN0IG1vdXNlRW50ZXJIYW5kbGVyID0gKGU6IE1vdXNlRXZlbnQpID0+IHtcbiAgICAvLyBJbml0aWFsaXplIG1vdXNlIHBvc2l0aW9uIHdoZW4gZW50ZXJpbmcgdGhlIHBhZ2VcbiAgICBtb3VzZVggPSBlLmNsaWVudFg7XG4gICAgbW91c2VZID0gZS5jbGllbnRZO1xuICAgIGxhc3RNb3VzZVggPSBtb3VzZVg7XG4gICAgbGFzdE1vdXNlWSA9IG1vdXNlWTtcbiAgfTtcblxuICBjb25zdCB0b3VjaE1vdmVIYW5kbGVyID0gKGU6IFRvdWNoRXZlbnQpID0+IHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgaWYgKGUudG91Y2hlcy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCB0b3VjaCA9IGUudG91Y2hlc1swXTtcbiAgICAgIG1vdXNlWCA9IHRvdWNoLmNsaWVudFg7XG4gICAgICBtb3VzZVkgPSB0b3VjaC5jbGllbnRZO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCB0b3VjaFN0YXJ0SGFuZGxlciA9IChlOiBUb3VjaEV2ZW50KSA9PiB7XG4gICAgaWYgKGUudG91Y2hlcy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCB0b3VjaCA9IGUudG91Y2hlc1swXTtcbiAgICAgIG1vdXNlWCA9IHRvdWNoLmNsaWVudFg7XG4gICAgICBtb3VzZVkgPSB0b3VjaC5jbGllbnRZO1xuICAgICAgbGFzdE1vdXNlWCA9IG1vdXNlWDtcbiAgICAgIGxhc3RNb3VzZVkgPSBtb3VzZVk7XG4gICAgfVxuICB9O1xuXG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgbW91c2VNb3ZlSGFuZGxlcik7XG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWVudGVyXCIsIG1vdXNlRW50ZXJIYW5kbGVyKTtcbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCB0b3VjaE1vdmVIYW5kbGVyLCB7IHBhc3NpdmU6IGZhbHNlIH0pO1xuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCB0b3VjaFN0YXJ0SGFuZGxlciwgeyBwYXNzaXZlOiB0cnVlIH0pO1xufVxuXG4vLyBNYWluIGluaXRpYWxpemF0aW9uIGZ1bmN0aW9uXG5leHBvcnQgZnVuY3Rpb24gaW5pdFBvbGFyb2lkQ3Vyc29yKCkge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybjtcbiAgXG4gIGlmIChwb2xhcm9pZEluaXRpYWxpemVkKSB7XG4gICAgY29uc29sZS5sb2coJ1BvbGFyb2lkIGN1cnNvciBhbHJlYWR5IGluaXRpYWxpemVkJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc29sZS5sb2coJ0luaXRpYWxpemluZyBwb2xhcm9pZCBjdXJzb3IgZWZmZWN0Li4uJyk7XG5cbiAgLy8gQ3JlYXRlIGNvbnRhaW5lciBmb3IgcG9sYXJvaWRzXG4gIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBjb250YWluZXIuaWQgPSAncG9sYXJvaWQtY29udGFpbmVyJztcbiAgY29udGFpbmVyLnN0eWxlLmNzc1RleHQgPSBgXG4gICAgcG9zaXRpb246IGZpeGVkO1xuICAgIHRvcDogMDtcbiAgICBsZWZ0OiAwO1xuICAgIHdpZHRoOiAxMDB2dztcbiAgICBoZWlnaHQ6IDEwMHZoO1xuICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICAgIHotaW5kZXg6IDEwMDA7XG4gIGA7XG4gIFxuICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XG5cbiAgLy8gSW5pdGlhbGl6ZSBtb3VzZSBwb3NpdGlvbiB0byBjZW50ZXIsIGJ1dCB3aWxsIGJlIHVwZGF0ZWQgb24gZmlyc3QgbW91c2UgbW92ZVxuICBtb3VzZVggPSB3aW5kb3cuaW5uZXJXaWR0aCAvIDI7XG4gIG1vdXNlWSA9IHdpbmRvdy5pbm5lckhlaWdodCAvIDI7XG4gIGxhc3RNb3VzZVggPSBtb3VzZVg7XG4gIGxhc3RNb3VzZVkgPSBtb3VzZVk7XG5cbiAgLy8gR2V0IGFjdHVhbCBtb3VzZSBwb3NpdGlvbiBpZiBhdmFpbGFibGVcbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgKGUpID0+IHtcbiAgICBpZiAobW91c2VYID09PSB3aW5kb3cuaW5uZXJXaWR0aCAvIDIgJiYgbW91c2VZID09PSB3aW5kb3cuaW5uZXJIZWlnaHQgLyAyKSB7XG4gICAgICAvLyBGaXJzdCBtb3VzZSBtb3ZlIC0gaW5pdGlhbGl6ZSBwcm9wZXJseVxuICAgICAgbW91c2VYID0gZS5jbGllbnRYO1xuICAgICAgbW91c2VZID0gZS5jbGllbnRZO1xuICAgICAgbGFzdE1vdXNlWCA9IG1vdXNlWDtcbiAgICAgIGxhc3RNb3VzZVkgPSBtb3VzZVk7XG4gICAgfVxuICB9LCB7IG9uY2U6IHRydWUgfSk7XG5cbiAgLy8gQXR0YWNoIGV2ZW50IGxpc3RlbmVyc1xuICBhdHRhY2hFdmVudExpc3RlbmVycygpO1xuICBcbiAgLy8gU3RhcnQgYW5pbWF0aW9uIGxvb3BcbiAgYW5pbWF0ZSgpO1xuXG4gIHBvbGFyb2lkSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICBjb25zb2xlLmxvZygnUG9sYXJvaWQgY3Vyc29yIGVmZmVjdCBpbml0aWFsaXplZCBzdWNjZXNzZnVsbHkhJyk7XG59XG5cbi8vIENsZWFudXAgZnVuY3Rpb25cbmV4cG9ydCBmdW5jdGlvbiBjbGVhbnVwUG9sYXJvaWRDdXJzb3IoKSB7XG4gIGlmIChjb250YWluZXIgJiYgY29udGFpbmVyLnBhcmVudE5vZGUpIHtcbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGNvbnRhaW5lcik7XG4gIH1cbiAgXG4gIHBvbGFyb2lkcy5mb3JFYWNoKHBvbGFyb2lkID0+IHtcbiAgICBpZiAocG9sYXJvaWQuZWxlbWVudC5wYXJlbnROb2RlKSB7XG4gICAgICBwb2xhcm9pZC5lbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQocG9sYXJvaWQuZWxlbWVudCk7XG4gICAgfVxuICB9KTtcbiAgXG4gIHBvbGFyb2lkcyA9IFtdO1xuICBjb250YWluZXIgPSBudWxsO1xuICBwb2xhcm9pZEluaXRpYWxpemVkID0gZmFsc2U7XG59XG4iXSwibmFtZXMiOlsicG9sYXJvaWRJbml0aWFsaXplZCIsImNvbnRhaW5lciIsInBvbGFyb2lkcyIsIm1vdXNlWCIsIm1vdXNlWSIsImxhc3RNb3VzZVgiLCJsYXN0TW91c2VZIiwic3Bhd25UaW1lciIsIndhc01vdXNlTW92aW5nIiwicmVzdW1lRGVsYXkiLCJSRVNVTUVfREVMQVlfRlJBTUVTIiwicmVzdW1lVW50aWxNcyIsImlkbGVGcmFtZXMiLCJJRExFX0FSTV9GUkFNRVMiLCJwaG90b0xpc3QiLCJjb25maWciLCJtYXhQb2xhcm9pZHMiLCJwb2xhcm9pZExpZmUiLCJzcGF3bkludGVydmFsIiwiZmFkZU91dER1cmF0aW9uIiwibWluTW92ZW1lbnRUaHJlc2hvbGQiLCJwb2xhcm9pZFNpemUiLCJwaG90b0luZGV4IiwiZ2V0TmV4dFBob3RvIiwic3JjIiwibGVuZ3RoIiwiY3JlYXRlUG9sYXJvaWRFbGVtZW50IiwieCIsInkiLCJlbGVtZW50IiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiaW1hZ2UiLCJjbGFzc05hbWUiLCJpbm5lckhUTUwiLCJyb3RhdGlvbiIsIk1hdGgiLCJyYW5kb20iLCJzY2FsZSIsInN0eWxlIiwiY3NzVGV4dCIsImxlZnQiLCJ0b3AiLCJwb2xhcm9pZEVsZW1lbnQiLCJvcGFjaXR5IiwibGlmZSIsIm1heExpZmUiLCJ2eCIsInZ5IiwiYXBwZW5kQ2hpbGQiLCJ1cGRhdGVQb2xhcm9pZHMiLCJpIiwicG9sYXJvaWQiLCJ0b1N0cmluZyIsInBhcmVudE5vZGUiLCJyZW1vdmVDaGlsZCIsInNwbGljZSIsImR4IiwiZHkiLCJtb3ZlbWVudCIsInNxcnQiLCJpc01vdmluZyIsInBlcmZvcm1hbmNlIiwibm93Iiwic3Bhd25EaXN0YW5jZSIsInNwYXduQW5nbGUiLCJQSSIsInJpbmdYIiwiY29zIiwicmluZ1kiLCJzaW4iLCJwdXNoIiwib2xkZXN0Iiwic2hpZnQiLCJhbmltYXRlIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiYXR0YWNoRXZlbnRMaXN0ZW5lcnMiLCJtb3VzZU1vdmVIYW5kbGVyIiwiZSIsImNsaWVudFgiLCJjbGllbnRZIiwibW91c2VFbnRlckhhbmRsZXIiLCJ0b3VjaE1vdmVIYW5kbGVyIiwicHJldmVudERlZmF1bHQiLCJ0b3VjaGVzIiwidG91Y2giLCJ0b3VjaFN0YXJ0SGFuZGxlciIsImFkZEV2ZW50TGlzdGVuZXIiLCJwYXNzaXZlIiwiaW5pdFBvbGFyb2lkQ3Vyc29yIiwiY29uc29sZSIsImxvZyIsImlkIiwiYm9keSIsIndpbmRvdyIsImlubmVyV2lkdGgiLCJpbm5lckhlaWdodCIsIm9uY2UiLCJjbGVhbnVwUG9sYXJvaWRDdXJzb3IiLCJmb3JFYWNoIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./app/lib/polaroid-cursor.ts\n");

/***/ })

};
;