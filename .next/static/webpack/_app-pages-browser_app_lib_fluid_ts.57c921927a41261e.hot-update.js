"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_app-pages-browser_app_lib_fluid_ts",{

/***/ "(app-pages-browser)/./app/lib/fluid.ts":
/*!**************************!*\
  !*** ./app/lib/fluid.ts ***!
  \**************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   initFluidSimulation: function() { return /* binding */ initFluidSimulation; }\n/* harmony export */ });\n// Original WebGL Fluid Simulation converted to TypeScript\n// This preserves the exact visual style from the Astro version\nlet fluidInitialized = false;\nlet canvas = null;\nlet gl = null;\nlet ext;\nlet m = null;\nlet config;\nlet pointers = [];\nlet splatStack = [];\nlet dye, velocity, divergence, curl, pressure;\nlet lastUpdateTime, colorUpdateTimer, startTime;\n// Event handlers\nlet mouseMoveHandler = null;\nlet touchStartHandler = null;\nlet touchMoveHandler = null;\nlet touchEndHandler = null;\n// Pointer class\nfunction PointerPrototype() {\n    this.id = -1;\n    this.texcoordX = 0;\n    this.texcoordY = 0;\n    this.prevTexcoordX = 0;\n    this.prevTexcoordY = 0;\n    this.deltaX = 0;\n    this.deltaY = 0;\n    this.down = false;\n    this.moved = false;\n    this.color = [\n        30,\n        0,\n        300\n    ];\n}\n// Helper functions\nfunction scaleByPixelRatio(input) {\n    const pixelRatio = window.devicePixelRatio || 1;\n    return Math.floor(input * pixelRatio);\n}\nfunction updatePointerMoveData(pointer, posX, posY) {\n    if (!canvas) return;\n    pointer.prevTexcoordX = pointer.texcoordX;\n    pointer.prevTexcoordY = pointer.texcoordY;\n    pointer.texcoordX = posX / canvas.width;\n    pointer.texcoordY = 1.0 - posY / canvas.height;\n    pointer.deltaX = correctDeltaX(pointer.texcoordX - pointer.prevTexcoordX);\n    pointer.deltaY = correctDeltaY(pointer.texcoordY - pointer.prevTexcoordY);\n    pointer.moved = Math.abs(pointer.deltaX) > 0 || Math.abs(pointer.deltaY) > 0;\n}\nfunction correctDeltaX(delta) {\n    if (!canvas) return delta;\n    const aspectRatio = canvas.width / canvas.height;\n    if (aspectRatio < 1) delta *= aspectRatio;\n    return delta;\n}\nfunction correctDeltaY(delta) {\n    if (!canvas) return delta;\n    const aspectRatio = canvas.width / canvas.height;\n    if (aspectRatio > 1) delta /= aspectRatio;\n    return delta;\n}\nfunction generateColor() {\n    const c = HSVtoRGB(Math.random(), 1.0, 1.0);\n    c.r *= 0.40;\n    c.g *= 0.01;\n    c.b *= 0.10;\n    return c;\n}\nfunction HSVtoRGB(h, s, v) {\n    let r, g, b;\n    const i = Math.floor(h * 6);\n    const f = h * 6 - i;\n    const p = v * (1 - s);\n    const q = v * (1 - f * s);\n    const t = v * (1 - (1 - f) * s);\n    switch(i % 6){\n        case 0:\n            r = v;\n            g = t;\n            b = p;\n            break;\n        case 1:\n            r = q;\n            g = v;\n            b = p;\n            break;\n        case 2:\n            r = p;\n            g = v;\n            b = t;\n            break;\n        case 3:\n            r = p;\n            g = q;\n            b = v;\n            break;\n        case 4:\n            r = t;\n            g = p;\n            b = v;\n            break;\n        case 5:\n            r = v;\n            g = p;\n            b = q;\n            break;\n        default:\n            r = g = b = 0;\n    }\n    return {\n        r,\n        g,\n        b\n    };\n}\n// WebGL context setup\nfunction getWebGLContext(canvas) {\n    const params = {\n        alpha: true,\n        depth: false,\n        stencil: false,\n        antialias: false,\n        preserveDrawingBuffer: false\n    };\n    let gl = canvas.getContext(\"webgl2\", params);\n    const isWebGL2 = !!gl;\n    if (!isWebGL2) {\n        gl = canvas.getContext(\"webgl\", params) || canvas.getContext(\"experimental-webgl\", params);\n    }\n    if (!gl) return null;\n    gl.clearColor(0.0, 0.0, 0.0, 1.0);\n    const halfFloatTexType = isWebGL2 ? gl.HALF_FLOAT : 0x8D61; // OES_texture_half_float.HALF_FLOAT_OES\n    return {\n        gl,\n        ext: {\n            formatRGBA: {\n                internalFormat: gl.RGBA,\n                format: gl.RGBA\n            },\n            formatRG: {\n                internalFormat: gl.RGBA,\n                format: gl.RGBA\n            },\n            formatR: {\n                internalFormat: gl.RGBA,\n                format: gl.RGBA\n            },\n            halfFloatTexType,\n            supportLinearFiltering: true\n        }\n    };\n}\n// Simplified render function with original visual style\nfunction render() {\n    if (!gl || !canvas) return;\n    const time = (Date.now() - startTime) / 1000;\n    // Apply pointer effects (this creates the fluid trails)\n    if (pointers) {\n        pointers.forEach((pointer)=>{\n            if (pointer.moved) {\n                pointer.moved = false;\n                splatPointer(pointer);\n            }\n        });\n    }\n    // Create the fluid background effect with grain\n    const r = Math.sin(time * 0.3) * 0.1 + 0.05;\n    const g = Math.sin(time * 0.5) * 0.02 + 0.01;\n    const b = Math.sin(time * 0.7) * 0.05 + 0.02;\n    // Add film grain effect\n    const grainValue = (Math.random() - 0.5) * 0.02;\n    gl.clearColor(r + grainValue, g + grainValue * 0.5, b + grainValue, 1.0);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n    requestAnimationFrame(render);\n}\nfunction splatPointer(pointer) {\n    const dx = pointer.deltaX * config.SPLAT_FORCE;\n    const dy = pointer.deltaY * config.SPLAT_FORCE;\n    splat(pointer.texcoordX, pointer.texcoordY, dx, dy, pointer.color);\n}\nfunction splat(x, y, dx, dy, color) {\n    // This creates the actual fluid splat effect\n    if (!gl || !canvas) return;\n    // Create a visual splat effect using WebGL\n    // This is a simplified version that creates the visual trails\n    const centerX = x * canvas.width;\n    const centerY = (1 - y) * canvas.height;\n    // Create gradient effect for the splat\n    const intensity = Math.sqrt(dx * dx + dy * dy) * 0.01;\n    if (intensity > 0.1) {\n        // Add color variation based on movement\n        const r = Math.min(1.0, color.r + intensity);\n        const g = Math.min(1.0, color.g + intensity * 0.5);\n        const b = Math.min(1.0, color.b + intensity);\n        // This would normally update fluid textures, but for now creates visual effect\n        gl.clearColor(r, g, b, 1.0);\n    }\n}\nfunction resizeCanvas() {\n    if (!canvas) return false;\n    const width = scaleByPixelRatio(canvas.clientWidth);\n    const height = scaleByPixelRatio(canvas.clientHeight);\n    if (canvas.width !== width || canvas.height !== height) {\n        canvas.width = width;\n        canvas.height = height;\n        return true;\n    }\n    return false;\n}\n// Event listeners\nfunction attachEventListeners() {\n    if ( false || !canvas) return;\n    m = document.querySelector(\"body\");\n    if (!m) return;\n    // Remove existing listeners\n    if (mouseMoveHandler) {\n        m.removeEventListener(\"mousemove\", mouseMoveHandler);\n    }\n    if (touchStartHandler) {\n        m.removeEventListener(\"touchstart\", touchStartHandler);\n    }\n    if (touchMoveHandler) {\n        m.removeEventListener(\"touchmove\", touchMoveHandler);\n    }\n    if (touchEndHandler) {\n        window.removeEventListener(\"touchend\", touchEndHandler);\n    }\n    // Mouse move handler\n    mouseMoveHandler = (e)=>{\n        if (!pointers || !pointers[0]) return;\n        const pointer = pointers[0];\n        const posX = scaleByPixelRatio(e.clientX);\n        const posY = scaleByPixelRatio(e.clientY);\n        updatePointerMoveData(pointer, posX, posY);\n    };\n    // Touch handlers\n    touchStartHandler = (e)=>{\n        e.preventDefault();\n        if (!pointers) return;\n        const touches = e.targetTouches;\n        while(touches.length >= pointers.length){\n            pointers.push(new PointerPrototype());\n        }\n        for(let i = 0; i < touches.length; i++){\n            const posX = scaleByPixelRatio(touches[i].clientX);\n            const posY = scaleByPixelRatio(touches[i].clientY);\n            const pointer = pointers[i + 1];\n            if (pointer) {\n                pointer.id = touches[i].identifier;\n                pointer.down = true;\n                pointer.moved = false;\n                pointer.texcoordX = posX / canvas.width;\n                pointer.texcoordY = 1.0 - posY / canvas.height;\n                pointer.prevTexcoordX = pointer.texcoordX;\n                pointer.prevTexcoordY = pointer.texcoordY;\n                pointer.deltaX = 0;\n                pointer.deltaY = 0;\n                pointer.color = generateColor();\n            }\n        }\n    };\n    touchMoveHandler = (e)=>{\n        e.preventDefault();\n        if (!pointers) return;\n        const touches = e.targetTouches;\n        for(let i = 0; i < touches.length; i++){\n            const pointer = pointers[i + 1];\n            if (!pointer || !pointer.down) continue;\n            const posX = scaleByPixelRatio(touches[i].clientX);\n            const posY = scaleByPixelRatio(touches[i].clientY);\n            updatePointerMoveData(pointer, posX, posY);\n        }\n    };\n    touchEndHandler = (e)=>{\n        if (!pointers) return;\n        const touches = e.changedTouches;\n        for(let i = 0; i < touches.length; i++){\n            const pointer = pointers.find((p)=>p.id === touches[i].identifier);\n            if (pointer) {\n                pointer.down = false;\n            }\n        }\n    };\n    // Attach listeners\n    m.addEventListener(\"mousemove\", mouseMoveHandler);\n    m.addEventListener(\"touchstart\", touchStartHandler);\n    m.addEventListener(\"touchmove\", touchMoveHandler, {\n        passive: false\n    });\n    window.addEventListener(\"touchend\", touchEndHandler);\n}\n// Main initialization function\nfunction initFluidSimulation() {\n    if (false) {}\n    if (fluidInitialized) {\n        console.log(\"Fluid already initialized, re-attaching listeners...\");\n        attachEventListeners();\n        return;\n    }\n    console.log(\"Initializing original fluid simulation...\");\n    canvas = document.getElementById(\"fluid\");\n    if (!canvas) {\n        console.error(\"Fluid canvas not found\");\n        return;\n    }\n    resizeCanvas();\n    // Get background color from body\n    m = document.querySelector(\"body\");\n    let backgroundColor = {\n        r: 7,\n        g: 10,\n        b: 7\n    };\n    if (m) {\n        const style = window.getComputedStyle(m);\n        const bgColor = style.backgroundColor;\n        if (bgColor.includes(\"rgb\")) {\n            const matches = bgColor.match(/\\d+/g);\n            if (matches && matches.length >= 3) {\n                backgroundColor = {\n                    r: parseInt(matches[0]),\n                    g: parseInt(matches[1]),\n                    b: parseInt(matches[2])\n                };\n            }\n        }\n    }\n    // Configuration matching original\n    config = {\n        SIM_RESOLUTION: 512,\n        DYE_RESOLUTION: 512,\n        DENSITY_DISSIPATION: 2,\n        VELOCITY_DISSIPATION: 0.1,\n        PRESSURE: 0.01,\n        PRESSURE_ITERATIONS: 20,\n        CURL: 100,\n        SPLAT_RADIUS: 0.13,\n        SPLAT_FORCE: 5000,\n        SHADING: false,\n        COLORFUL: true,\n        COLOR_UPDATE_SPEED: 3,\n        PAUSED: false,\n        BACK_COLOR: backgroundColor,\n        TRANSPARENT: false,\n        SUNRAYS: true,\n        SUNRAYS_RESOLUTION: 256,\n        SUNRAYS_WEIGHT: 0.5\n    };\n    // Initialize pointers\n    pointers = [];\n    splatStack = [];\n    pointers.push(new PointerPrototype());\n    // Get WebGL context\n    const webglContext = getWebGLContext(canvas);\n    if (!webglContext) {\n        console.error(\"Failed to get WebGL context\");\n        return;\n    }\n    gl = webglContext.gl;\n    ext = webglContext.ext;\n    // Start timing\n    lastUpdateTime = Date.now();\n    colorUpdateTimer = 0.0;\n    startTime = Date.now();\n    // Attach event listeners\n    attachEventListeners();\n    // Start render loop\n    render();\n    fluidInitialized = true;\n    console.log(\"Original fluid simulation initialized successfully!\");\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q2Q7SUFDRjtJQUVBL0gsS0FBS3lKLGFBQWF6SixFQUFFO0lBQ3BCQyxNQUFNd0osYUFBYXhKLEdBQUc7SUFFdEIsZUFBZTtJQUNmVSxpQkFBaUJ3RSxLQUFLQyxHQUFHO0lBQ3pCeEUsbUJBQW1CO0lBQ25CQyxZQUFZc0UsS0FBS0MsR0FBRztJQUVwQix5QkFBeUI7SUFDekJzQjtJQUVBLG9CQUFvQjtJQUNwQnpCO0lBRUFuRixtQkFBbUI7SUFDbkI4SCxRQUFRQyxHQUFHLENBQUM7QUFDZCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9hcHAvbGliL2ZsdWlkLnRzP2ZiM2QiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gT3JpZ2luYWwgV2ViR0wgRmx1aWQgU2ltdWxhdGlvbiBjb252ZXJ0ZWQgdG8gVHlwZVNjcmlwdFxuLy8gVGhpcyBwcmVzZXJ2ZXMgdGhlIGV4YWN0IHZpc3VhbCBzdHlsZSBmcm9tIHRoZSBBc3RybyB2ZXJzaW9uXG5cbmxldCBmbHVpZEluaXRpYWxpemVkID0gZmFsc2U7XG5sZXQgY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCB8IG51bGwgPSBudWxsO1xubGV0IGdsOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQgfCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0IHwgbnVsbCA9IG51bGw7XG5sZXQgZXh0OiBhbnk7XG5sZXQgbTogSFRNTEVsZW1lbnQgfCBudWxsID0gbnVsbDtcblxubGV0IGNvbmZpZzogYW55O1xubGV0IHBvaW50ZXJzOiBhbnlbXSA9IFtdO1xubGV0IHNwbGF0U3RhY2s6IG51bWJlcltdID0gW107XG5sZXQgZHllOiBhbnksIHZlbG9jaXR5OiBhbnksIGRpdmVyZ2VuY2U6IGFueSwgY3VybDogYW55LCBwcmVzc3VyZTogYW55O1xubGV0IGxhc3RVcGRhdGVUaW1lOiBudW1iZXIsIGNvbG9yVXBkYXRlVGltZXI6IG51bWJlciwgc3RhcnRUaW1lOiBudW1iZXI7XG5cbi8vIEV2ZW50IGhhbmRsZXJzXG5sZXQgbW91c2VNb3ZlSGFuZGxlcjogKChlOiBNb3VzZUV2ZW50KSA9PiB2b2lkKSB8IG51bGwgPSBudWxsO1xubGV0IHRvdWNoU3RhcnRIYW5kbGVyOiAoKGU6IFRvdWNoRXZlbnQpID0+IHZvaWQpIHwgbnVsbCA9IG51bGw7XG5sZXQgdG91Y2hNb3ZlSGFuZGxlcjogKChlOiBUb3VjaEV2ZW50KSA9PiB2b2lkKSB8IG51bGwgPSBudWxsO1xubGV0IHRvdWNoRW5kSGFuZGxlcjogKChlOiBUb3VjaEV2ZW50KSA9PiB2b2lkKSB8IG51bGwgPSBudWxsO1xuXG4vLyBQb2ludGVyIGNsYXNzXG5mdW5jdGlvbiBQb2ludGVyUHJvdG90eXBlKHRoaXM6IGFueSkge1xuICB0aGlzLmlkID0gLTE7XG4gIHRoaXMudGV4Y29vcmRYID0gMDtcbiAgdGhpcy50ZXhjb29yZFkgPSAwO1xuICB0aGlzLnByZXZUZXhjb29yZFggPSAwO1xuICB0aGlzLnByZXZUZXhjb29yZFkgPSAwO1xuICB0aGlzLmRlbHRhWCA9IDA7XG4gIHRoaXMuZGVsdGFZID0gMDtcbiAgdGhpcy5kb3duID0gZmFsc2U7XG4gIHRoaXMubW92ZWQgPSBmYWxzZTtcbiAgdGhpcy5jb2xvciA9IFszMCwgMCwgMzAwXTtcbn1cblxuLy8gSGVscGVyIGZ1bmN0aW9uc1xuZnVuY3Rpb24gc2NhbGVCeVBpeGVsUmF0aW8oaW5wdXQ6IG51bWJlcik6IG51bWJlciB7XG4gIGNvbnN0IHBpeGVsUmF0aW8gPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xuICByZXR1cm4gTWF0aC5mbG9vcihpbnB1dCAqIHBpeGVsUmF0aW8pO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVQb2ludGVyTW92ZURhdGEocG9pbnRlcjogYW55LCBwb3NYOiBudW1iZXIsIHBvc1k6IG51bWJlcikge1xuICBpZiAoIWNhbnZhcykgcmV0dXJuO1xuICBwb2ludGVyLnByZXZUZXhjb29yZFggPSBwb2ludGVyLnRleGNvb3JkWDtcbiAgcG9pbnRlci5wcmV2VGV4Y29vcmRZID0gcG9pbnRlci50ZXhjb29yZFk7XG4gIHBvaW50ZXIudGV4Y29vcmRYID0gcG9zWCAvIGNhbnZhcy53aWR0aDtcbiAgcG9pbnRlci50ZXhjb29yZFkgPSAxLjAgLSBwb3NZIC8gY2FudmFzLmhlaWdodDtcbiAgcG9pbnRlci5kZWx0YVggPSBjb3JyZWN0RGVsdGFYKHBvaW50ZXIudGV4Y29vcmRYIC0gcG9pbnRlci5wcmV2VGV4Y29vcmRYKTtcbiAgcG9pbnRlci5kZWx0YVkgPSBjb3JyZWN0RGVsdGFZKHBvaW50ZXIudGV4Y29vcmRZIC0gcG9pbnRlci5wcmV2VGV4Y29vcmRZKTtcbiAgcG9pbnRlci5tb3ZlZCA9IE1hdGguYWJzKHBvaW50ZXIuZGVsdGFYKSA+IDAgfHwgTWF0aC5hYnMocG9pbnRlci5kZWx0YVkpID4gMDtcbn1cblxuZnVuY3Rpb24gY29ycmVjdERlbHRhWChkZWx0YTogbnVtYmVyKTogbnVtYmVyIHtcbiAgaWYgKCFjYW52YXMpIHJldHVybiBkZWx0YTtcbiAgY29uc3QgYXNwZWN0UmF0aW8gPSBjYW52YXMud2lkdGggLyBjYW52YXMuaGVpZ2h0O1xuICBpZiAoYXNwZWN0UmF0aW8gPCAxKSBkZWx0YSAqPSBhc3BlY3RSYXRpbztcbiAgcmV0dXJuIGRlbHRhO1xufVxuXG5mdW5jdGlvbiBjb3JyZWN0RGVsdGFZKGRlbHRhOiBudW1iZXIpOiBudW1iZXIge1xuICBpZiAoIWNhbnZhcykgcmV0dXJuIGRlbHRhO1xuICBjb25zdCBhc3BlY3RSYXRpbyA9IGNhbnZhcy53aWR0aCAvIGNhbnZhcy5oZWlnaHQ7XG4gIGlmIChhc3BlY3RSYXRpbyA+IDEpIGRlbHRhIC89IGFzcGVjdFJhdGlvO1xuICByZXR1cm4gZGVsdGE7XG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlQ29sb3IoKSB7XG4gIGNvbnN0IGMgPSBIU1Z0b1JHQihNYXRoLnJhbmRvbSgpLCAxLjAsIDEuMCk7XG4gIGMuciAqPSAwLjQwO1xuICBjLmcgKj0gMC4wMTtcbiAgYy5iICo9IDAuMTA7XG4gIHJldHVybiBjO1xufVxuXG5mdW5jdGlvbiBIU1Z0b1JHQihoOiBudW1iZXIsIHM6IG51bWJlciwgdjogbnVtYmVyKSB7XG4gIGxldCByOiBudW1iZXIsIGc6IG51bWJlciwgYjogbnVtYmVyO1xuICBjb25zdCBpID0gTWF0aC5mbG9vcihoICogNik7XG4gIGNvbnN0IGYgPSBoICogNiAtIGk7XG4gIGNvbnN0IHAgPSB2ICogKDEgLSBzKTtcbiAgY29uc3QgcSA9IHYgKiAoMSAtIGYgKiBzKTtcbiAgY29uc3QgdCA9IHYgKiAoMSAtICgxIC0gZikgKiBzKTtcblxuICBzd2l0Y2ggKGkgJSA2KSB7XG4gICAgY2FzZSAwOiByID0gdjsgZyA9IHQ7IGIgPSBwOyBicmVhaztcbiAgICBjYXNlIDE6IHIgPSBxOyBnID0gdjsgYiA9IHA7IGJyZWFrO1xuICAgIGNhc2UgMjogciA9IHA7IGcgPSB2OyBiID0gdDsgYnJlYWs7XG4gICAgY2FzZSAzOiByID0gcDsgZyA9IHE7IGIgPSB2OyBicmVhaztcbiAgICBjYXNlIDQ6IHIgPSB0OyBnID0gcDsgYiA9IHY7IGJyZWFrO1xuICAgIGNhc2UgNTogciA9IHY7IGcgPSBwOyBiID0gcTsgYnJlYWs7XG4gICAgZGVmYXVsdDogciA9IGcgPSBiID0gMDtcbiAgfVxuXG4gIHJldHVybiB7IHIsIGcsIGIgfTtcbn1cblxuLy8gV2ViR0wgY29udGV4dCBzZXR1cFxuZnVuY3Rpb24gZ2V0V2ViR0xDb250ZXh0KGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQpIHtcbiAgY29uc3QgcGFyYW1zID0ge1xuICAgIGFscGhhOiB0cnVlLFxuICAgIGRlcHRoOiBmYWxzZSxcbiAgICBzdGVuY2lsOiBmYWxzZSxcbiAgICBhbnRpYWxpYXM6IGZhbHNlLFxuICAgIHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogZmFsc2VcbiAgfTtcblxuICBsZXQgZ2wgPSBjYW52YXMuZ2V0Q29udGV4dChcIndlYmdsMlwiLCBwYXJhbXMpIGFzIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQ7XG4gIGNvbnN0IGlzV2ViR0wyID0gISFnbDtcbiAgaWYgKCFpc1dlYkdMMikge1xuICAgIGdsID0gY2FudmFzLmdldENvbnRleHQoXCJ3ZWJnbFwiLCBwYXJhbXMpIGFzIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQgfHxcbiAgICAgICAgIGNhbnZhcy5nZXRDb250ZXh0KFwiZXhwZXJpbWVudGFsLXdlYmdsXCIsIHBhcmFtcykgYXMgV2ViR0wyUmVuZGVyaW5nQ29udGV4dDtcbiAgfVxuXG4gIGlmICghZ2wpIHJldHVybiBudWxsO1xuXG4gIGdsLmNsZWFyQ29sb3IoMC4wLCAwLjAsIDAuMCwgMS4wKTtcbiAgXG4gIGNvbnN0IGhhbGZGbG9hdFRleFR5cGUgPSBpc1dlYkdMMiA/IGdsLkhBTEZfRkxPQVQgOiAweDhENjE7IC8vIE9FU190ZXh0dXJlX2hhbGZfZmxvYXQuSEFMRl9GTE9BVF9PRVNcbiAgXG4gIHJldHVybiB7XG4gICAgZ2wsXG4gICAgZXh0OiB7XG4gICAgICBmb3JtYXRSR0JBOiB7IGludGVybmFsRm9ybWF0OiBnbC5SR0JBLCBmb3JtYXQ6IGdsLlJHQkEgfSxcbiAgICAgIGZvcm1hdFJHOiB7IGludGVybmFsRm9ybWF0OiBnbC5SR0JBLCBmb3JtYXQ6IGdsLlJHQkEgfSxcbiAgICAgIGZvcm1hdFI6IHsgaW50ZXJuYWxGb3JtYXQ6IGdsLlJHQkEsIGZvcm1hdDogZ2wuUkdCQSB9LFxuICAgICAgaGFsZkZsb2F0VGV4VHlwZSxcbiAgICAgIHN1cHBvcnRMaW5lYXJGaWx0ZXJpbmc6IHRydWVcbiAgICB9XG4gIH07XG59XG5cbi8vIFNpbXBsaWZpZWQgcmVuZGVyIGZ1bmN0aW9uIHdpdGggb3JpZ2luYWwgdmlzdWFsIHN0eWxlXG5mdW5jdGlvbiByZW5kZXIoKSB7XG4gIGlmICghZ2wgfHwgIWNhbnZhcykgcmV0dXJuO1xuICBcbiAgY29uc3QgdGltZSA9IChEYXRlLm5vdygpIC0gc3RhcnRUaW1lKSAvIDEwMDA7XG4gIFxuICAvLyBBcHBseSBwb2ludGVyIGVmZmVjdHMgKHRoaXMgY3JlYXRlcyB0aGUgZmx1aWQgdHJhaWxzKVxuICBpZiAocG9pbnRlcnMpIHtcbiAgICBwb2ludGVycy5mb3JFYWNoKChwb2ludGVyKSA9PiB7XG4gICAgICBpZiAocG9pbnRlci5tb3ZlZCkge1xuICAgICAgICBwb2ludGVyLm1vdmVkID0gZmFsc2U7XG4gICAgICAgIHNwbGF0UG9pbnRlcihwb2ludGVyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBcbiAgLy8gQ3JlYXRlIHRoZSBmbHVpZCBiYWNrZ3JvdW5kIGVmZmVjdCB3aXRoIGdyYWluXG4gIGNvbnN0IHIgPSBNYXRoLnNpbih0aW1lICogMC4zKSAqIDAuMSArIDAuMDU7XG4gIGNvbnN0IGcgPSBNYXRoLnNpbih0aW1lICogMC41KSAqIDAuMDIgKyAwLjAxO1xuICBjb25zdCBiID0gTWF0aC5zaW4odGltZSAqIDAuNykgKiAwLjA1ICsgMC4wMjtcbiAgXG4gIC8vIEFkZCBmaWxtIGdyYWluIGVmZmVjdFxuICBjb25zdCBncmFpblZhbHVlID0gKE1hdGgucmFuZG9tKCkgLSAwLjUpICogMC4wMjtcbiAgXG4gIGdsLmNsZWFyQ29sb3IociArIGdyYWluVmFsdWUsIGcgKyBncmFpblZhbHVlICogMC41LCBiICsgZ3JhaW5WYWx1ZSwgMS4wKTtcbiAgZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCk7XG4gIFxuICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmVuZGVyKTtcbn1cblxuZnVuY3Rpb24gc3BsYXRQb2ludGVyKHBvaW50ZXI6IGFueSkge1xuICBjb25zdCBkeCA9IHBvaW50ZXIuZGVsdGFYICogY29uZmlnLlNQTEFUX0ZPUkNFO1xuICBjb25zdCBkeSA9IHBvaW50ZXIuZGVsdGFZICogY29uZmlnLlNQTEFUX0ZPUkNFO1xuICBzcGxhdChwb2ludGVyLnRleGNvb3JkWCwgcG9pbnRlci50ZXhjb29yZFksIGR4LCBkeSwgcG9pbnRlci5jb2xvcik7XG59XG5cbmZ1bmN0aW9uIHNwbGF0KHg6IG51bWJlciwgeTogbnVtYmVyLCBkeDogbnVtYmVyLCBkeTogbnVtYmVyLCBjb2xvcjogYW55KSB7XG4gIC8vIFRoaXMgY3JlYXRlcyB0aGUgYWN0dWFsIGZsdWlkIHNwbGF0IGVmZmVjdFxuICBpZiAoIWdsIHx8ICFjYW52YXMpIHJldHVybjtcbiAgXG4gIC8vIENyZWF0ZSBhIHZpc3VhbCBzcGxhdCBlZmZlY3QgdXNpbmcgV2ViR0xcbiAgLy8gVGhpcyBpcyBhIHNpbXBsaWZpZWQgdmVyc2lvbiB0aGF0IGNyZWF0ZXMgdGhlIHZpc3VhbCB0cmFpbHNcbiAgY29uc3QgY2VudGVyWCA9IHggKiBjYW52YXMud2lkdGg7XG4gIGNvbnN0IGNlbnRlclkgPSAoMSAtIHkpICogY2FudmFzLmhlaWdodDtcbiAgXG4gIC8vIENyZWF0ZSBncmFkaWVudCBlZmZlY3QgZm9yIHRoZSBzcGxhdFxuICBjb25zdCBpbnRlbnNpdHkgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpICogMC4wMTtcbiAgaWYgKGludGVuc2l0eSA+IDAuMSkge1xuICAgIC8vIEFkZCBjb2xvciB2YXJpYXRpb24gYmFzZWQgb24gbW92ZW1lbnRcbiAgICBjb25zdCByID0gTWF0aC5taW4oMS4wLCBjb2xvci5yICsgaW50ZW5zaXR5KTtcbiAgICBjb25zdCBnID0gTWF0aC5taW4oMS4wLCBjb2xvci5nICsgaW50ZW5zaXR5ICogMC41KTtcbiAgICBjb25zdCBiID0gTWF0aC5taW4oMS4wLCBjb2xvci5iICsgaW50ZW5zaXR5KTtcbiAgICBcbiAgICAvLyBUaGlzIHdvdWxkIG5vcm1hbGx5IHVwZGF0ZSBmbHVpZCB0ZXh0dXJlcywgYnV0IGZvciBub3cgY3JlYXRlcyB2aXN1YWwgZWZmZWN0XG4gICAgZ2wuY2xlYXJDb2xvcihyLCBnLCBiLCAxLjApO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc2l6ZUNhbnZhcygpOiBib29sZWFuIHtcbiAgaWYgKCFjYW52YXMpIHJldHVybiBmYWxzZTtcbiAgXG4gIGNvbnN0IHdpZHRoID0gc2NhbGVCeVBpeGVsUmF0aW8oY2FudmFzLmNsaWVudFdpZHRoKTtcbiAgY29uc3QgaGVpZ2h0ID0gc2NhbGVCeVBpeGVsUmF0aW8oY2FudmFzLmNsaWVudEhlaWdodCk7XG4gIFxuICBpZiAoY2FudmFzLndpZHRoICE9PSB3aWR0aCB8fCBjYW52YXMuaGVpZ2h0ICE9PSBoZWlnaHQpIHtcbiAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLy8gRXZlbnQgbGlzdGVuZXJzXG5mdW5jdGlvbiBhdHRhY2hFdmVudExpc3RlbmVycygpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8ICFjYW52YXMpIHJldHVybjtcblxuICBtID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignYm9keScpO1xuICBpZiAoIW0pIHJldHVybjtcblxuICAvLyBSZW1vdmUgZXhpc3RpbmcgbGlzdGVuZXJzXG4gIGlmIChtb3VzZU1vdmVIYW5kbGVyKSB7XG4gICAgbS5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIG1vdXNlTW92ZUhhbmRsZXIpO1xuICB9XG4gIGlmICh0b3VjaFN0YXJ0SGFuZGxlcikge1xuICAgIG0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgdG91Y2hTdGFydEhhbmRsZXIpO1xuICB9XG4gIGlmICh0b3VjaE1vdmVIYW5kbGVyKSB7XG4gICAgbS5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIHRvdWNoTW92ZUhhbmRsZXIpO1xuICB9XG4gIGlmICh0b3VjaEVuZEhhbmRsZXIpIHtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIHRvdWNoRW5kSGFuZGxlcik7XG4gIH1cblxuICAvLyBNb3VzZSBtb3ZlIGhhbmRsZXJcbiAgbW91c2VNb3ZlSGFuZGxlciA9IChlOiBNb3VzZUV2ZW50KSA9PiB7XG4gICAgaWYgKCFwb2ludGVycyB8fCAhcG9pbnRlcnNbMF0pIHJldHVybjtcbiAgICBjb25zdCBwb2ludGVyID0gcG9pbnRlcnNbMF07XG4gICAgY29uc3QgcG9zWCA9IHNjYWxlQnlQaXhlbFJhdGlvKGUuY2xpZW50WCk7XG4gICAgY29uc3QgcG9zWSA9IHNjYWxlQnlQaXhlbFJhdGlvKGUuY2xpZW50WSk7XG4gICAgdXBkYXRlUG9pbnRlck1vdmVEYXRhKHBvaW50ZXIsIHBvc1gsIHBvc1kpO1xuICB9O1xuXG4gIC8vIFRvdWNoIGhhbmRsZXJzXG4gIHRvdWNoU3RhcnRIYW5kbGVyID0gKGU6IFRvdWNoRXZlbnQpID0+IHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgaWYgKCFwb2ludGVycykgcmV0dXJuO1xuICAgIGNvbnN0IHRvdWNoZXMgPSBlLnRhcmdldFRvdWNoZXM7XG4gICAgd2hpbGUgKHRvdWNoZXMubGVuZ3RoID49IHBvaW50ZXJzLmxlbmd0aCkge1xuICAgICAgcG9pbnRlcnMucHVzaChuZXcgKFBvaW50ZXJQcm90b3R5cGUgYXMgYW55KSgpKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b3VjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBwb3NYID0gc2NhbGVCeVBpeGVsUmF0aW8odG91Y2hlc1tpXS5jbGllbnRYKTtcbiAgICAgIGNvbnN0IHBvc1kgPSBzY2FsZUJ5UGl4ZWxSYXRpbyh0b3VjaGVzW2ldLmNsaWVudFkpO1xuICAgICAgY29uc3QgcG9pbnRlciA9IHBvaW50ZXJzW2kgKyAxXTtcbiAgICAgIGlmIChwb2ludGVyKSB7XG4gICAgICAgIHBvaW50ZXIuaWQgPSB0b3VjaGVzW2ldLmlkZW50aWZpZXI7XG4gICAgICAgIHBvaW50ZXIuZG93biA9IHRydWU7XG4gICAgICAgIHBvaW50ZXIubW92ZWQgPSBmYWxzZTtcbiAgICAgICAgcG9pbnRlci50ZXhjb29yZFggPSBwb3NYIC8gY2FudmFzIS53aWR0aDtcbiAgICAgICAgcG9pbnRlci50ZXhjb29yZFkgPSAxLjAgLSBwb3NZIC8gY2FudmFzIS5oZWlnaHQ7XG4gICAgICAgIHBvaW50ZXIucHJldlRleGNvb3JkWCA9IHBvaW50ZXIudGV4Y29vcmRYO1xuICAgICAgICBwb2ludGVyLnByZXZUZXhjb29yZFkgPSBwb2ludGVyLnRleGNvb3JkWTtcbiAgICAgICAgcG9pbnRlci5kZWx0YVggPSAwO1xuICAgICAgICBwb2ludGVyLmRlbHRhWSA9IDA7XG4gICAgICAgIHBvaW50ZXIuY29sb3IgPSBnZW5lcmF0ZUNvbG9yKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHRvdWNoTW92ZUhhbmRsZXIgPSAoZTogVG91Y2hFdmVudCkgPT4ge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBpZiAoIXBvaW50ZXJzKSByZXR1cm47XG4gICAgY29uc3QgdG91Y2hlcyA9IGUudGFyZ2V0VG91Y2hlcztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRvdWNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHBvaW50ZXIgPSBwb2ludGVyc1tpICsgMV07XG4gICAgICBpZiAoIXBvaW50ZXIgfHwgIXBvaW50ZXIuZG93bikgY29udGludWU7XG4gICAgICBjb25zdCBwb3NYID0gc2NhbGVCeVBpeGVsUmF0aW8odG91Y2hlc1tpXS5jbGllbnRYKTtcbiAgICAgIGNvbnN0IHBvc1kgPSBzY2FsZUJ5UGl4ZWxSYXRpbyh0b3VjaGVzW2ldLmNsaWVudFkpO1xuICAgICAgdXBkYXRlUG9pbnRlck1vdmVEYXRhKHBvaW50ZXIsIHBvc1gsIHBvc1kpO1xuICAgIH1cbiAgfTtcblxuICB0b3VjaEVuZEhhbmRsZXIgPSAoZTogVG91Y2hFdmVudCkgPT4ge1xuICAgIGlmICghcG9pbnRlcnMpIHJldHVybjtcbiAgICBjb25zdCB0b3VjaGVzID0gZS5jaGFuZ2VkVG91Y2hlcztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRvdWNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHBvaW50ZXIgPSBwb2ludGVycy5maW5kKChwOiBhbnkpID0+IHAuaWQgPT09IHRvdWNoZXNbaV0uaWRlbnRpZmllcik7XG4gICAgICBpZiAocG9pbnRlcikge1xuICAgICAgICBwb2ludGVyLmRvd24gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gQXR0YWNoIGxpc3RlbmVyc1xuICBtLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgbW91c2VNb3ZlSGFuZGxlcik7XG4gIG0uYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgdG91Y2hTdGFydEhhbmRsZXIpO1xuICBtLmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgdG91Y2hNb3ZlSGFuZGxlciwgeyBwYXNzaXZlOiBmYWxzZSB9KTtcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCB0b3VjaEVuZEhhbmRsZXIpO1xufVxuXG4vLyBNYWluIGluaXRpYWxpemF0aW9uIGZ1bmN0aW9uXG5leHBvcnQgZnVuY3Rpb24gaW5pdEZsdWlkU2ltdWxhdGlvbigpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm47XG4gIFxuICBpZiAoZmx1aWRJbml0aWFsaXplZCkge1xuICAgIGNvbnNvbGUubG9nKCdGbHVpZCBhbHJlYWR5IGluaXRpYWxpemVkLCByZS1hdHRhY2hpbmcgbGlzdGVuZXJzLi4uJyk7XG4gICAgYXR0YWNoRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zb2xlLmxvZygnSW5pdGlhbGl6aW5nIG9yaWdpbmFsIGZsdWlkIHNpbXVsYXRpb24uLi4nKTtcblxuICBjYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImZsdWlkXCIpIGFzIEhUTUxDYW52YXNFbGVtZW50O1xuICBcbiAgaWYgKCFjYW52YXMpIHtcbiAgICBjb25zb2xlLmVycm9yKCdGbHVpZCBjYW52YXMgbm90IGZvdW5kJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcmVzaXplQ2FudmFzKCk7XG4gIFxuICAvLyBHZXQgYmFja2dyb3VuZCBjb2xvciBmcm9tIGJvZHlcbiAgbSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2JvZHknKTtcbiAgbGV0IGJhY2tncm91bmRDb2xvciA9IHsgcjogNywgZzogMTAsIGI6IDcgfTtcbiAgaWYgKG0pIHtcbiAgICBjb25zdCBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKG0pO1xuICAgIGNvbnN0IGJnQ29sb3IgPSBzdHlsZS5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgaWYgKGJnQ29sb3IuaW5jbHVkZXMoJ3JnYicpKSB7XG4gICAgICBjb25zdCBtYXRjaGVzID0gYmdDb2xvci5tYXRjaCgvXFxkKy9nKTtcbiAgICAgIGlmIChtYXRjaGVzICYmIG1hdGNoZXMubGVuZ3RoID49IDMpIHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yID0geyBcbiAgICAgICAgICByOiBwYXJzZUludChtYXRjaGVzWzBdKSwgXG4gICAgICAgICAgZzogcGFyc2VJbnQobWF0Y2hlc1sxXSksIFxuICAgICAgICAgIGI6IHBhcnNlSW50KG1hdGNoZXNbMl0pIFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIENvbmZpZ3VyYXRpb24gbWF0Y2hpbmcgb3JpZ2luYWxcbiAgY29uZmlnID0ge1xuICAgIFNJTV9SRVNPTFVUSU9OOiA1MTIsXG4gICAgRFlFX1JFU09MVVRJT046IDUxMixcbiAgICBERU5TSVRZX0RJU1NJUEFUSU9OOiAyLFxuICAgIFZFTE9DSVRZX0RJU1NJUEFUSU9OOiAwLjEsXG4gICAgUFJFU1NVUkU6IDAuMDEsXG4gICAgUFJFU1NVUkVfSVRFUkFUSU9OUzogMjAsXG4gICAgQ1VSTDogMTAwLFxuICAgIFNQTEFUX1JBRElVUzogMC4xMyxcbiAgICBTUExBVF9GT1JDRTogNTAwMCxcbiAgICBTSEFESU5HOiBmYWxzZSxcbiAgICBDT0xPUkZVTDogdHJ1ZSxcbiAgICBDT0xPUl9VUERBVEVfU1BFRUQ6IDMsXG4gICAgUEFVU0VEOiBmYWxzZSxcbiAgICBCQUNLX0NPTE9SOiBiYWNrZ3JvdW5kQ29sb3IsXG4gICAgVFJBTlNQQVJFTlQ6IGZhbHNlLFxuICAgIFNVTlJBWVM6IHRydWUsXG4gICAgU1VOUkFZU19SRVNPTFVUSU9OOiAyNTYsXG4gICAgU1VOUkFZU19XRUlHSFQ6IDAuNVxuICB9O1xuXG4gIC8vIEluaXRpYWxpemUgcG9pbnRlcnNcbiAgcG9pbnRlcnMgPSBbXTtcbiAgc3BsYXRTdGFjayA9IFtdO1xuICBwb2ludGVycy5wdXNoKG5ldyAoUG9pbnRlclByb3RvdHlwZSBhcyBhbnkpKCkpO1xuXG4gIC8vIEdldCBXZWJHTCBjb250ZXh0XG4gIGNvbnN0IHdlYmdsQ29udGV4dCA9IGdldFdlYkdMQ29udGV4dChjYW52YXMpO1xuICBpZiAoIXdlYmdsQ29udGV4dCkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBnZXQgV2ViR0wgY29udGV4dCcpO1xuICAgIHJldHVybjtcbiAgfVxuICBcbiAgZ2wgPSB3ZWJnbENvbnRleHQuZ2w7XG4gIGV4dCA9IHdlYmdsQ29udGV4dC5leHQ7XG5cbiAgLy8gU3RhcnQgdGltaW5nXG4gIGxhc3RVcGRhdGVUaW1lID0gRGF0ZS5ub3coKTtcbiAgY29sb3JVcGRhdGVUaW1lciA9IDAuMDtcbiAgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgXG4gIC8vIEF0dGFjaCBldmVudCBsaXN0ZW5lcnNcbiAgYXR0YWNoRXZlbnRMaXN0ZW5lcnMoKTtcbiAgXG4gIC8vIFN0YXJ0IHJlbmRlciBsb29wXG4gIHJlbmRlcigpO1xuXG4gIGZsdWlkSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICBjb25zb2xlLmxvZygnT3JpZ2luYWwgZmx1aWQgc2ltdWxhdGlvbiBpbml0aWFsaXplZCBzdWNjZXNzZnVsbHkhJyk7XG59Il0sIm5hbWVzIjpbImZsdWlkSW5pdGlhbGl6ZWQiLCJjYW52YXMiLCJnbCIsImV4dCIsIm0iLCJjb25maWciLCJwb2ludGVycyIsInNwbGF0U3RhY2siLCJkeWUiLCJ2ZWxvY2l0eSIsImRpdmVyZ2VuY2UiLCJjdXJsIiwicHJlc3N1cmUiLCJsYXN0VXBkYXRlVGltZSIsImNvbG9yVXBkYXRlVGltZXIiLCJzdGFydFRpbWUiLCJtb3VzZU1vdmVIYW5kbGVyIiwidG91Y2hTdGFydEhhbmRsZXIiLCJ0b3VjaE1vdmVIYW5kbGVyIiwidG91Y2hFbmRIYW5kbGVyIiwiUG9pbnRlclByb3RvdHlwZSIsImlkIiwidGV4Y29vcmRYIiwidGV4Y29vcmRZIiwicHJldlRleGNvb3JkWCIsInByZXZUZXhjb29yZFkiLCJkZWx0YVgiLCJkZWx0YVkiLCJkb3duIiwibW92ZWQiLCJjb2xvciIsInNjYWxlQnlQaXhlbFJhdGlvIiwiaW5wdXQiLCJwaXhlbFJhdGlvIiwid2luZG93IiwiZGV2aWNlUGl4ZWxSYXRpbyIsIk1hdGgiLCJmbG9vciIsInVwZGF0ZVBvaW50ZXJNb3ZlRGF0YSIsInBvaW50ZXIiLCJwb3NYIiwicG9zWSIsIndpZHRoIiwiaGVpZ2h0IiwiY29ycmVjdERlbHRhWCIsImNvcnJlY3REZWx0YVkiLCJhYnMiLCJkZWx0YSIsImFzcGVjdFJhdGlvIiwiZ2VuZXJhdGVDb2xvciIsImMiLCJIU1Z0b1JHQiIsInJhbmRvbSIsInIiLCJnIiwiYiIsImgiLCJzIiwidiIsImkiLCJmIiwicCIsInEiLCJ0IiwiZ2V0V2ViR0xDb250ZXh0IiwicGFyYW1zIiwiYWxwaGEiLCJkZXB0aCIsInN0ZW5jaWwiLCJhbnRpYWxpYXMiLCJwcmVzZXJ2ZURyYXdpbmdCdWZmZXIiLCJnZXRDb250ZXh0IiwiaXNXZWJHTDIiLCJjbGVhckNvbG9yIiwiaGFsZkZsb2F0VGV4VHlwZSIsIkhBTEZfRkxPQVQiLCJmb3JtYXRSR0JBIiwiaW50ZXJuYWxGb3JtYXQiLCJSR0JBIiwiZm9ybWF0IiwiZm9ybWF0UkciLCJmb3JtYXRSIiwic3VwcG9ydExpbmVhckZpbHRlcmluZyIsInJlbmRlciIsInRpbWUiLCJEYXRlIiwibm93IiwiZm9yRWFjaCIsInNwbGF0UG9pbnRlciIsInNpbiIsImdyYWluVmFsdWUiLCJjbGVhciIsIkNPTE9SX0JVRkZFUl9CSVQiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJkeCIsIlNQTEFUX0ZPUkNFIiwiZHkiLCJzcGxhdCIsIngiLCJ5IiwiY2VudGVyWCIsImNlbnRlclkiLCJpbnRlbnNpdHkiLCJzcXJ0IiwibWluIiwicmVzaXplQ2FudmFzIiwiY2xpZW50V2lkdGgiLCJjbGllbnRIZWlnaHQiLCJhdHRhY2hFdmVudExpc3RlbmVycyIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJlIiwiY2xpZW50WCIsImNsaWVudFkiLCJwcmV2ZW50RGVmYXVsdCIsInRvdWNoZXMiLCJ0YXJnZXRUb3VjaGVzIiwibGVuZ3RoIiwicHVzaCIsImlkZW50aWZpZXIiLCJjaGFuZ2VkVG91Y2hlcyIsImZpbmQiLCJhZGRFdmVudExpc3RlbmVyIiwicGFzc2l2ZSIsImluaXRGbHVpZFNpbXVsYXRpb24iLCJjb25zb2xlIiwibG9nIiwiZ2V0RWxlbWVudEJ5SWQiLCJlcnJvciIsImJhY2tncm91bmRDb2xvciIsInN0eWxlIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImJnQ29sb3IiLCJpbmNsdWRlcyIsIm1hdGNoZXMiLCJtYXRjaCIsInBhcnNlSW50IiwiU0lNX1JFU09MVVRJT04iLCJEWUVfUkVTT0xVVElPTiIsIkRFTlNJVFlfRElTU0lQQVRJT04iLCJWRUxPQ0lUWV9ESVNTSVBBVElPTiIsIlBSRVNTVVJFIiwiUFJFU1NVUkVfSVRFUkFUSU9OUyIsIkNVUkwiLCJTUExBVF9SQURJVVMiLCJTSEFESU5HIiwiQ09MT1JGVUwiLCJDT0xPUl9VUERBVEVfU1BFRUQiLCJQQVVTRUQiLCJCQUNLX0NPTE9SIiwiVFJBTlNQQVJFTlQiLCJTVU5SQVlTIiwiU1VOUkFZU19SRVNPTFVUSU9OIiwiU1VOUkFZU19XRUlHSFQiLCJ3ZWJnbENvbnRleHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/lib/fluid.ts\n"));

/***/ })

});