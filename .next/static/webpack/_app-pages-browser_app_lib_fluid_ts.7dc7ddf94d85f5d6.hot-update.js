"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_app-pages-browser_app_lib_fluid_ts",{

/***/ "(app-pages-browser)/./app/lib/fluid.ts":
/*!**************************!*\
  !*** ./app/lib/fluid.ts ***!
  \**************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   initFluidSimulation: function() { return /* binding */ initFluidSimulation; }\n/* harmony export */ });\n// Proper fluid simulation for Next.js with localized mouse effects\nlet fluidInitialized = false;\nlet canvas = null;\nlet ctx = null;\nlet particles = [];\nlet mouseX = 0;\nlet mouseY = 0;\nlet mouseVX = 0;\nlet mouseVY = 0;\nlet lastMouseX = 0;\nlet lastMouseY = 0;\n// Configuration\nconst config = {\n    maxParticles: 150,\n    particleLife: 60,\n    trailLength: 20,\n    mouseInfluence: 100,\n    colorVariation: 0.3,\n    fadeSpeed: 0.02\n};\nfunction createParticle(x, y, vx, vy) {\n    const speed = Math.sqrt(vx * vx + vy * vy);\n    const hue = (Date.now() * 0.001 + speed * 10) % 360;\n    return {\n        x,\n        y,\n        vx: vx + (Math.random() - 0.5) * 2,\n        vy: vy + (Math.random() - 0.5) * 2,\n        life: config.particleLife,\n        maxLife: config.particleLife,\n        size: Math.random() * 3 + 1,\n        color: hsvToRgb(hue, 0.8, 1.0)\n    };\n}\nfunction hsvToRgb(h, s, v) {\n    const c = v * s;\n    const x = c * (1 - Math.abs(h / 60 % 2 - 1));\n    const m = v - c;\n    let r = 0, g = 0, b = 0;\n    if (0 <= h && h < 60) {\n        r = c;\n        g = x;\n        b = 0;\n    } else if (60 <= h && h < 120) {\n        r = x;\n        g = c;\n        b = 0;\n    } else if (120 <= h && h < 180) {\n        r = 0;\n        g = c;\n        b = x;\n    } else if (180 <= h && h < 240) {\n        r = 0;\n        g = x;\n        b = c;\n    } else if (240 <= h && h < 300) {\n        r = x;\n        g = 0;\n        b = c;\n    } else if (300 <= h && h < 360) {\n        r = c;\n        g = 0;\n        b = x;\n    }\n    return {\n        r: Math.round((r + m) * 255),\n        g: Math.round((g + m) * 255),\n        b: Math.round((b + m) * 255),\n        a: 1\n    };\n}\nfunction updateParticles() {\n    // Update existing particles\n    for(let i = particles.length - 1; i >= 0; i--){\n        const particle = particles[i];\n        // Update position\n        particle.x += particle.vx;\n        particle.y += particle.vy;\n        // Apply drag\n        particle.vx *= 0.98;\n        particle.vy *= 0.98;\n        // Update life\n        particle.life--;\n        particle.color.a = particle.life / particle.maxLife;\n        // Remove dead particles\n        if (particle.life <= 0) {\n            particles.splice(i, 1);\n        }\n    }\n    // Add new particles at mouse position if moving\n    const mouseSpeed = Math.sqrt(mouseVX * mouseVX + mouseVY * mouseVY);\n    if (mouseSpeed > 0.5 && particles.length < config.maxParticles) {\n        const numNewParticles = Math.min(3, Math.floor(mouseSpeed * 0.5));\n        for(let i = 0; i < numNewParticles; i++){\n            particles.push(createParticle(mouseX + (Math.random() - 0.5) * 10, mouseY + (Math.random() - 0.5) * 10, mouseVX * 0.3 + (Math.random() - 0.5) * 2, mouseVY * 0.3 + (Math.random() - 0.5) * 2));\n        }\n    }\n}\nfunction drawParticles() {\n    if (!ctx || !canvas) return;\n    // Clear with fade effect\n    ctx.fillStyle = \"rgba(7, 10, 7, 0.05)\";\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n    // Draw particles with trails\n    particles.forEach((particle)=>{\n        const alpha = particle.color.a * 0.8;\n        // Draw main particle\n        ctx.beginPath();\n        ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);\n        ctx.fillStyle = \"rgba(\".concat(particle.color.r, \", \").concat(particle.color.g, \", \").concat(particle.color.b, \", \").concat(alpha, \")\");\n        ctx.fill();\n        // Draw glow effect\n        const gradient = ctx.createRadialGradient(particle.x, particle.y, 0, particle.x, particle.y, particle.size * 3);\n        gradient.addColorStop(0, \"rgba(\".concat(particle.color.r, \", \").concat(particle.color.g, \", \").concat(particle.color.b, \", \").concat(alpha * 0.3, \")\"));\n        gradient.addColorStop(1, \"rgba(0, 0, 0, 0)\");\n        ctx.beginPath();\n        ctx.arc(particle.x, particle.y, particle.size * 3, 0, Math.PI * 2);\n        ctx.fillStyle = gradient;\n        ctx.fill();\n    });\n    // Draw connections between nearby particles\n    for(let i = 0; i < particles.length; i++){\n        for(let j = i + 1; j < particles.length; j++){\n            const p1 = particles[i];\n            const p2 = particles[j];\n            const dist = Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2);\n            if (dist < 80) {\n                const alpha = (1 - dist / 80) * 0.2 * Math.min(p1.color.a, p2.color.a);\n                ctx.beginPath();\n                ctx.moveTo(p1.x, p1.y);\n                ctx.lineTo(p2.x, p2.y);\n                ctx.strokeStyle = \"rgba(255, 255, 255, \".concat(alpha, \")\");\n                ctx.lineWidth = 0.5;\n                ctx.stroke();\n            }\n        }\n    }\n}\nfunction animate() {\n    updateParticles();\n    drawParticles();\n    requestAnimationFrame(animate);\n}\nfunction resizeCanvas() {\n    if (!canvas) return false;\n    const rect = canvas.getBoundingClientRect();\n    const dpr = window.devicePixelRatio || 1;\n    canvas.width = rect.width * dpr;\n    canvas.height = rect.height * dpr;\n    if (ctx) {\n        ctx.scale(dpr, dpr);\n    }\n    canvas.style.width = rect.width + \"px\";\n    canvas.style.height = rect.height + \"px\";\n    return true;\n}\n// Event handlers\nfunction attachEventListeners() {\n    if ( false || !canvas) return;\n    const body = document.querySelector(\"body\");\n    if (!body) return;\n    const mouseMoveHandler = (e)=>{\n        const rect = canvas.getBoundingClientRect();\n        const newMouseX = e.clientX - rect.left;\n        const newMouseY = e.clientY - rect.top;\n        mouseVX = newMouseX - mouseX;\n        mouseVY = newMouseY - mouseY;\n        mouseX = newMouseX;\n        mouseY = newMouseY;\n    };\n    const touchMoveHandler = (e)=>{\n        e.preventDefault();\n        if (e.touches.length > 0) {\n            const rect = canvas.getBoundingClientRect();\n            const touch = e.touches[0];\n            const newMouseX = touch.clientX - rect.left;\n            const newMouseY = touch.clientY - rect.top;\n            mouseVX = newMouseX - mouseX;\n            mouseVY = newMouseY - mouseY;\n            mouseX = newMouseX;\n            mouseY = newMouseY;\n        }\n    };\n    const resizeHandler = ()=>{\n        resizeCanvas();\n    };\n    body.addEventListener(\"mousemove\", mouseMoveHandler);\n    body.addEventListener(\"touchmove\", touchMoveHandler, {\n        passive: false\n    });\n    window.addEventListener(\"resize\", resizeHandler);\n    // Store handlers for cleanup\n    canvas._eventHandlers = {\n        mouseMoveHandler,\n        touchMoveHandler,\n        resizeHandler\n    };\n}\n// Main initialization function\nfunction initFluidSimulation() {\n    if (false) {}\n    if (fluidInitialized) {\n        console.log(\"Fluid already initialized\");\n        return;\n    }\n    console.log(\"Initializing fluid simulation...\");\n    canvas = document.getElementById(\"fluid\");\n    if (!canvas) {\n        console.error(\"Fluid canvas not found\");\n        return;\n    }\n    ctx = canvas.getContext(\"2d\");\n    if (!ctx) {\n        console.error(\"Could not get 2D context\");\n        return;\n    }\n    // Set up canvas\n    resizeCanvas();\n    // Initialize mouse position\n    mouseX = canvas.width / 2;\n    mouseY = canvas.height / 2;\n    // Attach event listeners\n    attachEventListeners();\n    // Start animation loop\n    animate();\n    fluidInitialized = true;\n    console.log(\"Fluid simulation initialized successfully!\");\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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TUwsT0FBTyxHQUFHakIsS0FBS2tCLEdBQUc7WUFFMUM3RixVQUFVd0YsWUFBWTFGO1lBQ3RCRyxVQUFVMEYsWUFBWTVGO1lBQ3RCRCxTQUFTMEY7WUFDVHpGLFNBQVM0RjtRQUNYO0lBQ0Y7SUFFQSxNQUFNTyxnQkFBZ0I7UUFDcEJ4QjtJQUNGO0lBRUFTLEtBQUtnQixnQkFBZ0IsQ0FBQyxhQUFhYjtJQUNuQ0gsS0FBS2dCLGdCQUFnQixDQUFDLGFBQWFMLGtCQUFrQjtRQUFFTSxTQUFTO0lBQU07SUFDdEV0QixPQUFPcUIsZ0JBQWdCLENBQUMsVUFBVUQ7SUFFbEMsNkJBQTZCO0lBQzVCdkcsT0FBZTBHLGNBQWMsR0FBRztRQUMvQmY7UUFDQVE7UUFDQUk7SUFDRjtBQUNGO0FBRUEsK0JBQStCO0FBQ3hCLFNBQVNJO0lBQ2QsSUFBSSxLQUFrQixFQUFhLEVBQU87SUFFMUMsSUFBSTVHLGtCQUFrQjtRQUNwQjZHLFFBQVFDLEdBQUcsQ0FBQztRQUNaO0lBQ0Y7SUFFQUQsUUFBUUMsR0FBRyxDQUFDO0lBRVo3RyxTQUFTeUYsU0FBU3FCLGNBQWMsQ0FBQztJQUVqQyxJQUFJLENBQUM5RyxRQUFRO1FBQ1g0RyxRQUFRRyxLQUFLLENBQUM7UUFDZDtJQUNGO0lBRUE5RyxNQUFNRCxPQUFPZ0gsVUFBVSxDQUFDO0lBQ3hCLElBQUksQ0FBQy9HLEtBQUs7UUFDUjJHLFFBQVFHLEtBQUssQ0FBQztRQUNkO0lBQ0Y7SUFFQSxnQkFBZ0I7SUFDaEJoQztJQUVBLDRCQUE0QjtJQUM1QjVFLFNBQVNILE9BQU95RCxLQUFLLEdBQUc7SUFDeEJyRCxTQUFTSixPQUFPMEQsTUFBTSxHQUFHO0lBRXpCLHlCQUF5QjtJQUN6QjZCO0lBRUEsdUJBQXVCO0lBQ3ZCVjtJQUVBOUUsbUJBQW1CO0lBQ25CNkcsUUFBUUMsR0FBRyxDQUFDO0FBQ2QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vYXBwL2xpYi9mbHVpZC50cz9mYjNkIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFByb3BlciBmbHVpZCBzaW11bGF0aW9uIGZvciBOZXh0LmpzIHdpdGggbG9jYWxpemVkIG1vdXNlIGVmZmVjdHNcblxubGV0IGZsdWlkSW5pdGlhbGl6ZWQgPSBmYWxzZTtcbmxldCBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50IHwgbnVsbCA9IG51bGw7XG5sZXQgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQgfCBudWxsID0gbnVsbDtcblxuLy8gRmx1aWQgcGFydGljbGVzIHN5c3RlbVxuaW50ZXJmYWNlIEZsdWlkUGFydGljbGUge1xuICB4OiBudW1iZXI7XG4gIHk6IG51bWJlcjtcbiAgdng6IG51bWJlcjtcbiAgdnk6IG51bWJlcjtcbiAgbGlmZTogbnVtYmVyO1xuICBtYXhMaWZlOiBudW1iZXI7XG4gIHNpemU6IG51bWJlcjtcbiAgY29sb3I6IHsgcjogbnVtYmVyOyBnOiBudW1iZXI7IGI6IG51bWJlcjsgYTogbnVtYmVyIH07XG59XG5cbmxldCBwYXJ0aWNsZXM6IEZsdWlkUGFydGljbGVbXSA9IFtdO1xubGV0IG1vdXNlWCA9IDA7XG5sZXQgbW91c2VZID0gMDtcbmxldCBtb3VzZVZYID0gMDtcbmxldCBtb3VzZVZZID0gMDtcbmxldCBsYXN0TW91c2VYID0gMDtcbmxldCBsYXN0TW91c2VZID0gMDtcblxuLy8gQ29uZmlndXJhdGlvblxuY29uc3QgY29uZmlnID0ge1xuICBtYXhQYXJ0aWNsZXM6IDE1MCxcbiAgcGFydGljbGVMaWZlOiA2MCxcbiAgdHJhaWxMZW5ndGg6IDIwLFxuICBtb3VzZUluZmx1ZW5jZTogMTAwLFxuICBjb2xvclZhcmlhdGlvbjogMC4zLFxuICBmYWRlU3BlZWQ6IDAuMDIsXG59O1xuXG5mdW5jdGlvbiBjcmVhdGVQYXJ0aWNsZSh4OiBudW1iZXIsIHk6IG51bWJlciwgdng6IG51bWJlciwgdnk6IG51bWJlcik6IEZsdWlkUGFydGljbGUge1xuICBjb25zdCBzcGVlZCA9IE1hdGguc3FydCh2eCAqIHZ4ICsgdnkgKiB2eSk7XG4gIGNvbnN0IGh1ZSA9IChEYXRlLm5vdygpICogMC4wMDEgKyBzcGVlZCAqIDEwKSAlIDM2MDtcbiAgXG4gIHJldHVybiB7XG4gICAgeCxcbiAgICB5LFxuICAgIHZ4OiB2eCArIChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIDIsXG4gICAgdnk6IHZ5ICsgKE1hdGgucmFuZG9tKCkgLSAwLjUpICogMixcbiAgICBsaWZlOiBjb25maWcucGFydGljbGVMaWZlLFxuICAgIG1heExpZmU6IGNvbmZpZy5wYXJ0aWNsZUxpZmUsXG4gICAgc2l6ZTogTWF0aC5yYW5kb20oKSAqIDMgKyAxLFxuICAgIGNvbG9yOiBoc3ZUb1JnYihodWUsIDAuOCwgMS4wKVxuICB9O1xufVxuXG5mdW5jdGlvbiBoc3ZUb1JnYihoOiBudW1iZXIsIHM6IG51bWJlciwgdjogbnVtYmVyKTogeyByOiBudW1iZXI7IGc6IG51bWJlcjsgYjogbnVtYmVyOyBhOiBudW1iZXIgfSB7XG4gIGNvbnN0IGMgPSB2ICogcztcbiAgY29uc3QgeCA9IGMgKiAoMSAtIE1hdGguYWJzKChoIC8gNjApICUgMiAtIDEpKTtcbiAgY29uc3QgbSA9IHYgLSBjO1xuICBsZXQgciA9IDAsIGcgPSAwLCBiID0gMDtcblxuICBpZiAoMCA8PSBoICYmIGggPCA2MCkge1xuICAgIHIgPSBjOyBnID0geDsgYiA9IDA7XG4gIH0gZWxzZSBpZiAoNjAgPD0gaCAmJiBoIDwgMTIwKSB7XG4gICAgciA9IHg7IGcgPSBjOyBiID0gMDtcbiAgfSBlbHNlIGlmICgxMjAgPD0gaCAmJiBoIDwgMTgwKSB7XG4gICAgciA9IDA7IGcgPSBjOyBiID0geDtcbiAgfSBlbHNlIGlmICgxODAgPD0gaCAmJiBoIDwgMjQwKSB7XG4gICAgciA9IDA7IGcgPSB4OyBiID0gYztcbiAgfSBlbHNlIGlmICgyNDAgPD0gaCAmJiBoIDwgMzAwKSB7XG4gICAgciA9IHg7IGcgPSAwOyBiID0gYztcbiAgfSBlbHNlIGlmICgzMDAgPD0gaCAmJiBoIDwgMzYwKSB7XG4gICAgciA9IGM7IGcgPSAwOyBiID0geDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcjogTWF0aC5yb3VuZCgociArIG0pICogMjU1KSxcbiAgICBnOiBNYXRoLnJvdW5kKChnICsgbSkgKiAyNTUpLFxuICAgIGI6IE1hdGgucm91bmQoKGIgKyBtKSAqIDI1NSksXG4gICAgYTogMVxuICB9O1xufVxuXG5mdW5jdGlvbiB1cGRhdGVQYXJ0aWNsZXMoKSB7XG4gIC8vIFVwZGF0ZSBleGlzdGluZyBwYXJ0aWNsZXNcbiAgZm9yIChsZXQgaSA9IHBhcnRpY2xlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGNvbnN0IHBhcnRpY2xlID0gcGFydGljbGVzW2ldO1xuICAgIFxuICAgIC8vIFVwZGF0ZSBwb3NpdGlvblxuICAgIHBhcnRpY2xlLnggKz0gcGFydGljbGUudng7XG4gICAgcGFydGljbGUueSArPSBwYXJ0aWNsZS52eTtcbiAgICBcbiAgICAvLyBBcHBseSBkcmFnXG4gICAgcGFydGljbGUudnggKj0gMC45ODtcbiAgICBwYXJ0aWNsZS52eSAqPSAwLjk4O1xuICAgIFxuICAgIC8vIFVwZGF0ZSBsaWZlXG4gICAgcGFydGljbGUubGlmZS0tO1xuICAgIHBhcnRpY2xlLmNvbG9yLmEgPSBwYXJ0aWNsZS5saWZlIC8gcGFydGljbGUubWF4TGlmZTtcbiAgICBcbiAgICAvLyBSZW1vdmUgZGVhZCBwYXJ0aWNsZXNcbiAgICBpZiAocGFydGljbGUubGlmZSA8PSAwKSB7XG4gICAgICBwYXJ0aWNsZXMuc3BsaWNlKGksIDEpO1xuICAgIH1cbiAgfVxuICBcbiAgLy8gQWRkIG5ldyBwYXJ0aWNsZXMgYXQgbW91c2UgcG9zaXRpb24gaWYgbW92aW5nXG4gIGNvbnN0IG1vdXNlU3BlZWQgPSBNYXRoLnNxcnQobW91c2VWWCAqIG1vdXNlVlggKyBtb3VzZVZZICogbW91c2VWWSk7XG4gIGlmIChtb3VzZVNwZWVkID4gMC41ICYmIHBhcnRpY2xlcy5sZW5ndGggPCBjb25maWcubWF4UGFydGljbGVzKSB7XG4gICAgY29uc3QgbnVtTmV3UGFydGljbGVzID0gTWF0aC5taW4oMywgTWF0aC5mbG9vcihtb3VzZVNwZWVkICogMC41KSk7XG4gICAgXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1OZXdQYXJ0aWNsZXM7IGkrKykge1xuICAgICAgcGFydGljbGVzLnB1c2goY3JlYXRlUGFydGljbGUoXG4gICAgICAgIG1vdXNlWCArIChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIDEwLFxuICAgICAgICBtb3VzZVkgKyAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAxMCxcbiAgICAgICAgbW91c2VWWCAqIDAuMyArIChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIDIsXG4gICAgICAgIG1vdXNlVlkgKiAwLjMgKyAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAyXG4gICAgICApKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZHJhd1BhcnRpY2xlcygpIHtcbiAgaWYgKCFjdHggfHwgIWNhbnZhcykgcmV0dXJuO1xuICBcbiAgLy8gQ2xlYXIgd2l0aCBmYWRlIGVmZmVjdFxuICBjdHguZmlsbFN0eWxlID0gJ3JnYmEoNywgMTAsIDcsIDAuMDUpJztcbiAgY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gIFxuICAvLyBEcmF3IHBhcnRpY2xlcyB3aXRoIHRyYWlsc1xuICBwYXJ0aWNsZXMuZm9yRWFjaChwYXJ0aWNsZSA9PiB7XG4gICAgY29uc3QgYWxwaGEgPSBwYXJ0aWNsZS5jb2xvci5hICogMC44O1xuICAgIFxuICAgIC8vIERyYXcgbWFpbiBwYXJ0aWNsZVxuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHguYXJjKHBhcnRpY2xlLngsIHBhcnRpY2xlLnksIHBhcnRpY2xlLnNpemUsIDAsIE1hdGguUEkgKiAyKTtcbiAgICBjdHguZmlsbFN0eWxlID0gYHJnYmEoJHtwYXJ0aWNsZS5jb2xvci5yfSwgJHtwYXJ0aWNsZS5jb2xvci5nfSwgJHtwYXJ0aWNsZS5jb2xvci5ifSwgJHthbHBoYX0pYDtcbiAgICBjdHguZmlsbCgpO1xuICAgIFxuICAgIC8vIERyYXcgZ2xvdyBlZmZlY3RcbiAgICBjb25zdCBncmFkaWVudCA9IGN0eC5jcmVhdGVSYWRpYWxHcmFkaWVudChcbiAgICAgIHBhcnRpY2xlLngsIHBhcnRpY2xlLnksIDAsXG4gICAgICBwYXJ0aWNsZS54LCBwYXJ0aWNsZS55LCBwYXJ0aWNsZS5zaXplICogM1xuICAgICk7XG4gICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKDAsIGByZ2JhKCR7cGFydGljbGUuY29sb3Iucn0sICR7cGFydGljbGUuY29sb3IuZ30sICR7cGFydGljbGUuY29sb3IuYn0sICR7YWxwaGEgKiAwLjN9KWApO1xuICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcCgxLCAncmdiYSgwLCAwLCAwLCAwKScpO1xuICAgIFxuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHguYXJjKHBhcnRpY2xlLngsIHBhcnRpY2xlLnksIHBhcnRpY2xlLnNpemUgKiAzLCAwLCBNYXRoLlBJICogMik7XG4gICAgY3R4LmZpbGxTdHlsZSA9IGdyYWRpZW50O1xuICAgIGN0eC5maWxsKCk7XG4gIH0pO1xuICBcbiAgLy8gRHJhdyBjb25uZWN0aW9ucyBiZXR3ZWVuIG5lYXJieSBwYXJ0aWNsZXNcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0aWNsZXMubGVuZ3RoOyBpKyspIHtcbiAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCBwYXJ0aWNsZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgIGNvbnN0IHAxID0gcGFydGljbGVzW2ldO1xuICAgICAgY29uc3QgcDIgPSBwYXJ0aWNsZXNbal07XG4gICAgICBjb25zdCBkaXN0ID0gTWF0aC5zcXJ0KChwMS54IC0gcDIueCkgKiogMiArIChwMS55IC0gcDIueSkgKiogMik7XG4gICAgICBcbiAgICAgIGlmIChkaXN0IDwgODApIHtcbiAgICAgICAgY29uc3QgYWxwaGEgPSAoMSAtIGRpc3QgLyA4MCkgKiAwLjIgKiBNYXRoLm1pbihwMS5jb2xvci5hLCBwMi5jb2xvci5hKTtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHgubW92ZVRvKHAxLngsIHAxLnkpO1xuICAgICAgICBjdHgubGluZVRvKHAyLngsIHAyLnkpO1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBgcmdiYSgyNTUsIDI1NSwgMjU1LCAke2FscGhhfSlgO1xuICAgICAgICBjdHgubGluZVdpZHRoID0gMC41O1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFuaW1hdGUoKSB7XG4gIHVwZGF0ZVBhcnRpY2xlcygpO1xuICBkcmF3UGFydGljbGVzKCk7XG4gIHJlcXVlc3RBbmltYXRpb25GcmFtZShhbmltYXRlKTtcbn1cblxuZnVuY3Rpb24gcmVzaXplQ2FudmFzKCkge1xuICBpZiAoIWNhbnZhcykgcmV0dXJuIGZhbHNlO1xuICBcbiAgY29uc3QgcmVjdCA9IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgY29uc3QgZHByID0gd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMTtcbiAgXG4gIGNhbnZhcy53aWR0aCA9IHJlY3Qud2lkdGggKiBkcHI7XG4gIGNhbnZhcy5oZWlnaHQgPSByZWN0LmhlaWdodCAqIGRwcjtcbiAgXG4gIGlmIChjdHgpIHtcbiAgICBjdHguc2NhbGUoZHByLCBkcHIpO1xuICB9XG4gIFxuICBjYW52YXMuc3R5bGUud2lkdGggPSByZWN0LndpZHRoICsgJ3B4JztcbiAgY2FudmFzLnN0eWxlLmhlaWdodCA9IHJlY3QuaGVpZ2h0ICsgJ3B4JztcbiAgXG4gIHJldHVybiB0cnVlO1xufVxuXG4vLyBFdmVudCBoYW5kbGVyc1xuZnVuY3Rpb24gYXR0YWNoRXZlbnRMaXN0ZW5lcnMoKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyB8fCAhY2FudmFzKSByZXR1cm47XG5cbiAgY29uc3QgYm9keSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2JvZHknKTtcbiAgaWYgKCFib2R5KSByZXR1cm47XG5cbiAgY29uc3QgbW91c2VNb3ZlSGFuZGxlciA9IChlOiBNb3VzZUV2ZW50KSA9PiB7XG4gICAgY29uc3QgcmVjdCA9IGNhbnZhcyEuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3QgbmV3TW91c2VYID0gZS5jbGllbnRYIC0gcmVjdC5sZWZ0O1xuICAgIGNvbnN0IG5ld01vdXNlWSA9IGUuY2xpZW50WSAtIHJlY3QudG9wO1xuICAgIFxuICAgIG1vdXNlVlggPSBuZXdNb3VzZVggLSBtb3VzZVg7XG4gICAgbW91c2VWWSA9IG5ld01vdXNlWSAtIG1vdXNlWTtcbiAgICBtb3VzZVggPSBuZXdNb3VzZVg7XG4gICAgbW91c2VZID0gbmV3TW91c2VZO1xuICB9O1xuXG4gIGNvbnN0IHRvdWNoTW92ZUhhbmRsZXIgPSAoZTogVG91Y2hFdmVudCkgPT4ge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBpZiAoZS50b3VjaGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IHJlY3QgPSBjYW52YXMhLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgY29uc3QgdG91Y2ggPSBlLnRvdWNoZXNbMF07XG4gICAgICBjb25zdCBuZXdNb3VzZVggPSB0b3VjaC5jbGllbnRYIC0gcmVjdC5sZWZ0O1xuICAgICAgY29uc3QgbmV3TW91c2VZID0gdG91Y2guY2xpZW50WSAtIHJlY3QudG9wO1xuICAgICAgXG4gICAgICBtb3VzZVZYID0gbmV3TW91c2VYIC0gbW91c2VYO1xuICAgICAgbW91c2VWWSA9IG5ld01vdXNlWSAtIG1vdXNlWTtcbiAgICAgIG1vdXNlWCA9IG5ld01vdXNlWDtcbiAgICAgIG1vdXNlWSA9IG5ld01vdXNlWTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgcmVzaXplSGFuZGxlciA9ICgpID0+IHtcbiAgICByZXNpemVDYW52YXMoKTtcbiAgfTtcblxuICBib2R5LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgbW91c2VNb3ZlSGFuZGxlcik7XG4gIGJvZHkuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCB0b3VjaE1vdmVIYW5kbGVyLCB7IHBhc3NpdmU6IGZhbHNlIH0pO1xuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCByZXNpemVIYW5kbGVyKTtcblxuICAvLyBTdG9yZSBoYW5kbGVycyBmb3IgY2xlYW51cFxuICAoY2FudmFzIGFzIGFueSkuX2V2ZW50SGFuZGxlcnMgPSB7XG4gICAgbW91c2VNb3ZlSGFuZGxlcixcbiAgICB0b3VjaE1vdmVIYW5kbGVyLFxuICAgIHJlc2l6ZUhhbmRsZXJcbiAgfTtcbn1cblxuLy8gTWFpbiBpbml0aWFsaXphdGlvbiBmdW5jdGlvblxuZXhwb3J0IGZ1bmN0aW9uIGluaXRGbHVpZFNpbXVsYXRpb24oKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuO1xuICBcbiAgaWYgKGZsdWlkSW5pdGlhbGl6ZWQpIHtcbiAgICBjb25zb2xlLmxvZygnRmx1aWQgYWxyZWFkeSBpbml0aWFsaXplZCcpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnNvbGUubG9nKCdJbml0aWFsaXppbmcgZmx1aWQgc2ltdWxhdGlvbi4uLicpO1xuXG4gIGNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZmx1aWRcIikgYXMgSFRNTENhbnZhc0VsZW1lbnQ7XG4gIFxuICBpZiAoIWNhbnZhcykge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0ZsdWlkIGNhbnZhcyBub3QgZm91bmQnKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgaWYgKCFjdHgpIHtcbiAgICBjb25zb2xlLmVycm9yKCdDb3VsZCBub3QgZ2V0IDJEIGNvbnRleHQnKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBTZXQgdXAgY2FudmFzXG4gIHJlc2l6ZUNhbnZhcygpO1xuICBcbiAgLy8gSW5pdGlhbGl6ZSBtb3VzZSBwb3NpdGlvblxuICBtb3VzZVggPSBjYW52YXMud2lkdGggLyAyO1xuICBtb3VzZVkgPSBjYW52YXMuaGVpZ2h0IC8gMjtcblxuICAvLyBBdHRhY2ggZXZlbnQgbGlzdGVuZXJzXG4gIGF0dGFjaEV2ZW50TGlzdGVuZXJzKCk7XG4gIFxuICAvLyBTdGFydCBhbmltYXRpb24gbG9vcFxuICBhbmltYXRlKCk7XG5cbiAgZmx1aWRJbml0aWFsaXplZCA9IHRydWU7XG4gIGNvbnNvbGUubG9nKCdGbHVpZCBzaW11bGF0aW9uIGluaXRpYWxpemVkIHN1Y2Nlc3NmdWxseSEnKTtcbn0iXSwibmFtZXMiOlsiZmx1aWRJbml0aWFsaXplZCIsImNhbnZhcyIsImN0eCIsInBhcnRpY2xlcyIsIm1vdXNlWCIsIm1vdXNlWSIsIm1vdXNlVlgiLCJtb3VzZVZZIiwibGFzdE1vdXNlWCIsImxhc3RNb3VzZVkiLCJjb25maWciLCJtYXhQYXJ0aWNsZXMiLCJwYXJ0aWNsZUxpZmUiLCJ0cmFpbExlbmd0aCIsIm1vdXNlSW5mbHVlbmNlIiwiY29sb3JWYXJpYXRpb24iLCJmYWRlU3BlZWQiLCJjcmVhdGVQYXJ0aWNsZSIsIngiLCJ5IiwidngiLCJ2eSIsInNwZWVkIiwiTWF0aCIsInNxcnQiLCJodWUiLCJEYXRlIiwibm93IiwicmFuZG9tIiwibGlmZSIsIm1heExpZmUiLCJzaXplIiwiY29sb3IiLCJoc3ZUb1JnYiIsImgiLCJzIiwidiIsImMiLCJhYnMiLCJtIiwiciIsImciLCJiIiwicm91bmQiLCJhIiwidXBkYXRlUGFydGljbGVzIiwiaSIsImxlbmd0aCIsInBhcnRpY2xlIiwic3BsaWNlIiwibW91c2VTcGVlZCIsIm51bU5ld1BhcnRpY2xlcyIsIm1pbiIsImZsb29yIiwicHVzaCIsImRyYXdQYXJ0aWNsZXMiLCJmaWxsU3R5bGUiLCJmaWxsUmVjdCIsIndpZHRoIiwiaGVpZ2h0IiwiZm9yRWFjaCIsImFscGhhIiwiYmVnaW5QYXRoIiwiYXJjIiwiUEkiLCJmaWxsIiwiZ3JhZGllbnQiLCJjcmVhdGVSYWRpYWxHcmFkaWVudCIsImFkZENvbG9yU3RvcCIsImoiLCJwMSIsInAyIiwiZGlzdCIsIm1vdmVUbyIsImxpbmVUbyIsInN0cm9rZVN0eWxlIiwibGluZVdpZHRoIiwic3Ryb2tlIiwiYW5pbWF0ZSIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsInJlc2l6ZUNhbnZhcyIsInJlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJkcHIiLCJ3aW5kb3ciLCJkZXZpY2VQaXhlbFJhdGlvIiwic2NhbGUiLCJzdHlsZSIsImF0dGFjaEV2ZW50TGlzdGVuZXJzIiwiYm9keSIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvciIsIm1vdXNlTW92ZUhhbmRsZXIiLCJlIiwibmV3TW91c2VYIiwiY2xpZW50WCIsImxlZnQiLCJuZXdNb3VzZVkiLCJjbGllbnRZIiwidG9wIiwidG91Y2hNb3ZlSGFuZGxlciIsInByZXZlbnREZWZhdWx0IiwidG91Y2hlcyIsInRvdWNoIiwicmVzaXplSGFuZGxlciIsImFkZEV2ZW50TGlzdGVuZXIiLCJwYXNzaXZlIiwiX2V2ZW50SGFuZGxlcnMiLCJpbml0Rmx1aWRTaW11bGF0aW9uIiwiY29uc29sZSIsImxvZyIsImdldEVsZW1lbnRCeUlkIiwiZXJyb3IiLCJnZXRDb250ZXh0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/lib/fluid.ts\n"));

/***/ })

});