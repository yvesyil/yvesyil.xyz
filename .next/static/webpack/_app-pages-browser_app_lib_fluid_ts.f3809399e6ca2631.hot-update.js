"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_app-pages-browser_app_lib_fluid_ts",{

/***/ "(app-pages-browser)/./app/lib/fluid.ts":
/*!**************************!*\
  !*** ./app/lib/fluid.ts ***!
  \**************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   initFluidSimulation: function() { return /* binding */ initFluidSimulation; }\n/* harmony export */ });\n// Proper WebGL Fluid Simulation for Next.js\n// Based on the original Astro implementation but adapted for React\nlet fluidInitialized = false;\nlet canvas = null;\nlet gl = null;\nlet ext;\n// Fluid simulation state\nlet config;\nlet pointers = [];\nlet dye, velocity;\nlet programs = {};\nlet framebuffers = [];\n// Timing\nlet lastUpdateTime = 0;\nlet startTime = 0;\nclass Pointer {\n    constructor(){\n        this.id = -1;\n        this.texcoordX = 0;\n        this.texcoordY = 0;\n        this.prevTexcoordX = 0;\n        this.prevTexcoordY = 0;\n        this.deltaX = 0;\n        this.deltaY = 0;\n        this.down = false;\n        this.moved = false;\n        this.color = {\n            r: 0.3,\n            g: 0.0,\n            b: 0.1\n        };\n    }\n}\n// Utility functions\nfunction scaleByPixelRatio(input) {\n    const pixelRatio = window.devicePixelRatio || 1;\n    return Math.floor(input * pixelRatio);\n}\nfunction generateColor() {\n    const c = HSVtoRGB(Math.random(), 0.8, 1.0);\n    return {\n        r: c.r * 0.4,\n        g: c.g * 0.05,\n        b: c.b * 0.2\n    };\n}\nfunction HSVtoRGB(h, s, v) {\n    let r, g, b;\n    const i = Math.floor(h * 6);\n    const f = h * 6 - i;\n    const p = v * (1 - s);\n    const q = v * (1 - f * s);\n    const t = v * (1 - (1 - f) * s);\n    switch(i % 6){\n        case 0:\n            r = v;\n            g = t;\n            b = p;\n            break;\n        case 1:\n            r = q;\n            g = v;\n            b = p;\n            break;\n        case 2:\n            r = p;\n            g = v;\n            b = t;\n            break;\n        case 3:\n            r = p;\n            g = q;\n            b = v;\n            break;\n        case 4:\n            r = t;\n            g = p;\n            b = v;\n            break;\n        case 5:\n            r = v;\n            g = p;\n            b = q;\n            break;\n        default:\n            r = g = b = 0;\n    }\n    return {\n        r,\n        g,\n        b\n    };\n}\n// WebGL setup\nfunction getWebGLContext(canvas) {\n    const params = {\n        alpha: true,\n        depth: false,\n        stencil: false,\n        antialias: false,\n        preserveDrawingBuffer: false\n    };\n    let gl = canvas.getContext(\"webgl2\", params);\n    const isWebGL2 = !!gl;\n    if (!isWebGL2) {\n        gl = canvas.getContext(\"webgl\", params);\n    }\n    if (!gl) return null;\n    gl.clearColor(0.0, 0.0, 0.0, 1.0);\n    return {\n        gl,\n        ext: {\n            formatRGBA: {\n                internalFormat: gl.RGBA,\n                format: gl.RGBA\n            },\n            halfFloatTexType: gl.HALF_FLOAT || 0x8D61,\n            supportLinearFiltering: true\n        }\n    };\n}\n// Shader creation\nfunction compileShader(type, source) {\n    if (!gl) return null;\n    const shader = gl.createShader(type);\n    if (!shader) return null;\n    gl.shaderSource(shader, source);\n    gl.compileShader(shader);\n    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n        console.error(\"Shader compile error:\", gl.getShaderInfoLog(shader));\n        gl.deleteShader(shader);\n        return null;\n    }\n    return shader;\n}\nfunction createProgram(vertexShader, fragmentShader) {\n    if (!gl) return null;\n    const program = gl.createProgram();\n    if (!program) return null;\n    gl.attachShader(program, vertexShader);\n    gl.attachShader(program, fragmentShader);\n    gl.linkProgram(program);\n    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n        console.error(\"Program link error:\", gl.getProgramInfoLog(program));\n        return null;\n    }\n    return program;\n}\n// Simple shaders for fluid effect\nconst vertexShaderSource = \"\\n  attribute vec2 aPosition;\\n  varying vec2 vUv;\\n  void main () {\\n    vUv = aPosition * 0.5 + 0.5;\\n    gl_Position = vec4(aPosition, 0.0, 1.0);\\n  }\\n\";\nconst fragmentShaderSource = \"\\n  precision mediump float;\\n  varying vec2 vUv;\\n  uniform sampler2D uTexture;\\n  uniform vec2 texelSize;\\n  uniform vec3 color;\\n  uniform vec2 point;\\n  uniform float radius;\\n  uniform float aspectRatio;\\n  uniform float time;\\n  \\n  void main () {\\n    vec2 p = vUv - point.xy;\\n    p.x *= aspectRatio;\\n    \\n    float dist = length(p);\\n    float splat = exp(-dist / radius);\\n    \\n    vec3 base = texture2D(uTexture, vUv).xyz;\\n    vec3 splatColor = color * splat;\\n    \\n    // Add some noise for grain effect\\n    float noise = fract(sin(dot(vUv.xy + time, vec2(12.9898,78.233))) * 43758.5453);\\n    base += (noise - 0.5) * 0.02;\\n    \\n    gl_FragColor = vec4(base + splatColor, 1.0);\\n  }\\n\";\nconst displayShaderSource = \"\\n  precision mediump float;\\n  varying vec2 vUv;\\n  uniform sampler2D uTexture;\\n  uniform float time;\\n  \\n  void main () {\\n    vec3 color = texture2D(uTexture, vUv).xyz;\\n    \\n    // Add film grain\\n    float noise = fract(sin(dot(vUv.xy + time * 0.1, vec2(12.9898,78.233))) * 43758.5453);\\n    color += (noise - 0.5) * 0.03;\\n    \\n    // Fade effect\\n    color *= 0.995;\\n    \\n    gl_FragColor = vec4(color, 1.0);\\n  }\\n\";\n// Create framebuffer\nfunction createFBO(w, h) {\n    if (!gl) return null;\n    gl.activeTexture(gl.TEXTURE0);\n    const texture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, w, h, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n    const fbo = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n    gl.viewport(0, 0, w, h);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n    return {\n        texture,\n        fbo,\n        width: w,\n        height: h,\n        attach (id) {\n            gl.activeTexture(gl.TEXTURE0 + id);\n            gl.bindTexture(gl.TEXTURE_2D, texture);\n            return id;\n        }\n    };\n}\n// Blit setup\nlet blit;\nfunction setupBlit() {\n    if (!gl) return;\n    gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([\n        -1,\n        -1,\n        -1,\n        1,\n        1,\n        1,\n        1,\n        -1\n    ]), gl.STATIC_DRAW);\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gl.createBuffer());\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array([\n        0,\n        1,\n        2,\n        0,\n        2,\n        3\n    ]), gl.STATIC_DRAW);\n    gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);\n    gl.enableVertexAttribArray(0);\n    blit = (target)=>{\n        if (!gl) return;\n        if (target == null) {\n            gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\n            gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n        } else {\n            gl.viewport(0, 0, target.width, target.height);\n            gl.bindFramebuffer(gl.FRAMEBUFFER, target.fbo);\n        }\n        gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);\n    };\n}\n// Main render loop\nfunction render() {\n    if (!gl || !canvas) return;\n    const dt = calcDeltaTime();\n    if (resizeCanvas()) initFramebuffers();\n    applyInputs();\n    step(dt);\n    requestAnimationFrame(render);\n}\nfunction calcDeltaTime() {\n    const now = Date.now();\n    let dt = (now - lastUpdateTime) / 1000;\n    dt = Math.min(dt, 0.016666);\n    lastUpdateTime = now;\n    return dt;\n}\nfunction applyInputs() {\n    pointers.forEach((pointer)=>{\n        if (pointer.moved) {\n            pointer.moved = false;\n            splatPointer(pointer);\n        }\n    });\n}\nfunction splatPointer(pointer) {\n    const dx = pointer.deltaX * config.SPLAT_FORCE;\n    const dy = pointer.deltaY * config.SPLAT_FORCE;\n    splat(pointer.texcoordX, pointer.texcoordY, dx, dy, pointer.color);\n}\nfunction splat(x, y, dx, dy, color) {\n    if (!gl || !programs.splat || !dye) return;\n    gl.useProgram(programs.splat);\n    gl.uniform1i(gl.getUniformLocation(programs.splat, \"uTexture\"), dye.read.attach(0));\n    gl.uniform1f(gl.getUniformLocation(programs.splat, \"aspectRatio\"), canvas.width / canvas.height);\n    gl.uniform2f(gl.getUniformLocation(programs.splat, \"point\"), x, y);\n    gl.uniform3f(gl.getUniformLocation(programs.splat, \"color\"), color.r, color.g, color.b);\n    gl.uniform1f(gl.getUniformLocation(programs.splat, \"radius\"), config.SPLAT_RADIUS);\n    gl.uniform1f(gl.getUniformLocation(programs.splat, \"time\"), (Date.now() - startTime) / 1000);\n    blit(dye.write);\n    dye.swap();\n}\nfunction step(dt) {\n    if (!gl || !programs.display || !dye) return;\n    // Simple display with fade\n    gl.useProgram(programs.display);\n    gl.uniform1i(gl.getUniformLocation(programs.display, \"uTexture\"), dye.read.attach(0));\n    gl.uniform1f(gl.getUniformLocation(programs.display, \"time\"), (Date.now() - startTime) / 1000);\n    blit(null);\n}\nfunction resizeCanvas() {\n    if (!canvas) return false;\n    const width = scaleByPixelRatio(canvas.clientWidth);\n    const height = scaleByPixelRatio(canvas.clientHeight);\n    if (canvas.width !== width || canvas.height !== height) {\n        canvas.width = width;\n        canvas.height = height;\n        return true;\n    }\n    return false;\n}\nfunction initFramebuffers() {\n    if (!gl) return;\n    const simRes = {\n        width: 512,\n        height: 512\n    };\n    dye = {\n        read: createFBO(simRes.width, simRes.height),\n        write: createFBO(simRes.width, simRes.height),\n        swap () {\n            const temp = this.read;\n            this.read = this.write;\n            this.write = temp;\n        }\n    };\n}\n// Event handlers\nfunction updatePointerMoveData(pointer, posX, posY) {\n    if (!canvas) return;\n    pointer.prevTexcoordX = pointer.texcoordX;\n    pointer.prevTexcoordY = pointer.texcoordY;\n    pointer.texcoordX = posX / canvas.width;\n    pointer.texcoordY = 1.0 - posY / canvas.height;\n    pointer.deltaX = pointer.texcoordX - pointer.prevTexcoordX;\n    pointer.deltaY = pointer.texcoordY - pointer.prevTexcoordY;\n    pointer.moved = Math.abs(pointer.deltaX) > 0 || Math.abs(pointer.deltaY) > 0;\n}\nfunction attachEventListeners() {\n    if ( false || !canvas) return;\n    const body = document.querySelector(\"body\");\n    if (!body) return;\n    const mouseMoveHandler = (e)=>{\n        if (!pointers[0]) return;\n        const pointer = pointers[0];\n        const posX = scaleByPixelRatio(e.clientX);\n        const posY = scaleByPixelRatio(e.clientY);\n        updatePointerMoveData(pointer, posX, posY);\n    };\n    const touchMoveHandler = (e)=>{\n        e.preventDefault();\n        if (e.touches.length > 0 && pointers[0]) {\n            const touch = e.touches[0];\n            const posX = scaleByPixelRatio(touch.clientX);\n            const posY = scaleByPixelRatio(touch.clientY);\n            updatePointerMoveData(pointers[0], posX, posY);\n        }\n    };\n    body.addEventListener(\"mousemove\", mouseMoveHandler);\n    body.addEventListener(\"touchmove\", touchMoveHandler, {\n        passive: false\n    });\n}\n// Main initialization\nfunction initFluidSimulation() {\n    if (false) {}\n    if (fluidInitialized) {\n        console.log(\"Fluid already initialized\");\n        attachEventListeners();\n        return;\n    }\n    console.log(\"Initializing WebGL fluid simulation...\");\n    canvas = document.getElementById(\"fluid\");\n    if (!canvas) {\n        console.error(\"Fluid canvas not found\");\n        return;\n    }\n    const webglContext = getWebGLContext(canvas);\n    if (!webglContext) {\n        console.error(\"Failed to get WebGL context\");\n        return;\n    }\n    gl = webglContext.gl;\n    ext = webglContext.ext;\n    // Configuration\n    config = {\n        SPLAT_RADIUS: 0.25,\n        SPLAT_FORCE: 6000,\n        DENSITY_DISSIPATION: 1,\n        VELOCITY_DISSIPATION: 0.2,\n        PRESSURE: 0.8,\n        CURL: 30,\n        COLOR_UPDATE_SPEED: 10\n    };\n    // Create shaders\n    const vertexShader = compileShader(gl.VERTEX_SHADER, vertexShaderSource);\n    const fragmentShader = compileShader(gl.FRAGMENT_SHADER, fragmentShaderSource);\n    const displayFragmentShader = compileShader(gl.FRAGMENT_SHADER, displayShaderSource);\n    if (!vertexShader || !fragmentShader || !displayFragmentShader) {\n        console.error(\"Failed to compile shaders\");\n        return;\n    }\n    programs.splat = createProgram(vertexShader, fragmentShader);\n    programs.display = createProgram(vertexShader, displayFragmentShader);\n    if (!programs.splat || !programs.display) {\n        console.error(\"Failed to create programs\");\n        return;\n    }\n    // Setup\n    setupBlit();\n    initFramebuffers();\n    // Initialize pointer\n    pointers = [\n        new Pointer()\n    ];\n    pointers[0].color = generateColor();\n    // Timing\n    lastUpdateTime = Date.now();\n    startTime = Date.now();\n    // Event listeners\n    attachEventListeners();\n    // Start render loop\n    render();\n    fluidInitialized = true;\n    console.log(\"WebGL fluid simulation initialized successfully!\");\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Y0MsY0FBY0M7SUFDN0NwRSxTQUFTNEosT0FBTyxHQUFHMUYsY0FBY0MsY0FBYzRIO0lBRS9DLElBQUksQ0FBQy9MLFNBQVMrSSxLQUFLLElBQUksQ0FBQy9JLFNBQVM0SixPQUFPLEVBQUU7UUFDeEM5RixRQUFRQyxLQUFLLENBQUM7UUFDZDtJQUNGO0lBRUEsUUFBUTtJQUNSNkM7SUFDQXNCO0lBRUEscUJBQXFCO0lBQ3JCckksV0FBVztRQUFDLElBQUlPO0tBQVU7SUFDMUJQLFFBQVEsQ0FBQyxFQUFFLENBQUNpQixLQUFLLEdBQUdXO0lBRXBCLFNBQVM7SUFDVHZCLGlCQUFpQnFJLEtBQUtELEdBQUc7SUFDekJuSSxZQUFZb0ksS0FBS0QsR0FBRztJQUVwQixrQkFBa0I7SUFDbEIrQjtJQUVBLG9CQUFvQjtJQUNwQnZDO0lBRUF0SSxtQkFBbUI7SUFDbkJzRSxRQUFRdUgsR0FBRyxDQUFDO0FBQ2QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vYXBwL2xpYi9mbHVpZC50cz9mYjNkIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFByb3BlciBXZWJHTCBGbHVpZCBTaW11bGF0aW9uIGZvciBOZXh0LmpzXG4vLyBCYXNlZCBvbiB0aGUgb3JpZ2luYWwgQXN0cm8gaW1wbGVtZW50YXRpb24gYnV0IGFkYXB0ZWQgZm9yIFJlYWN0XG5cbmxldCBmbHVpZEluaXRpYWxpemVkID0gZmFsc2U7XG5sZXQgY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCB8IG51bGwgPSBudWxsO1xubGV0IGdsOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQgfCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0IHwgbnVsbCA9IG51bGw7XG5sZXQgZXh0OiBhbnk7XG5cbi8vIEZsdWlkIHNpbXVsYXRpb24gc3RhdGVcbmxldCBjb25maWc6IGFueTtcbmxldCBwb2ludGVyczogYW55W10gPSBbXTtcbmxldCBkeWU6IGFueSwgdmVsb2NpdHk6IGFueTtcbmxldCBwcm9ncmFtczogYW55ID0ge307XG5sZXQgZnJhbWVidWZmZXJzOiBhbnlbXSA9IFtdO1xuXG4vLyBUaW1pbmdcbmxldCBsYXN0VXBkYXRlVGltZSA9IDA7XG5sZXQgc3RhcnRUaW1lID0gMDtcblxuY2xhc3MgUG9pbnRlciB7XG4gIGlkID0gLTE7XG4gIHRleGNvb3JkWCA9IDA7XG4gIHRleGNvb3JkWSA9IDA7XG4gIHByZXZUZXhjb29yZFggPSAwO1xuICBwcmV2VGV4Y29vcmRZID0gMDtcbiAgZGVsdGFYID0gMDtcbiAgZGVsdGFZID0gMDtcbiAgZG93biA9IGZhbHNlO1xuICBtb3ZlZCA9IGZhbHNlO1xuICBjb2xvciA9IHsgcjogMC4zLCBnOiAwLjAsIGI6IDAuMSB9O1xufVxuXG4vLyBVdGlsaXR5IGZ1bmN0aW9uc1xuZnVuY3Rpb24gc2NhbGVCeVBpeGVsUmF0aW8oaW5wdXQ6IG51bWJlcik6IG51bWJlciB7XG4gIGNvbnN0IHBpeGVsUmF0aW8gPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xuICByZXR1cm4gTWF0aC5mbG9vcihpbnB1dCAqIHBpeGVsUmF0aW8pO1xufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZUNvbG9yKCkge1xuICBjb25zdCBjID0gSFNWdG9SR0IoTWF0aC5yYW5kb20oKSwgMC44LCAxLjApO1xuICByZXR1cm4ge1xuICAgIHI6IGMuciAqIDAuNCxcbiAgICBnOiBjLmcgKiAwLjA1LFxuICAgIGI6IGMuYiAqIDAuMlxuICB9O1xufVxuXG5mdW5jdGlvbiBIU1Z0b1JHQihoOiBudW1iZXIsIHM6IG51bWJlciwgdjogbnVtYmVyKSB7XG4gIGxldCByOiBudW1iZXIsIGc6IG51bWJlciwgYjogbnVtYmVyO1xuICBjb25zdCBpID0gTWF0aC5mbG9vcihoICogNik7XG4gIGNvbnN0IGYgPSBoICogNiAtIGk7XG4gIGNvbnN0IHAgPSB2ICogKDEgLSBzKTtcbiAgY29uc3QgcSA9IHYgKiAoMSAtIGYgKiBzKTtcbiAgY29uc3QgdCA9IHYgKiAoMSAtICgxIC0gZikgKiBzKTtcblxuICBzd2l0Y2ggKGkgJSA2KSB7XG4gICAgY2FzZSAwOiByID0gdjsgZyA9IHQ7IGIgPSBwOyBicmVhaztcbiAgICBjYXNlIDE6IHIgPSBxOyBnID0gdjsgYiA9IHA7IGJyZWFrO1xuICAgIGNhc2UgMjogciA9IHA7IGcgPSB2OyBiID0gdDsgYnJlYWs7XG4gICAgY2FzZSAzOiByID0gcDsgZyA9IHE7IGIgPSB2OyBicmVhaztcbiAgICBjYXNlIDQ6IHIgPSB0OyBnID0gcDsgYiA9IHY7IGJyZWFrO1xuICAgIGNhc2UgNTogciA9IHY7IGcgPSBwOyBiID0gcTsgYnJlYWs7XG4gICAgZGVmYXVsdDogciA9IGcgPSBiID0gMDtcbiAgfVxuXG4gIHJldHVybiB7IHIsIGcsIGIgfTtcbn1cblxuLy8gV2ViR0wgc2V0dXBcbmZ1bmN0aW9uIGdldFdlYkdMQ29udGV4dChjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KSB7XG4gIGNvbnN0IHBhcmFtcyA9IHtcbiAgICBhbHBoYTogdHJ1ZSxcbiAgICBkZXB0aDogZmFsc2UsXG4gICAgc3RlbmNpbDogZmFsc2UsXG4gICAgYW50aWFsaWFzOiBmYWxzZSxcbiAgICBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IGZhbHNlXG4gIH07XG5cbiAgbGV0IGdsID0gY2FudmFzLmdldENvbnRleHQoXCJ3ZWJnbDJcIiwgcGFyYW1zKSBhcyBXZWJHTDJSZW5kZXJpbmdDb250ZXh0O1xuICBjb25zdCBpc1dlYkdMMiA9ICEhZ2w7XG4gIFxuICBpZiAoIWlzV2ViR0wyKSB7XG4gICAgZ2wgPSBjYW52YXMuZ2V0Q29udGV4dChcIndlYmdsXCIsIHBhcmFtcykgYXMgV2ViR0wyUmVuZGVyaW5nQ29udGV4dDtcbiAgfVxuXG4gIGlmICghZ2wpIHJldHVybiBudWxsO1xuXG4gIGdsLmNsZWFyQ29sb3IoMC4wLCAwLjAsIDAuMCwgMS4wKTtcbiAgXG4gIHJldHVybiB7XG4gICAgZ2wsXG4gICAgZXh0OiB7XG4gICAgICBmb3JtYXRSR0JBOiB7IGludGVybmFsRm9ybWF0OiBnbC5SR0JBLCBmb3JtYXQ6IGdsLlJHQkEgfSxcbiAgICAgIGhhbGZGbG9hdFRleFR5cGU6IGdsLkhBTEZfRkxPQVQgfHwgMHg4RDYxLFxuICAgICAgc3VwcG9ydExpbmVhckZpbHRlcmluZzogdHJ1ZVxuICAgIH1cbiAgfTtcbn1cblxuLy8gU2hhZGVyIGNyZWF0aW9uXG5mdW5jdGlvbiBjb21waWxlU2hhZGVyKHR5cGU6IG51bWJlciwgc291cmNlOiBzdHJpbmcpOiBXZWJHTFNoYWRlciB8IG51bGwge1xuICBpZiAoIWdsKSByZXR1cm4gbnVsbDtcbiAgXG4gIGNvbnN0IHNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlcih0eXBlKTtcbiAgaWYgKCFzaGFkZXIpIHJldHVybiBudWxsO1xuICBcbiAgZ2wuc2hhZGVyU291cmNlKHNoYWRlciwgc291cmNlKTtcbiAgZ2wuY29tcGlsZVNoYWRlcihzaGFkZXIpO1xuXG4gIGlmICghZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpKSB7XG4gICAgY29uc29sZS5lcnJvcignU2hhZGVyIGNvbXBpbGUgZXJyb3I6JywgZ2wuZ2V0U2hhZGVySW5mb0xvZyhzaGFkZXIpKTtcbiAgICBnbC5kZWxldGVTaGFkZXIoc2hhZGVyKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBzaGFkZXI7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVByb2dyYW0odmVydGV4U2hhZGVyOiBXZWJHTFNoYWRlciwgZnJhZ21lbnRTaGFkZXI6IFdlYkdMU2hhZGVyKTogV2ViR0xQcm9ncmFtIHwgbnVsbCB7XG4gIGlmICghZ2wpIHJldHVybiBudWxsO1xuICBcbiAgY29uc3QgcHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKTtcbiAgaWYgKCFwcm9ncmFtKSByZXR1cm4gbnVsbDtcbiAgXG4gIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCB2ZXJ0ZXhTaGFkZXIpO1xuICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgZnJhZ21lbnRTaGFkZXIpO1xuICBnbC5saW5rUHJvZ3JhbShwcm9ncmFtKTtcblxuICBpZiAoIWdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgZ2wuTElOS19TVEFUVVMpKSB7XG4gICAgY29uc29sZS5lcnJvcignUHJvZ3JhbSBsaW5rIGVycm9yOicsIGdsLmdldFByb2dyYW1JbmZvTG9nKHByb2dyYW0pKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBwcm9ncmFtO1xufVxuXG4vLyBTaW1wbGUgc2hhZGVycyBmb3IgZmx1aWQgZWZmZWN0XG5jb25zdCB2ZXJ0ZXhTaGFkZXJTb3VyY2UgPSBgXG4gIGF0dHJpYnV0ZSB2ZWMyIGFQb3NpdGlvbjtcbiAgdmFyeWluZyB2ZWMyIHZVdjtcbiAgdm9pZCBtYWluICgpIHtcbiAgICB2VXYgPSBhUG9zaXRpb24gKiAwLjUgKyAwLjU7XG4gICAgZ2xfUG9zaXRpb24gPSB2ZWM0KGFQb3NpdGlvbiwgMC4wLCAxLjApO1xuICB9XG5gO1xuXG5jb25zdCBmcmFnbWVudFNoYWRlclNvdXJjZSA9IGBcbiAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XG4gIHZhcnlpbmcgdmVjMiB2VXY7XG4gIHVuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xuICB1bmlmb3JtIHZlYzIgdGV4ZWxTaXplO1xuICB1bmlmb3JtIHZlYzMgY29sb3I7XG4gIHVuaWZvcm0gdmVjMiBwb2ludDtcbiAgdW5pZm9ybSBmbG9hdCByYWRpdXM7XG4gIHVuaWZvcm0gZmxvYXQgYXNwZWN0UmF0aW87XG4gIHVuaWZvcm0gZmxvYXQgdGltZTtcbiAgXG4gIHZvaWQgbWFpbiAoKSB7XG4gICAgdmVjMiBwID0gdlV2IC0gcG9pbnQueHk7XG4gICAgcC54ICo9IGFzcGVjdFJhdGlvO1xuICAgIFxuICAgIGZsb2F0IGRpc3QgPSBsZW5ndGgocCk7XG4gICAgZmxvYXQgc3BsYXQgPSBleHAoLWRpc3QgLyByYWRpdXMpO1xuICAgIFxuICAgIHZlYzMgYmFzZSA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlV2KS54eXo7XG4gICAgdmVjMyBzcGxhdENvbG9yID0gY29sb3IgKiBzcGxhdDtcbiAgICBcbiAgICAvLyBBZGQgc29tZSBub2lzZSBmb3IgZ3JhaW4gZWZmZWN0XG4gICAgZmxvYXQgbm9pc2UgPSBmcmFjdChzaW4oZG90KHZVdi54eSArIHRpbWUsIHZlYzIoMTIuOTg5OCw3OC4yMzMpKSkgKiA0Mzc1OC41NDUzKTtcbiAgICBiYXNlICs9IChub2lzZSAtIDAuNSkgKiAwLjAyO1xuICAgIFxuICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoYmFzZSArIHNwbGF0Q29sb3IsIDEuMCk7XG4gIH1cbmA7XG5cbmNvbnN0IGRpc3BsYXlTaGFkZXJTb3VyY2UgPSBgXG4gIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xuICB2YXJ5aW5nIHZlYzIgdlV2O1xuICB1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcbiAgdW5pZm9ybSBmbG9hdCB0aW1lO1xuICBcbiAgdm9pZCBtYWluICgpIHtcbiAgICB2ZWMzIGNvbG9yID0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VXYpLnh5ejtcbiAgICBcbiAgICAvLyBBZGQgZmlsbSBncmFpblxuICAgIGZsb2F0IG5vaXNlID0gZnJhY3Qoc2luKGRvdCh2VXYueHkgKyB0aW1lICogMC4xLCB2ZWMyKDEyLjk4OTgsNzguMjMzKSkpICogNDM3NTguNTQ1Myk7XG4gICAgY29sb3IgKz0gKG5vaXNlIC0gMC41KSAqIDAuMDM7XG4gICAgXG4gICAgLy8gRmFkZSBlZmZlY3RcbiAgICBjb2xvciAqPSAwLjk5NTtcbiAgICBcbiAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KGNvbG9yLCAxLjApO1xuICB9XG5gO1xuXG4vLyBDcmVhdGUgZnJhbWVidWZmZXJcbmZ1bmN0aW9uIGNyZWF0ZUZCTyh3OiBudW1iZXIsIGg6IG51bWJlcik6IGFueSB7XG4gIGlmICghZ2wpIHJldHVybiBudWxsO1xuICBcbiAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCk7XG4gIGNvbnN0IHRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG4gIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpO1xuICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTElORUFSKTtcbiAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLkxJTkVBUik7XG4gIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpO1xuICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTtcbiAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCB3LCBoLCAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBudWxsKTtcblxuICBjb25zdCBmYm8gPSBnbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xuICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGZibyk7XG4gIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCwgZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSwgMCk7XG4gIGdsLnZpZXdwb3J0KDAsIDAsIHcsIGgpO1xuICBnbC5jbGVhcihnbC5DT0xPUl9CVUZGRVJfQklUKTtcblxuICByZXR1cm4ge1xuICAgIHRleHR1cmUsXG4gICAgZmJvLFxuICAgIHdpZHRoOiB3LFxuICAgIGhlaWdodDogaCxcbiAgICBhdHRhY2goaWQ6IG51bWJlcikge1xuICAgICAgZ2whLmFjdGl2ZVRleHR1cmUoZ2whLlRFWFRVUkUwICsgaWQpO1xuICAgICAgZ2whLmJpbmRUZXh0dXJlKGdsIS5URVhUVVJFXzJELCB0ZXh0dXJlKTtcbiAgICAgIHJldHVybiBpZDtcbiAgICB9XG4gIH07XG59XG5cbi8vIEJsaXQgc2V0dXBcbmxldCBibGl0OiBhbnk7XG5mdW5jdGlvbiBzZXR1cEJsaXQoKSB7XG4gIGlmICghZ2wpIHJldHVybjtcbiAgXG4gIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBnbC5jcmVhdGVCdWZmZXIoKSk7XG4gIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBuZXcgRmxvYXQzMkFycmF5KFstMSwgLTEsIC0xLCAxLCAxLCAxLCAxLCAtMV0pLCBnbC5TVEFUSUNfRFJBVyk7XG4gIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGdsLmNyZWF0ZUJ1ZmZlcigpKTtcbiAgZ2wuYnVmZmVyRGF0YShnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgbmV3IFVpbnQxNkFycmF5KFswLCAxLCAyLCAwLCAyLCAzXSksIGdsLlNUQVRJQ19EUkFXKTtcbiAgZ2wudmVydGV4QXR0cmliUG9pbnRlcigwLCAyLCBnbC5GTE9BVCwgZmFsc2UsIDAsIDApO1xuICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSgwKTtcblxuICBibGl0ID0gKHRhcmdldDogYW55KSA9PiB7XG4gICAgaWYgKCFnbCkgcmV0dXJuO1xuICAgIFxuICAgIGlmICh0YXJnZXQgPT0gbnVsbCkge1xuICAgICAgZ2wudmlld3BvcnQoMCwgMCwgZ2wuZHJhd2luZ0J1ZmZlcldpZHRoLCBnbC5kcmF3aW5nQnVmZmVySGVpZ2h0KTtcbiAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgbnVsbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdsLnZpZXdwb3J0KDAsIDAsIHRhcmdldC53aWR0aCwgdGFyZ2V0LmhlaWdodCk7XG4gICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIHRhcmdldC5mYm8pO1xuICAgIH1cbiAgICBnbC5kcmF3RWxlbWVudHMoZ2wuVFJJQU5HTEVTLCA2LCBnbC5VTlNJR05FRF9TSE9SVCwgMCk7XG4gIH07XG59XG5cbi8vIE1haW4gcmVuZGVyIGxvb3BcbmZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgaWYgKCFnbCB8fCAhY2FudmFzKSByZXR1cm47XG4gIFxuICBjb25zdCBkdCA9IGNhbGNEZWx0YVRpbWUoKTtcbiAgaWYgKHJlc2l6ZUNhbnZhcygpKSBpbml0RnJhbWVidWZmZXJzKCk7XG4gIFxuICBhcHBseUlucHV0cygpO1xuICBzdGVwKGR0KTtcbiAgXG4gIHJlcXVlc3RBbmltYXRpb25GcmFtZShyZW5kZXIpO1xufVxuXG5mdW5jdGlvbiBjYWxjRGVsdGFUaW1lKCk6IG51bWJlciB7XG4gIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gIGxldCBkdCA9IChub3cgLSBsYXN0VXBkYXRlVGltZSkgLyAxMDAwO1xuICBkdCA9IE1hdGgubWluKGR0LCAwLjAxNjY2Nik7XG4gIGxhc3RVcGRhdGVUaW1lID0gbm93O1xuICByZXR1cm4gZHQ7XG59XG5cbmZ1bmN0aW9uIGFwcGx5SW5wdXRzKCkge1xuICBwb2ludGVycy5mb3JFYWNoKChwb2ludGVyKSA9PiB7XG4gICAgaWYgKHBvaW50ZXIubW92ZWQpIHtcbiAgICAgIHBvaW50ZXIubW92ZWQgPSBmYWxzZTtcbiAgICAgIHNwbGF0UG9pbnRlcihwb2ludGVyKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBzcGxhdFBvaW50ZXIocG9pbnRlcjogYW55KSB7XG4gIGNvbnN0IGR4ID0gcG9pbnRlci5kZWx0YVggKiBjb25maWcuU1BMQVRfRk9SQ0U7XG4gIGNvbnN0IGR5ID0gcG9pbnRlci5kZWx0YVkgKiBjb25maWcuU1BMQVRfRk9SQ0U7XG4gIHNwbGF0KHBvaW50ZXIudGV4Y29vcmRYLCBwb2ludGVyLnRleGNvb3JkWSwgZHgsIGR5LCBwb2ludGVyLmNvbG9yKTtcbn1cblxuZnVuY3Rpb24gc3BsYXQoeDogbnVtYmVyLCB5OiBudW1iZXIsIGR4OiBudW1iZXIsIGR5OiBudW1iZXIsIGNvbG9yOiBhbnkpIHtcbiAgaWYgKCFnbCB8fCAhcHJvZ3JhbXMuc3BsYXQgfHwgIWR5ZSkgcmV0dXJuO1xuICBcbiAgZ2wudXNlUHJvZ3JhbShwcm9ncmFtcy5zcGxhdCk7XG4gIGdsLnVuaWZvcm0xaShnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbXMuc3BsYXQsICd1VGV4dHVyZScpLCBkeWUucmVhZC5hdHRhY2goMCkpO1xuICBnbC51bmlmb3JtMWYoZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW1zLnNwbGF0LCAnYXNwZWN0UmF0aW8nKSwgY2FudmFzIS53aWR0aCAvIGNhbnZhcyEuaGVpZ2h0KTtcbiAgZ2wudW5pZm9ybTJmKGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtcy5zcGxhdCwgJ3BvaW50JyksIHgsIHkpO1xuICBnbC51bmlmb3JtM2YoZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW1zLnNwbGF0LCAnY29sb3InKSwgY29sb3IuciwgY29sb3IuZywgY29sb3IuYik7XG4gIGdsLnVuaWZvcm0xZihnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbXMuc3BsYXQsICdyYWRpdXMnKSwgY29uZmlnLlNQTEFUX1JBRElVUyk7XG4gIGdsLnVuaWZvcm0xZihnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbXMuc3BsYXQsICd0aW1lJyksIChEYXRlLm5vdygpIC0gc3RhcnRUaW1lKSAvIDEwMDApO1xuICBibGl0KGR5ZS53cml0ZSk7XG4gIGR5ZS5zd2FwKCk7XG59XG5cbmZ1bmN0aW9uIHN0ZXAoZHQ6IG51bWJlcikge1xuICBpZiAoIWdsIHx8ICFwcm9ncmFtcy5kaXNwbGF5IHx8ICFkeWUpIHJldHVybjtcbiAgXG4gIC8vIFNpbXBsZSBkaXNwbGF5IHdpdGggZmFkZVxuICBnbC51c2VQcm9ncmFtKHByb2dyYW1zLmRpc3BsYXkpO1xuICBnbC51bmlmb3JtMWkoZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW1zLmRpc3BsYXksICd1VGV4dHVyZScpLCBkeWUucmVhZC5hdHRhY2goMCkpO1xuICBnbC51bmlmb3JtMWYoZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW1zLmRpc3BsYXksICd0aW1lJyksIChEYXRlLm5vdygpIC0gc3RhcnRUaW1lKSAvIDEwMDApO1xuICBibGl0KG51bGwpO1xufVxuXG5mdW5jdGlvbiByZXNpemVDYW52YXMoKTogYm9vbGVhbiB7XG4gIGlmICghY2FudmFzKSByZXR1cm4gZmFsc2U7XG4gIFxuICBjb25zdCB3aWR0aCA9IHNjYWxlQnlQaXhlbFJhdGlvKGNhbnZhcy5jbGllbnRXaWR0aCk7XG4gIGNvbnN0IGhlaWdodCA9IHNjYWxlQnlQaXhlbFJhdGlvKGNhbnZhcy5jbGllbnRIZWlnaHQpO1xuICBcbiAgaWYgKGNhbnZhcy53aWR0aCAhPT0gd2lkdGggfHwgY2FudmFzLmhlaWdodCAhPT0gaGVpZ2h0KSB7XG4gICAgY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGluaXRGcmFtZWJ1ZmZlcnMoKSB7XG4gIGlmICghZ2wpIHJldHVybjtcbiAgXG4gIGNvbnN0IHNpbVJlcyA9IHsgd2lkdGg6IDUxMiwgaGVpZ2h0OiA1MTIgfTtcbiAgXG4gIGR5ZSA9IHtcbiAgICByZWFkOiBjcmVhdGVGQk8oc2ltUmVzLndpZHRoLCBzaW1SZXMuaGVpZ2h0KSxcbiAgICB3cml0ZTogY3JlYXRlRkJPKHNpbVJlcy53aWR0aCwgc2ltUmVzLmhlaWdodCksXG4gICAgc3dhcCgpIHtcbiAgICAgIGNvbnN0IHRlbXAgPSB0aGlzLnJlYWQ7XG4gICAgICB0aGlzLnJlYWQgPSB0aGlzLndyaXRlO1xuICAgICAgdGhpcy53cml0ZSA9IHRlbXA7XG4gICAgfVxuICB9O1xufVxuXG4vLyBFdmVudCBoYW5kbGVyc1xuZnVuY3Rpb24gdXBkYXRlUG9pbnRlck1vdmVEYXRhKHBvaW50ZXI6IGFueSwgcG9zWDogbnVtYmVyLCBwb3NZOiBudW1iZXIpIHtcbiAgaWYgKCFjYW52YXMpIHJldHVybjtcbiAgXG4gIHBvaW50ZXIucHJldlRleGNvb3JkWCA9IHBvaW50ZXIudGV4Y29vcmRYO1xuICBwb2ludGVyLnByZXZUZXhjb29yZFkgPSBwb2ludGVyLnRleGNvb3JkWTtcbiAgcG9pbnRlci50ZXhjb29yZFggPSBwb3NYIC8gY2FudmFzLndpZHRoO1xuICBwb2ludGVyLnRleGNvb3JkWSA9IDEuMCAtIHBvc1kgLyBjYW52YXMuaGVpZ2h0O1xuICBwb2ludGVyLmRlbHRhWCA9IHBvaW50ZXIudGV4Y29vcmRYIC0gcG9pbnRlci5wcmV2VGV4Y29vcmRYO1xuICBwb2ludGVyLmRlbHRhWSA9IHBvaW50ZXIudGV4Y29vcmRZIC0gcG9pbnRlci5wcmV2VGV4Y29vcmRZO1xuICBwb2ludGVyLm1vdmVkID0gTWF0aC5hYnMocG9pbnRlci5kZWx0YVgpID4gMCB8fCBNYXRoLmFicyhwb2ludGVyLmRlbHRhWSkgPiAwO1xufVxuXG5mdW5jdGlvbiBhdHRhY2hFdmVudExpc3RlbmVycygpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8ICFjYW52YXMpIHJldHVybjtcblxuICBjb25zdCBib2R5ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignYm9keScpO1xuICBpZiAoIWJvZHkpIHJldHVybjtcblxuICBjb25zdCBtb3VzZU1vdmVIYW5kbGVyID0gKGU6IE1vdXNlRXZlbnQpID0+IHtcbiAgICBpZiAoIXBvaW50ZXJzWzBdKSByZXR1cm47XG4gICAgY29uc3QgcG9pbnRlciA9IHBvaW50ZXJzWzBdO1xuICAgIGNvbnN0IHBvc1ggPSBzY2FsZUJ5UGl4ZWxSYXRpbyhlLmNsaWVudFgpO1xuICAgIGNvbnN0IHBvc1kgPSBzY2FsZUJ5UGl4ZWxSYXRpbyhlLmNsaWVudFkpO1xuICAgIHVwZGF0ZVBvaW50ZXJNb3ZlRGF0YShwb2ludGVyLCBwb3NYLCBwb3NZKTtcbiAgfTtcblxuICBjb25zdCB0b3VjaE1vdmVIYW5kbGVyID0gKGU6IFRvdWNoRXZlbnQpID0+IHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgaWYgKGUudG91Y2hlcy5sZW5ndGggPiAwICYmIHBvaW50ZXJzWzBdKSB7XG4gICAgICBjb25zdCB0b3VjaCA9IGUudG91Y2hlc1swXTtcbiAgICAgIGNvbnN0IHBvc1ggPSBzY2FsZUJ5UGl4ZWxSYXRpbyh0b3VjaC5jbGllbnRYKTtcbiAgICAgIGNvbnN0IHBvc1kgPSBzY2FsZUJ5UGl4ZWxSYXRpbyh0b3VjaC5jbGllbnRZKTtcbiAgICAgIHVwZGF0ZVBvaW50ZXJNb3ZlRGF0YShwb2ludGVyc1swXSwgcG9zWCwgcG9zWSk7XG4gICAgfVxuICB9O1xuXG4gIGJvZHkuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBtb3VzZU1vdmVIYW5kbGVyKTtcbiAgYm9keS5hZGRFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIHRvdWNoTW92ZUhhbmRsZXIsIHsgcGFzc2l2ZTogZmFsc2UgfSk7XG59XG5cbi8vIE1haW4gaW5pdGlhbGl6YXRpb25cbmV4cG9ydCBmdW5jdGlvbiBpbml0Rmx1aWRTaW11bGF0aW9uKCkge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybjtcbiAgXG4gIGlmIChmbHVpZEluaXRpYWxpemVkKSB7XG4gICAgY29uc29sZS5sb2coJ0ZsdWlkIGFscmVhZHkgaW5pdGlhbGl6ZWQnKTtcbiAgICBhdHRhY2hFdmVudExpc3RlbmVycygpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnNvbGUubG9nKCdJbml0aWFsaXppbmcgV2ViR0wgZmx1aWQgc2ltdWxhdGlvbi4uLicpO1xuXG4gIGNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZmx1aWRcIikgYXMgSFRNTENhbnZhc0VsZW1lbnQ7XG4gIGlmICghY2FudmFzKSB7XG4gICAgY29uc29sZS5lcnJvcignRmx1aWQgY2FudmFzIG5vdCBmb3VuZCcpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHdlYmdsQ29udGV4dCA9IGdldFdlYkdMQ29udGV4dChjYW52YXMpO1xuICBpZiAoIXdlYmdsQ29udGV4dCkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBnZXQgV2ViR0wgY29udGV4dCcpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGdsID0gd2ViZ2xDb250ZXh0LmdsO1xuICBleHQgPSB3ZWJnbENvbnRleHQuZXh0O1xuXG4gIC8vIENvbmZpZ3VyYXRpb25cbiAgY29uZmlnID0ge1xuICAgIFNQTEFUX1JBRElVUzogMC4yNSxcbiAgICBTUExBVF9GT1JDRTogNjAwMCxcbiAgICBERU5TSVRZX0RJU1NJUEFUSU9OOiAxLFxuICAgIFZFTE9DSVRZX0RJU1NJUEFUSU9OOiAwLjIsXG4gICAgUFJFU1NVUkU6IDAuOCxcbiAgICBDVVJMOiAzMCxcbiAgICBDT0xPUl9VUERBVEVfU1BFRUQ6IDEwXG4gIH07XG5cbiAgLy8gQ3JlYXRlIHNoYWRlcnNcbiAgY29uc3QgdmVydGV4U2hhZGVyID0gY29tcGlsZVNoYWRlcihnbC5WRVJURVhfU0hBREVSLCB2ZXJ0ZXhTaGFkZXJTb3VyY2UpO1xuICBjb25zdCBmcmFnbWVudFNoYWRlciA9IGNvbXBpbGVTaGFkZXIoZ2wuRlJBR01FTlRfU0hBREVSLCBmcmFnbWVudFNoYWRlclNvdXJjZSk7XG4gIGNvbnN0IGRpc3BsYXlGcmFnbWVudFNoYWRlciA9IGNvbXBpbGVTaGFkZXIoZ2wuRlJBR01FTlRfU0hBREVSLCBkaXNwbGF5U2hhZGVyU291cmNlKTtcblxuICBpZiAoIXZlcnRleFNoYWRlciB8fCAhZnJhZ21lbnRTaGFkZXIgfHwgIWRpc3BsYXlGcmFnbWVudFNoYWRlcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBjb21waWxlIHNoYWRlcnMnKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBwcm9ncmFtcy5zcGxhdCA9IGNyZWF0ZVByb2dyYW0odmVydGV4U2hhZGVyLCBmcmFnbWVudFNoYWRlcik7XG4gIHByb2dyYW1zLmRpc3BsYXkgPSBjcmVhdGVQcm9ncmFtKHZlcnRleFNoYWRlciwgZGlzcGxheUZyYWdtZW50U2hhZGVyKTtcblxuICBpZiAoIXByb2dyYW1zLnNwbGF0IHx8ICFwcm9ncmFtcy5kaXNwbGF5KSB7XG4gICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGNyZWF0ZSBwcm9ncmFtcycpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFNldHVwXG4gIHNldHVwQmxpdCgpO1xuICBpbml0RnJhbWVidWZmZXJzKCk7XG5cbiAgLy8gSW5pdGlhbGl6ZSBwb2ludGVyXG4gIHBvaW50ZXJzID0gW25ldyBQb2ludGVyKCldO1xuICBwb2ludGVyc1swXS5jb2xvciA9IGdlbmVyYXRlQ29sb3IoKTtcblxuICAvLyBUaW1pbmdcbiAgbGFzdFVwZGF0ZVRpbWUgPSBEYXRlLm5vdygpO1xuICBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuXG4gIC8vIEV2ZW50IGxpc3RlbmVyc1xuICBhdHRhY2hFdmVudExpc3RlbmVycygpO1xuXG4gIC8vIFN0YXJ0IHJlbmRlciBsb29wXG4gIHJlbmRlcigpO1xuXG4gIGZsdWlkSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICBjb25zb2xlLmxvZygnV2ViR0wgZmx1aWQgc2ltdWxhdGlvbiBpbml0aWFsaXplZCBzdWNjZXNzZnVsbHkhJyk7XG59Il0sIm5hbWVzIjpbImZsdWlkSW5pdGlhbGl6ZWQiLCJjYW52YXMiLCJnbCIsImV4dCIsImNvbmZpZyIsInBvaW50ZXJzIiwiZHllIiwidmVsb2NpdHkiLCJwcm9ncmFtcyIsImZyYW1lYnVmZmVycyIsImxhc3RVcGRhdGVUaW1lIiwic3RhcnRUaW1lIiwiUG9pbnRlciIsImlkIiwidGV4Y29vcmRYIiwidGV4Y29vcmRZIiwicHJldlRleGNvb3JkWCIsInByZXZUZXhjb29yZFkiLCJkZWx0YVgiLCJkZWx0YVkiLCJkb3duIiwibW92ZWQiLCJjb2xvciIsInIiLCJnIiwiYiIsInNjYWxlQnlQaXhlbFJhdGlvIiwiaW5wdXQiLCJwaXhlbFJhdGlvIiwid2luZG93IiwiZGV2aWNlUGl4ZWxSYXRpbyIsIk1hdGgiLCJmbG9vciIsImdlbmVyYXRlQ29sb3IiLCJjIiwiSFNWdG9SR0IiLCJyYW5kb20iLCJoIiwicyIsInYiLCJpIiwiZiIsInAiLCJxIiwidCIsImdldFdlYkdMQ29udGV4dCIsInBhcmFtcyIsImFscGhhIiwiZGVwdGgiLCJzdGVuY2lsIiwiYW50aWFsaWFzIiwicHJlc2VydmVEcmF3aW5nQnVmZmVyIiwiZ2V0Q29udGV4dCIsImlzV2ViR0wyIiwiY2xlYXJDb2xvciIsImZvcm1hdFJHQkEiLCJpbnRlcm5hbEZvcm1hdCIsIlJHQkEiLCJmb3JtYXQiLCJoYWxmRmxvYXRUZXhUeXBlIiwiSEFMRl9GTE9BVCIsInN1cHBvcnRMaW5lYXJGaWx0ZXJpbmciLCJjb21waWxlU2hhZGVyIiwidHlwZSIsInNvdXJjZSIsInNoYWRlciIsImNyZWF0ZVNoYWRlciIsInNoYWRlclNvdXJjZSIsImdldFNoYWRlclBhcmFtZXRlciIsIkNPTVBJTEVfU1RBVFVTIiwiY29uc29sZSIsImVycm9yIiwiZ2V0U2hhZGVySW5mb0xvZyIsImRlbGV0ZVNoYWRlciIsImNyZWF0ZVByb2dyYW0iLCJ2ZXJ0ZXhTaGFkZXIiLCJmcmFnbWVudFNoYWRlciIsInByb2dyYW0iLCJhdHRhY2hTaGFkZXIiLCJsaW5rUHJvZ3JhbSIsImdldFByb2dyYW1QYXJhbWV0ZXIiLCJMSU5LX1NUQVRVUyIsImdldFByb2dyYW1JbmZvTG9nIiwidmVydGV4U2hhZGVyU291cmNlIiwiZnJhZ21lbnRTaGFkZXJTb3VyY2UiLCJkaXNwbGF5U2hhZGVyU291cmNlIiwiY3JlYXRlRkJPIiwidyIsImFjdGl2ZVRleHR1cmUiLCJURVhUVVJFMCIsInRleHR1cmUiLCJjcmVhdGVUZXh0dXJlIiwiYmluZFRleHR1cmUiLCJURVhUVVJFXzJEIiwidGV4UGFyYW1ldGVyaSIsIlRFWFRVUkVfTUlOX0ZJTFRFUiIsIkxJTkVBUiIsIlRFWFRVUkVfTUFHX0ZJTFRFUiIsIlRFWFRVUkVfV1JBUF9TIiwiQ0xBTVBfVE9fRURHRSIsIlRFWFRVUkVfV1JBUF9UIiwidGV4SW1hZ2UyRCIsIlVOU0lHTkVEX0JZVEUiLCJmYm8iLCJjcmVhdGVGcmFtZWJ1ZmZlciIsImJpbmRGcmFtZWJ1ZmZlciIsIkZSQU1FQlVGRkVSIiwiZnJhbWVidWZmZXJUZXh0dXJlMkQiLCJDT0xPUl9BVFRBQ0hNRU5UMCIsInZpZXdwb3J0IiwiY2xlYXIiLCJDT0xPUl9CVUZGRVJfQklUIiwid2lkdGgiLCJoZWlnaHQiLCJhdHRhY2giLCJibGl0Iiwic2V0dXBCbGl0IiwiYmluZEJ1ZmZlciIsIkFSUkFZX0JVRkZFUiIsImNyZWF0ZUJ1ZmZlciIsImJ1ZmZlckRhdGEiLCJGbG9hdDMyQXJyYXkiLCJTVEFUSUNfRFJBVyIsIkVMRU1FTlRfQVJSQVlfQlVGRkVSIiwiVWludDE2QXJyYXkiLCJ2ZXJ0ZXhBdHRyaWJQb2ludGVyIiwiRkxPQVQiLCJlbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSIsInRhcmdldCIsImRyYXdpbmdCdWZmZXJXaWR0aCIsImRyYXdpbmdCdWZmZXJIZWlnaHQiLCJkcmF3RWxlbWVudHMiLCJUUklBTkdMRVMiLCJVTlNJR05FRF9TSE9SVCIsInJlbmRlciIsImR0IiwiY2FsY0RlbHRhVGltZSIsInJlc2l6ZUNhbnZhcyIsImluaXRGcmFtZWJ1ZmZlcnMiLCJhcHBseUlucHV0cyIsInN0ZXAiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJub3ciLCJEYXRlIiwibWluIiwiZm9yRWFjaCIsInBvaW50ZXIiLCJzcGxhdFBvaW50ZXIiLCJkeCIsIlNQTEFUX0ZPUkNFIiwiZHkiLCJzcGxhdCIsIngiLCJ5IiwidXNlUHJvZ3JhbSIsInVuaWZvcm0xaSIsImdldFVuaWZvcm1Mb2NhdGlvbiIsInJlYWQiLCJ1bmlmb3JtMWYiLCJ1bmlmb3JtMmYiLCJ1bmlmb3JtM2YiLCJTUExBVF9SQURJVVMiLCJ3cml0ZSIsInN3YXAiLCJkaXNwbGF5IiwiY2xpZW50V2lkdGgiLCJjbGllbnRIZWlnaHQiLCJzaW1SZXMiLCJ0ZW1wIiwidXBkYXRlUG9pbnRlck1vdmVEYXRhIiwicG9zWCIsInBvc1kiLCJhYnMiLCJhdHRhY2hFdmVudExpc3RlbmVycyIsImJvZHkiLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3IiLCJtb3VzZU1vdmVIYW5kbGVyIiwiZSIsImNsaWVudFgiLCJjbGllbnRZIiwidG91Y2hNb3ZlSGFuZGxlciIsInByZXZlbnREZWZhdWx0IiwidG91Y2hlcyIsImxlbmd0aCIsInRvdWNoIiwiYWRkRXZlbnRMaXN0ZW5lciIsInBhc3NpdmUiLCJpbml0Rmx1aWRTaW11bGF0aW9uIiwibG9nIiwiZ2V0RWxlbWVudEJ5SWQiLCJ3ZWJnbENvbnRleHQiLCJERU5TSVRZX0RJU1NJUEFUSU9OIiwiVkVMT0NJVFlfRElTU0lQQVRJT04iLCJQUkVTU1VSRSIsIkNVUkwiLCJDT0xPUl9VUERBVEVfU1BFRUQiLCJWRVJURVhfU0hBREVSIiwiRlJBR01FTlRfU0hBREVSIiwiZGlzcGxheUZyYWdtZW50U2hhZGVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/lib/fluid.ts\n"));

/***/ })

});