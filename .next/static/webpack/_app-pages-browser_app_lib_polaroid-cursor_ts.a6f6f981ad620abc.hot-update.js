"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_app-pages-browser_app_lib_polaroid-cursor_ts",{

/***/ "(app-pages-browser)/./app/lib/polaroid-cursor.ts":
/*!************************************!*\
  !*** ./app/lib/polaroid-cursor.ts ***!
  \************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cleanupPolaroidCursor: function() { return /* binding */ cleanupPolaroidCursor; },\n/* harmony export */   initPolaroidCursor: function() { return /* binding */ initPolaroidCursor; }\n/* harmony export */ });\n// Polaroid Cursor Effect\n// Creates polaroid photos that follow mouse movement\nlet polaroidInitialized = false;\nlet container = null;\nlet polaroids = [];\nlet mouseX = 0;\nlet mouseY = 0;\nlet lastMouseX = 0;\nlet lastMouseY = 0;\n// All available photos - only from public/photos/\nconst photoList = [\n    \"/photos/AStreetInHaarlem.jpg\",\n    \"/photos/Autopark.jpg\",\n    \"/photos/DeBurcht.jpg\",\n    \"/photos/SAIL.jpg\",\n    \"/photos/SintBonifatiuskerk.jpg\"\n];\nconst config = {\n    maxPolaroids: 15,\n    polaroidLife: 300,\n    spawnRate: 0.6,\n    fadeOutDuration: 100,\n    minMovementThreshold: 1,\n    polaroidSize: 140\n};\nfunction getRandomPhoto() {\n    return photoList[Math.floor(Math.random() * photoList.length)];\n}\nfunction createPolaroidElement(x, y) {\n    const element = document.createElement(\"div\");\n    const image = getRandomPhoto();\n    element.className = \"polaroid-photo\";\n    element.innerHTML = '\\n    <div class=\"polaroid-inner\">\\n      <img src=\"'.concat(image, '\" alt=\"Random photo\" />\\n      <div class=\"polaroid-caption\"></div>\\n    </div>\\n  ');\n    // Random rotation and slight scale variation\n    const rotation = (Math.random() - 0.5) * 30; // -15 to 15 degrees\n    const scale = 0.8 + Math.random() * 0.4; // 0.8 to 1.2\n    element.style.cssText = \"\\n    position: fixed;\\n    width: \".concat(config.polaroidSize, \"px;\\n    height: \").concat(config.polaroidSize * 1.2, \"px;\\n    pointer-events: none;\\n    z-index: 1000;\\n    transform: translate(-50%, -50%) rotate(\").concat(rotation, \"deg) scale(\").concat(scale, \");\\n    transition: none;\\n  \");\n    const polaroidElement = {\n        element,\n        x,\n        y,\n        rotation,\n        scale,\n        opacity: 1,\n        life: config.polaroidLife,\n        maxLife: config.polaroidLife,\n        vx: (Math.random() - 0.5) * 2,\n        vy: (Math.random() - 0.5) * 2,\n        image\n    };\n    if (container) {\n        container.appendChild(element);\n    }\n    return polaroidElement;\n}\nfunction updatePolaroids() {\n    // Update existing polaroids\n    for(let i = polaroids.length - 1; i >= 0; i--){\n        const polaroid = polaroids[i];\n        // Update position with slight drift\n        polaroid.x += polaroid.vx;\n        polaroid.y += polaroid.vy;\n        // Apply slight drag\n        polaroid.vx *= 0.98;\n        polaroid.vy *= 0.98;\n        // Update life\n        polaroid.life--;\n        // Calculate opacity based on remaining life\n        if (polaroid.life < config.fadeOutDuration) {\n            polaroid.opacity = polaroid.life / config.fadeOutDuration;\n        }\n        // Update element position and opacity\n        polaroid.element.style.left = \"\".concat(polaroid.x, \"px\");\n        polaroid.element.style.top = \"\".concat(polaroid.y, \"px\");\n        polaroid.element.style.opacity = polaroid.opacity.toString();\n        // Remove dead polaroids\n        if (polaroid.life <= 0) {\n            if (container && polaroid.element.parentNode) {\n                container.removeChild(polaroid.element);\n            }\n            polaroids.splice(i, 1);\n        }\n    }\n    // Improved continuous spawning logic\n    const dx = mouseX - lastMouseX;\n    const dy = mouseY - lastMouseY;\n    const movement = Math.sqrt(dx * dx + dy * dy);\n    // Always try to spawn when moving and under limit\n    if (movement > config.minMovementThreshold && polaroids.length < config.maxPolaroids) {\n        // Higher probability for faster movement\n        const speedBonus = Math.min(movement * 0.05, 0.4);\n        const totalSpawnRate = config.spawnRate + speedBonus;\n        if (Math.random() < totalSpawnRate) {\n            const spawnX = mouseX + (Math.random() - 0.5) * 40;\n            const spawnY = mouseY + (Math.random() - 0.5) * 40;\n            polaroids.push(createPolaroidElement(spawnX, spawnY));\n        }\n    }\n    // Continuous background spawning for smooth flow\n    if (polaroids.length < config.maxPolaroids * 0.8) {\n        if (Math.random() < 0.15) {\n            const spawnX = mouseX + (Math.random() - 0.5) * 60;\n            const spawnY = mouseY + (Math.random() - 0.5) * 60;\n            polaroids.push(createPolaroidElement(spawnX, spawnY));\n        }\n    }\n    // Emergency spawning if too few photos\n    if (polaroids.length < 3 && Math.random() < 0.3) {\n        const spawnX = mouseX + (Math.random() - 0.5) * 50;\n        const spawnY = mouseY + (Math.random() - 0.5) * 50;\n        polaroids.push(createPolaroidElement(spawnX, spawnY));\n    }\n    lastMouseX = mouseX;\n    lastMouseY = mouseY;\n}\nfunction animate() {\n    updatePolaroids();\n    requestAnimationFrame(animate);\n}\n// Event handlers\nfunction attachEventListeners() {\n    if (false) {}\n    const mouseMoveHandler = (e)=>{\n        mouseX = e.clientX;\n        mouseY = e.clientY;\n    };\n    const touchMoveHandler = (e)=>{\n        e.preventDefault();\n        if (e.touches.length > 0) {\n            const touch = e.touches[0];\n            mouseX = touch.clientX;\n            mouseY = touch.clientY;\n        }\n    };\n    document.addEventListener(\"mousemove\", mouseMoveHandler);\n    document.addEventListener(\"touchmove\", touchMoveHandler, {\n        passive: false\n    });\n}\n// Main initialization function\nfunction initPolaroidCursor() {\n    if (false) {}\n    if (polaroidInitialized) {\n        console.log(\"Polaroid cursor already initialized\");\n        return;\n    }\n    console.log(\"Initializing polaroid cursor effect...\");\n    // Create container for polaroids\n    container = document.createElement(\"div\");\n    container.id = \"polaroid-container\";\n    container.style.cssText = \"\\n    position: fixed;\\n    top: 0;\\n    left: 0;\\n    width: 100vw;\\n    height: 100vh;\\n    pointer-events: none;\\n    z-index: 1000;\\n  \";\n    document.body.appendChild(container);\n    // Initialize mouse position\n    mouseX = window.innerWidth / 2;\n    mouseY = window.innerHeight / 2;\n    lastMouseX = mouseX;\n    lastMouseY = mouseY;\n    // Attach event listeners\n    attachEventListeners();\n    // Start animation loop\n    animate();\n    polaroidInitialized = true;\n    console.log(\"Polaroid cursor effect initialized successfully!\");\n}\n// Cleanup function\nfunction cleanupPolaroidCursor() {\n    if (container && container.parentNode) {\n        document.body.removeChild(container);\n    }\n    polaroids.forEach((polaroid)=>{\n        if (polaroid.element.parentNode) {\n            polaroid.element.parentNode.removeChild(polaroid.element);\n        }\n    });\n    polaroids = [];\n    container = null;\n    polaroidInitialized = false;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9saWIvcG9sYXJvaWQtY3Vyc29yLnRzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUEseUJBQXlCO0FBQ3pCLHFEQUFxRDtBQUVyRCxJQUFJQSxzQkFBc0I7QUFDMUIsSUFBSUMsWUFBbUM7QUFDdkMsSUFBSUMsWUFBK0IsRUFBRTtBQUNyQyxJQUFJQyxTQUFTO0FBQ2IsSUFBSUMsU0FBUztBQUNiLElBQUlDLGFBQWE7QUFDakIsSUFBSUMsYUFBYTtBQWdCakIsa0RBQWtEO0FBQ2xELE1BQU1DLFlBQVk7SUFDaEI7SUFDQTtJQUNBO0lBQ0E7SUFDQTtDQUNEO0FBRUQsTUFBTUMsU0FBUztJQUNiQyxjQUFjO0lBQ2RDLGNBQWM7SUFDZEMsV0FBVztJQUNYQyxpQkFBaUI7SUFDakJDLHNCQUFzQjtJQUN0QkMsY0FBYztBQUNoQjtBQUVBLFNBQVNDO0lBQ1AsT0FBT1IsU0FBUyxDQUFDUyxLQUFLQyxLQUFLLENBQUNELEtBQUtFLE1BQU0sS0FBS1gsVUFBVVksTUFBTSxFQUFFO0FBQ2hFO0FBRUEsU0FBU0Msc0JBQXNCQyxDQUFTLEVBQUVDLENBQVM7SUFDakQsTUFBTUMsVUFBVUMsU0FBU0MsYUFBYSxDQUFDO0lBQ3ZDLE1BQU1DLFFBQVFYO0lBRWRRLFFBQVFJLFNBQVMsR0FBRztJQUNwQkosUUFBUUssU0FBUyxHQUFHLHVEQUVFLE9BQU5GLE9BQU07SUFLdEIsNkNBQTZDO0lBQzdDLE1BQU1HLFdBQVcsQ0FBQ2IsS0FBS0UsTUFBTSxLQUFLLEdBQUUsSUFBSyxJQUFJLG9CQUFvQjtJQUNqRSxNQUFNWSxRQUFRLE1BQU1kLEtBQUtFLE1BQU0sS0FBSyxLQUFLLGFBQWE7SUFFdERLLFFBQVFRLEtBQUssQ0FBQ0MsT0FBTyxHQUFHLHNDQUdaeEIsT0FEREEsT0FBT00sWUFBWSxFQUFDLHFCQUlhZSxPQUhoQ3JCLE9BQU9NLFlBQVksR0FBRyxLQUFJLG9HQUc0QmdCLE9BQXRCRCxVQUFTLGVBQW1CLE9BQU5DLE9BQU07SUFJeEUs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QUFRQyxHQUFHLENBQUM7SUFFWixpQ0FBaUM7SUFDakN6RSxZQUFZdUIsU0FBU0MsYUFBYSxDQUFDO0lBQ25DeEIsVUFBVTBFLEVBQUUsR0FBRztJQUNmMUUsVUFBVThCLEtBQUssQ0FBQ0MsT0FBTyxHQUFJO0lBVTNCUixTQUFTb0QsSUFBSSxDQUFDckMsV0FBVyxDQUFDdEM7SUFFMUIsNEJBQTRCO0lBQzVCRSxTQUFTMEUsT0FBT0MsVUFBVSxHQUFHO0lBQzdCMUUsU0FBU3lFLE9BQU9FLFdBQVcsR0FBRztJQUM5QjFFLGFBQWFGO0lBQ2JHLGFBQWFGO0lBRWIseUJBQXlCO0lBQ3pCeUQ7SUFFQSx1QkFBdUI7SUFDdkJGO0lBRUEzRCxzQkFBc0I7SUFDdEJ5RSxRQUFRQyxHQUFHLENBQUM7QUFDZDtBQUVBLG1CQUFtQjtBQUNaLFNBQVNNO0lBQ2QsSUFBSS9FLGFBQWFBLFVBQVU2QyxVQUFVLEVBQUU7UUFDckN0QixTQUFTb0QsSUFBSSxDQUFDN0IsV0FBVyxDQUFDOUM7SUFDNUI7SUFFQUMsVUFBVStFLE9BQU8sQ0FBQ3ZDLENBQUFBO1FBQ2hCLElBQUlBLFNBQVNuQixPQUFPLENBQUN1QixVQUFVLEVBQUU7WUFDL0JKLFNBQVNuQixPQUFPLENBQUN1QixVQUFVLENBQUNDLFdBQVcsQ0FBQ0wsU0FBU25CLE9BQU87UUFDMUQ7SUFDRjtJQUVBckIsWUFBWSxFQUFFO0lBQ2RELFlBQVk7SUFDWkQsc0JBQXNCO0FBQ3hCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2FwcC9saWIvcG9sYXJvaWQtY3Vyc29yLnRzPzgyNjYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gUG9sYXJvaWQgQ3Vyc29yIEVmZmVjdFxuLy8gQ3JlYXRlcyBwb2xhcm9pZCBwaG90b3MgdGhhdCBmb2xsb3cgbW91c2UgbW92ZW1lbnRcblxubGV0IHBvbGFyb2lkSW5pdGlhbGl6ZWQgPSBmYWxzZTtcbmxldCBjb250YWluZXI6IEhUTUxEaXZFbGVtZW50IHwgbnVsbCA9IG51bGw7XG5sZXQgcG9sYXJvaWRzOiBQb2xhcm9pZEVsZW1lbnRbXSA9IFtdO1xubGV0IG1vdXNlWCA9IDA7XG5sZXQgbW91c2VZID0gMDtcbmxldCBsYXN0TW91c2VYID0gMDtcbmxldCBsYXN0TW91c2VZID0gMDtcblxuaW50ZXJmYWNlIFBvbGFyb2lkRWxlbWVudCB7XG4gIGVsZW1lbnQ6IEhUTUxEaXZFbGVtZW50O1xuICB4OiBudW1iZXI7XG4gIHk6IG51bWJlcjtcbiAgcm90YXRpb246IG51bWJlcjtcbiAgc2NhbGU6IG51bWJlcjtcbiAgb3BhY2l0eTogbnVtYmVyO1xuICBsaWZlOiBudW1iZXI7XG4gIG1heExpZmU6IG51bWJlcjtcbiAgdng6IG51bWJlcjtcbiAgdnk6IG51bWJlcjtcbiAgaW1hZ2U6IHN0cmluZztcbn1cblxuLy8gQWxsIGF2YWlsYWJsZSBwaG90b3MgLSBvbmx5IGZyb20gcHVibGljL3Bob3Rvcy9cbmNvbnN0IHBob3RvTGlzdCA9IFtcbiAgJy9waG90b3MvQVN0cmVldEluSGFhcmxlbS5qcGcnLFxuICAnL3Bob3Rvcy9BdXRvcGFyay5qcGcnLFxuICAnL3Bob3Rvcy9EZUJ1cmNodC5qcGcnLFxuICAnL3Bob3Rvcy9TQUlMLmpwZycsXG4gICcvcGhvdG9zL1NpbnRCb25pZmF0aXVza2Vyay5qcGcnLFxuXTtcblxuY29uc3QgY29uZmlnID0ge1xuICBtYXhQb2xhcm9pZHM6IDE1LCAvLyBFdmVuIG1vcmUgZm9yIGNvbnRpbnVvdXMgZmxvd1xuICBwb2xhcm9pZExpZmU6IDMwMCwgLy8gTG9uZ2VyIGxpZmVcbiAgc3Bhd25SYXRlOiAwLjYsIC8vIE11Y2ggaGlnaGVyIHNwYXduIHJhdGVcbiAgZmFkZU91dER1cmF0aW9uOiAxMDAsIC8vIExvbmdlciBmYWRlXG4gIG1pbk1vdmVtZW50VGhyZXNob2xkOiAxLCAvLyBWZXJ5IGxvdyB0aHJlc2hvbGRcbiAgcG9sYXJvaWRTaXplOiAxNDAsIC8vIEJpZ2dlciBwaG90b3Ncbn07XG5cbmZ1bmN0aW9uIGdldFJhbmRvbVBob3RvKCk6IHN0cmluZyB7XG4gIHJldHVybiBwaG90b0xpc3RbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogcGhvdG9MaXN0Lmxlbmd0aCldO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVQb2xhcm9pZEVsZW1lbnQoeDogbnVtYmVyLCB5OiBudW1iZXIpOiBQb2xhcm9pZEVsZW1lbnQge1xuICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGNvbnN0IGltYWdlID0gZ2V0UmFuZG9tUGhvdG8oKTtcbiAgXG4gIGVsZW1lbnQuY2xhc3NOYW1lID0gJ3BvbGFyb2lkLXBob3RvJztcbiAgZWxlbWVudC5pbm5lckhUTUwgPSBgXG4gICAgPGRpdiBjbGFzcz1cInBvbGFyb2lkLWlubmVyXCI+XG4gICAgICA8aW1nIHNyYz1cIiR7aW1hZ2V9XCIgYWx0PVwiUmFuZG9tIHBob3RvXCIgLz5cbiAgICAgIDxkaXYgY2xhc3M9XCJwb2xhcm9pZC1jYXB0aW9uXCI+PC9kaXY+XG4gICAgPC9kaXY+XG4gIGA7XG4gIFxuICAvLyBSYW5kb20gcm90YXRpb24gYW5kIHNsaWdodCBzY2FsZSB2YXJpYXRpb25cbiAgY29uc3Qgcm90YXRpb24gPSAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAzMDsgLy8gLTE1IHRvIDE1IGRlZ3JlZXNcbiAgY29uc3Qgc2NhbGUgPSAwLjggKyBNYXRoLnJhbmRvbSgpICogMC40OyAvLyAwLjggdG8gMS4yXG4gIFxuICBlbGVtZW50LnN0eWxlLmNzc1RleHQgPSBgXG4gICAgcG9zaXRpb246IGZpeGVkO1xuICAgIHdpZHRoOiAke2NvbmZpZy5wb2xhcm9pZFNpemV9cHg7XG4gICAgaGVpZ2h0OiAke2NvbmZpZy5wb2xhcm9pZFNpemUgKiAxLjJ9cHg7XG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gICAgei1pbmRleDogMTAwMDtcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgtNTAlLCAtNTAlKSByb3RhdGUoJHtyb3RhdGlvbn1kZWcpIHNjYWxlKCR7c2NhbGV9KTtcbiAgICB0cmFuc2l0aW9uOiBub25lO1xuICBgO1xuICBcbiAgY29uc3QgcG9sYXJvaWRFbGVtZW50OiBQb2xhcm9pZEVsZW1lbnQgPSB7XG4gICAgZWxlbWVudCxcbiAgICB4LFxuICAgIHksXG4gICAgcm90YXRpb24sXG4gICAgc2NhbGUsXG4gICAgb3BhY2l0eTogMSxcbiAgICBsaWZlOiBjb25maWcucG9sYXJvaWRMaWZlLFxuICAgIG1heExpZmU6IGNvbmZpZy5wb2xhcm9pZExpZmUsXG4gICAgdng6IChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIDIsXG4gICAgdnk6IChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIDIsXG4gICAgaW1hZ2VcbiAgfTtcbiAgXG4gIGlmIChjb250YWluZXIpIHtcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG4gIH1cbiAgXG4gIHJldHVybiBwb2xhcm9pZEVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVBvbGFyb2lkcygpIHtcbiAgLy8gVXBkYXRlIGV4aXN0aW5nIHBvbGFyb2lkc1xuICBmb3IgKGxldCBpID0gcG9sYXJvaWRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgY29uc3QgcG9sYXJvaWQgPSBwb2xhcm9pZHNbaV07XG4gICAgXG4gICAgLy8gVXBkYXRlIHBvc2l0aW9uIHdpdGggc2xpZ2h0IGRyaWZ0XG4gICAgcG9sYXJvaWQueCArPSBwb2xhcm9pZC52eDtcbiAgICBwb2xhcm9pZC55ICs9IHBvbGFyb2lkLnZ5O1xuICAgIFxuICAgIC8vIEFwcGx5IHNsaWdodCBkcmFnXG4gICAgcG9sYXJvaWQudnggKj0gMC45ODtcbiAgICBwb2xhcm9pZC52eSAqPSAwLjk4O1xuICAgIFxuICAgIC8vIFVwZGF0ZSBsaWZlXG4gICAgcG9sYXJvaWQubGlmZS0tO1xuICAgIFxuICAgIC8vIENhbGN1bGF0ZSBvcGFjaXR5IGJhc2VkIG9uIHJlbWFpbmluZyBsaWZlXG4gICAgaWYgKHBvbGFyb2lkLmxpZmUgPCBjb25maWcuZmFkZU91dER1cmF0aW9uKSB7XG4gICAgICBwb2xhcm9pZC5vcGFjaXR5ID0gcG9sYXJvaWQubGlmZSAvIGNvbmZpZy5mYWRlT3V0RHVyYXRpb247XG4gICAgfVxuICAgIFxuICAgIC8vIFVwZGF0ZSBlbGVtZW50IHBvc2l0aW9uIGFuZCBvcGFjaXR5XG4gICAgcG9sYXJvaWQuZWxlbWVudC5zdHlsZS5sZWZ0ID0gYCR7cG9sYXJvaWQueH1weGA7XG4gICAgcG9sYXJvaWQuZWxlbWVudC5zdHlsZS50b3AgPSBgJHtwb2xhcm9pZC55fXB4YDtcbiAgICBwb2xhcm9pZC5lbGVtZW50LnN0eWxlLm9wYWNpdHkgPSBwb2xhcm9pZC5vcGFjaXR5LnRvU3RyaW5nKCk7XG4gICAgXG4gICAgLy8gUmVtb3ZlIGRlYWQgcG9sYXJvaWRzXG4gICAgaWYgKHBvbGFyb2lkLmxpZmUgPD0gMCkge1xuICAgICAgaWYgKGNvbnRhaW5lciAmJiBwb2xhcm9pZC5lbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgICAgY29udGFpbmVyLnJlbW92ZUNoaWxkKHBvbGFyb2lkLmVsZW1lbnQpO1xuICAgICAgfVxuICAgICAgcG9sYXJvaWRzLnNwbGljZShpLCAxKTtcbiAgICB9XG4gIH1cbiAgXG4gIC8vIEltcHJvdmVkIGNvbnRpbnVvdXMgc3Bhd25pbmcgbG9naWNcbiAgY29uc3QgZHggPSBtb3VzZVggLSBsYXN0TW91c2VYO1xuICBjb25zdCBkeSA9IG1vdXNlWSAtIGxhc3RNb3VzZVk7XG4gIGNvbnN0IG1vdmVtZW50ID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgXG4gIC8vIEFsd2F5cyB0cnkgdG8gc3Bhd24gd2hlbiBtb3ZpbmcgYW5kIHVuZGVyIGxpbWl0XG4gIGlmIChtb3ZlbWVudCA+IGNvbmZpZy5taW5Nb3ZlbWVudFRocmVzaG9sZCAmJiBwb2xhcm9pZHMubGVuZ3RoIDwgY29uZmlnLm1heFBvbGFyb2lkcykge1xuICAgIC8vIEhpZ2hlciBwcm9iYWJpbGl0eSBmb3IgZmFzdGVyIG1vdmVtZW50XG4gICAgY29uc3Qgc3BlZWRCb251cyA9IE1hdGgubWluKG1vdmVtZW50ICogMC4wNSwgMC40KTtcbiAgICBjb25zdCB0b3RhbFNwYXduUmF0ZSA9IGNvbmZpZy5zcGF3blJhdGUgKyBzcGVlZEJvbnVzO1xuICAgIFxuICAgIGlmIChNYXRoLnJhbmRvbSgpIDwgdG90YWxTcGF3blJhdGUpIHtcbiAgICAgIGNvbnN0IHNwYXduWCA9IG1vdXNlWCArIChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIDQwO1xuICAgICAgY29uc3Qgc3Bhd25ZID0gbW91c2VZICsgKE1hdGgucmFuZG9tKCkgLSAwLjUpICogNDA7XG4gICAgICBwb2xhcm9pZHMucHVzaChjcmVhdGVQb2xhcm9pZEVsZW1lbnQoc3Bhd25YLCBzcGF3blkpKTtcbiAgICB9XG4gIH1cbiAgXG4gIC8vIENvbnRpbnVvdXMgYmFja2dyb3VuZCBzcGF3bmluZyBmb3Igc21vb3RoIGZsb3dcbiAgaWYgKHBvbGFyb2lkcy5sZW5ndGggPCBjb25maWcubWF4UG9sYXJvaWRzICogMC44KSB7XG4gICAgaWYgKE1hdGgucmFuZG9tKCkgPCAwLjE1KSB7IC8vIEhpZ2hlciBiYWNrZ3JvdW5kIHNwYXduIHJhdGVcbiAgICAgIGNvbnN0IHNwYXduWCA9IG1vdXNlWCArIChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIDYwO1xuICAgICAgY29uc3Qgc3Bhd25ZID0gbW91c2VZICsgKE1hdGgucmFuZG9tKCkgLSAwLjUpICogNjA7XG4gICAgICBwb2xhcm9pZHMucHVzaChjcmVhdGVQb2xhcm9pZEVsZW1lbnQoc3Bhd25YLCBzcGF3blkpKTtcbiAgICB9XG4gIH1cbiAgXG4gIC8vIEVtZXJnZW5jeSBzcGF3bmluZyBpZiB0b28gZmV3IHBob3Rvc1xuICBpZiAocG9sYXJvaWRzLmxlbmd0aCA8IDMgJiYgTWF0aC5yYW5kb20oKSA8IDAuMykge1xuICAgIGNvbnN0IHNwYXduWCA9IG1vdXNlWCArIChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIDUwO1xuICAgIGNvbnN0IHNwYXduWSA9IG1vdXNlWSArIChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIDUwO1xuICAgIHBvbGFyb2lkcy5wdXNoKGNyZWF0ZVBvbGFyb2lkRWxlbWVudChzcGF3blgsIHNwYXduWSkpO1xuICB9XG4gIFxuICBsYXN0TW91c2VYID0gbW91c2VYO1xuICBsYXN0TW91c2VZID0gbW91c2VZO1xufVxuXG5mdW5jdGlvbiBhbmltYXRlKCkge1xuICB1cGRhdGVQb2xhcm9pZHMoKTtcbiAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpO1xufVxuXG4vLyBFdmVudCBoYW5kbGVyc1xuZnVuY3Rpb24gYXR0YWNoRXZlbnRMaXN0ZW5lcnMoKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuO1xuXG4gIGNvbnN0IG1vdXNlTW92ZUhhbmRsZXIgPSAoZTogTW91c2VFdmVudCkgPT4ge1xuICAgIG1vdXNlWCA9IGUuY2xpZW50WDtcbiAgICBtb3VzZVkgPSBlLmNsaWVudFk7XG4gIH07XG5cbiAgY29uc3QgdG91Y2hNb3ZlSGFuZGxlciA9IChlOiBUb3VjaEV2ZW50KSA9PiB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGlmIChlLnRvdWNoZXMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgdG91Y2ggPSBlLnRvdWNoZXNbMF07XG4gICAgICBtb3VzZVggPSB0b3VjaC5jbGllbnRYO1xuICAgICAgbW91c2VZID0gdG91Y2guY2xpZW50WTtcbiAgICB9XG4gIH07XG5cbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBtb3VzZU1vdmVIYW5kbGVyKTtcbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCB0b3VjaE1vdmVIYW5kbGVyLCB7IHBhc3NpdmU6IGZhbHNlIH0pO1xufVxuXG4vLyBNYWluIGluaXRpYWxpemF0aW9uIGZ1bmN0aW9uXG5leHBvcnQgZnVuY3Rpb24gaW5pdFBvbGFyb2lkQ3Vyc29yKCkge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybjtcbiAgXG4gIGlmIChwb2xhcm9pZEluaXRpYWxpemVkKSB7XG4gICAgY29uc29sZS5sb2coJ1BvbGFyb2lkIGN1cnNvciBhbHJlYWR5IGluaXRpYWxpemVkJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc29sZS5sb2coJ0luaXRpYWxpemluZyBwb2xhcm9pZCBjdXJzb3IgZWZmZWN0Li4uJyk7XG5cbiAgLy8gQ3JlYXRlIGNvbnRhaW5lciBmb3IgcG9sYXJvaWRzXG4gIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBjb250YWluZXIuaWQgPSAncG9sYXJvaWQtY29udGFpbmVyJztcbiAgY29udGFpbmVyLnN0eWxlLmNzc1RleHQgPSBgXG4gICAgcG9zaXRpb246IGZpeGVkO1xuICAgIHRvcDogMDtcbiAgICBsZWZ0OiAwO1xuICAgIHdpZHRoOiAxMDB2dztcbiAgICBoZWlnaHQ6IDEwMHZoO1xuICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICAgIHotaW5kZXg6IDEwMDA7XG4gIGA7XG4gIFxuICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XG5cbiAgLy8gSW5pdGlhbGl6ZSBtb3VzZSBwb3NpdGlvblxuICBtb3VzZVggPSB3aW5kb3cuaW5uZXJXaWR0aCAvIDI7XG4gIG1vdXNlWSA9IHdpbmRvdy5pbm5lckhlaWdodCAvIDI7XG4gIGxhc3RNb3VzZVggPSBtb3VzZVg7XG4gIGxhc3RNb3VzZVkgPSBtb3VzZVk7XG5cbiAgLy8gQXR0YWNoIGV2ZW50IGxpc3RlbmVyc1xuICBhdHRhY2hFdmVudExpc3RlbmVycygpO1xuICBcbiAgLy8gU3RhcnQgYW5pbWF0aW9uIGxvb3BcbiAgYW5pbWF0ZSgpO1xuXG4gIHBvbGFyb2lkSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICBjb25zb2xlLmxvZygnUG9sYXJvaWQgY3Vyc29yIGVmZmVjdCBpbml0aWFsaXplZCBzdWNjZXNzZnVsbHkhJyk7XG59XG5cbi8vIENsZWFudXAgZnVuY3Rpb25cbmV4cG9ydCBmdW5jdGlvbiBjbGVhbnVwUG9sYXJvaWRDdXJzb3IoKSB7XG4gIGlmIChjb250YWluZXIgJiYgY29udGFpbmVyLnBhcmVudE5vZGUpIHtcbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGNvbnRhaW5lcik7XG4gIH1cbiAgXG4gIHBvbGFyb2lkcy5mb3JFYWNoKHBvbGFyb2lkID0+IHtcbiAgICBpZiAocG9sYXJvaWQuZWxlbWVudC5wYXJlbnROb2RlKSB7XG4gICAgICBwb2xhcm9pZC5lbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQocG9sYXJvaWQuZWxlbWVudCk7XG4gICAgfVxuICB9KTtcbiAgXG4gIHBvbGFyb2lkcyA9IFtdO1xuICBjb250YWluZXIgPSBudWxsO1xuICBwb2xhcm9pZEluaXRpYWxpemVkID0gZmFsc2U7XG59XG4iXSwibmFtZXMiOlsicG9sYXJvaWRJbml0aWFsaXplZCIsImNvbnRhaW5lciIsInBvbGFyb2lkcyIsIm1vdXNlWCIsIm1vdXNlWSIsImxhc3RNb3VzZVgiLCJsYXN0TW91c2VZIiwicGhvdG9MaXN0IiwiY29uZmlnIiwibWF4UG9sYXJvaWRzIiwicG9sYXJvaWRMaWZlIiwic3Bhd25SYXRlIiwiZmFkZU91dER1cmF0aW9uIiwibWluTW92ZW1lbnRUaHJlc2hvbGQiLCJwb2xhcm9pZFNpemUiLCJnZXRSYW5kb21QaG90byIsIk1hdGgiLCJmbG9vciIsInJhbmRvbSIsImxlbmd0aCIsImNyZWF0ZVBvbGFyb2lkRWxlbWVudCIsIngiLCJ5IiwiZWxlbWVudCIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImltYWdlIiwiY2xhc3NOYW1lIiwiaW5uZXJIVE1MIiwicm90YXRpb24iLCJzY2FsZSIsInN0eWxlIiwiY3NzVGV4dCIsInBvbGFyb2lkRWxlbWVudCIsIm9wYWNpdHkiLCJsaWZlIiwibWF4TGlmZSIsInZ4IiwidnkiLCJhcHBlbmRDaGlsZCIsInVwZGF0ZVBvbGFyb2lkcyIsImkiLCJwb2xhcm9pZCIsImxlZnQiLCJ0b3AiLCJ0b1N0cmluZyIsInBhcmVudE5vZGUiLCJyZW1vdmVDaGlsZCIsInNwbGljZSIsImR4IiwiZHkiLCJtb3ZlbWVudCIsInNxcnQiLCJzcGVlZEJvbnVzIiwibWluIiwidG90YWxTcGF3blJhdGUiLCJzcGF3blgiLCJzcGF3blkiLCJwdXNoIiwiYW5pbWF0ZSIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImF0dGFjaEV2ZW50TGlzdGVuZXJzIiwibW91c2VNb3ZlSGFuZGxlciIsImUiLCJjbGllbnRYIiwiY2xpZW50WSIsInRvdWNoTW92ZUhhbmRsZXIiLCJwcmV2ZW50RGVmYXVsdCIsInRvdWNoZXMiLCJ0b3VjaCIsImFkZEV2ZW50TGlzdGVuZXIiLCJwYXNzaXZlIiwiaW5pdFBvbGFyb2lkQ3Vyc29yIiwiY29uc29sZSIsImxvZyIsImlkIiwiYm9keSIsIndpbmRvdyIsImlubmVyV2lkdGgiLCJpbm5lckhlaWdodCIsImNsZWFudXBQb2xhcm9pZEN1cnNvciIsImZvckVhY2giXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/lib/polaroid-cursor.ts\n"));

/***/ })

});