"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/contact/page",{

/***/ "(app-pages-browser)/./app/components/Navigation.tsx":
/*!***************************************!*\
  !*** ./app/components/Navigation.tsx ***!
  \***************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Navigation)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.3_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_navigation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/navigation */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.3_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/next/dist/api/navigation.js\");\n/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/utils */ \"(app-pages-browser)/./app/lib/utils.ts\");\n/* harmony import */ var _lib_navigation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lib/navigation */ \"(app-pages-browser)/./app/lib/navigation.ts\");\n/* __next_internal_client_entry_do_not_use__ default auto */ var _s = $RefreshSig$();\n\n\n\n\nconst pageOrder = [\n    '/',\n    '/whoami',\n    '/projects',\n    '/writings',\n    '/contact'\n];\nfunction Navigation() {\n    _s();\n    const router = (0,next_navigation__WEBPACK_IMPORTED_MODULE_1__.useRouter)();\n    const pathname = (0,next_navigation__WEBPACK_IMPORTED_MODULE_1__.usePathname)();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"Navigation.useEffect\": ()=>{\n            let currentIndex = pageOrder.indexOf(pathname);\n            if (currentIndex === -1) currentIndex = 0;\n            let isNavigating = false;\n            let lastNavigationTime = 0;\n            const NAVIGATION_COOLDOWN = 250;\n            function shouldEnableNavigation() {\n                const contentElement = document.querySelector('.content-navigation-enabled');\n                return contentElement !== null;\n            }\n            const handleWheel = (0,_lib_utils__WEBPACK_IMPORTED_MODULE_2__.debounce)({\n                \"Navigation.useEffect.handleWheel\": async (event)=>{\n                    if (isNavigating || !shouldEnableNavigation()) return;\n                    const now = Date.now();\n                    if (now - lastNavigationTime < NAVIGATION_COOLDOWN) return;\n                    event.preventDefault();\n                    let targetIndex;\n                    if (event.deltaY > 0) {\n                        targetIndex = (currentIndex + 1) % pageOrder.length;\n                    } else {\n                        targetIndex = (currentIndex - 1 + pageOrder.length) % pageOrder.length;\n                    }\n                    const targetPage = pageOrder[targetIndex];\n                    isNavigating = true;\n                    lastNavigationTime = now;\n                    try {\n                        (0,_lib_navigation__WEBPACK_IMPORTED_MODULE_3__.fadeOutThen)({\n                            \"Navigation.useEffect.handleWheel\": ()=>router.push(targetPage)\n                        }[\"Navigation.useEffect.handleWheel\"]);\n                        currentIndex = targetIndex;\n                    } catch (error) {\n                        console.error('Navigation error:', error);\n                    }\n                    setTimeout({\n                        \"Navigation.useEffect.handleWheel\": ()=>{\n                            isNavigating = false;\n                        }\n                    }[\"Navigation.useEffect.handleWheel\"], 150);\n                }\n            }[\"Navigation.useEffect.handleWheel\"], 30);\n            const handleKeyDown = {\n                \"Navigation.useEffect.handleKeyDown\": async (event)=>{\n                    if (isNavigating || !shouldEnableNavigation()) return;\n                    const now = Date.now();\n                    if (now - lastNavigationTime < NAVIGATION_COOLDOWN) return;\n                    let targetIndex;\n                    switch(event.key){\n                        case 'ArrowDown':\n                        case ' ':\n                            event.preventDefault();\n                            targetIndex = (currentIndex + 1) % pageOrder.length;\n                            break;\n                        case 'ArrowUp':\n                            event.preventDefault();\n                            targetIndex = (currentIndex - 1 + pageOrder.length) % pageOrder.length;\n                            break;\n                        default:\n                            return;\n                    }\n                    const targetPage = pageOrder[targetIndex];\n                    isNavigating = true;\n                    lastNavigationTime = now;\n                    try {\n                        (0,_lib_navigation__WEBPACK_IMPORTED_MODULE_3__.fadeOutThen)({\n                            \"Navigation.useEffect.handleKeyDown\": ()=>router.push(targetPage)\n                        }[\"Navigation.useEffect.handleKeyDown\"]);\n                        currentIndex = targetIndex;\n                    } catch (error) {\n                        console.error('Navigation error:', error);\n                    }\n                    setTimeout({\n                        \"Navigation.useEffect.handleKeyDown\": ()=>{\n                            isNavigating = false;\n                        }\n                    }[\"Navigation.useEffect.handleKeyDown\"], 150);\n                }\n            }[\"Navigation.useEffect.handleKeyDown\"];\n            // Touch navigation\n            let touchStartY = 0;\n            let touchStartX = 0;\n            let touchStartTime = 0;\n            const handleTouchStart = {\n                \"Navigation.useEffect.handleTouchStart\": (event)=>{\n                    if (!shouldEnableNavigation()) return;\n                    const touch = event.changedTouches[0];\n                    touchStartY = touch.screenY;\n                    touchStartX = touch.screenX;\n                    touchStartTime = Date.now();\n                }\n            }[\"Navigation.useEffect.handleTouchStart\"];\n            const handleTouchEnd = (0,_lib_utils__WEBPACK_IMPORTED_MODULE_2__.debounce)({\n                \"Navigation.useEffect.handleTouchEnd\": async (event)=>{\n                    if (isNavigating || !shouldEnableNavigation()) return;\n                    const now = Date.now();\n                    if (now - lastNavigationTime < NAVIGATION_COOLDOWN) return;\n                    const touch = event.changedTouches[0];\n                    const touchEndY = touch.screenY;\n                    const touchEndX = touch.screenX;\n                    const deltaY = touchStartY - touchEndY;\n                    const deltaX = Math.abs(touchStartX - touchEndX);\n                    const touchDuration = Date.now() - touchStartTime;\n                    if (Math.abs(deltaY) < 30 || deltaX > Math.abs(deltaY) || touchDuration > 500 || touchDuration < 30) {\n                        return;\n                    }\n                    event.preventDefault();\n                    let targetIndex;\n                    if (deltaY > 0) {\n                        targetIndex = (currentIndex + 1) % pageOrder.length;\n                    } else {\n                        targetIndex = (currentIndex - 1 + pageOrder.length) % pageOrder.length;\n                    }\n                    const targetPage = pageOrder[targetIndex];\n                    isNavigating = true;\n                    lastNavigationTime = now;\n                    try {\n                        (0,_lib_navigation__WEBPACK_IMPORTED_MODULE_3__.fadeOutThen)({\n                            \"Navigation.useEffect.handleTouchEnd\": ()=>router.push(targetPage)\n                        }[\"Navigation.useEffect.handleTouchEnd\"]);\n                        currentIndex = targetIndex;\n                    } catch (error) {\n                        console.error('Navigation error:', error);\n                    }\n                    setTimeout({\n                        \"Navigation.useEffect.handleTouchEnd\": ()=>{\n                            isNavigating = false;\n                        }\n                    }[\"Navigation.useEffect.handleTouchEnd\"], 150);\n                }\n            }[\"Navigation.useEffect.handleTouchEnd\"], 25);\n            if (shouldEnableNavigation()) {\n                document.addEventListener('wheel', handleWheel, {\n                    passive: false\n                });\n                document.addEventListener('keydown', handleKeyDown);\n                document.addEventListener('touchstart', handleTouchStart, {\n                    passive: true\n                });\n                document.addEventListener('touchend', handleTouchEnd, {\n                    passive: false\n                });\n            }\n            return ({\n                \"Navigation.useEffect\": ()=>{\n                    document.removeEventListener('wheel', handleWheel);\n                    document.removeEventListener('keydown', handleKeyDown);\n                    document.removeEventListener('touchstart', handleTouchStart);\n                    document.removeEventListener('touchend', handleTouchEnd);\n                }\n            })[\"Navigation.useEffect\"];\n        }\n    }[\"Navigation.useEffect\"], [\n        router,\n        pathname\n    ]);\n    return null;\n}\n_s(Navigation, \"o5ZI+SkIudo7k8HXWSgHRZPlXUg=\", false, function() {\n    return [\n        next_navigation__WEBPACK_IMPORTED_MODULE_1__.useRouter,\n        next_navigation__WEBPACK_IMPORTED_MODULE_1__.usePathname\n    ];\n});\n_c = Navigation;\nvar _c;\n$RefreshReg$(_c, \"Navigation\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9jb21wb25lbnRzL05hdmlnYXRpb24udHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFFa0M7QUFDdUI7QUFDakI7QUFDUTtBQUVoRCxNQUFNSyxZQUFZO0lBQUM7SUFBSztJQUFXO0lBQWE7SUFBYTtDQUFXO0FBRXpELFNBQVNDOztJQUN0QixNQUFNQyxTQUFTTiwwREFBU0E7SUFDeEIsTUFBTU8sV0FBV04sNERBQVdBO0lBRTVCRixnREFBU0E7Z0NBQUM7WUFDUixJQUFJUyxlQUFlSixVQUFVSyxPQUFPLENBQUNGO1lBQ3JDLElBQUlDLGlCQUFpQixDQUFDLEdBQUdBLGVBQWU7WUFFeEMsSUFBSUUsZUFBZTtZQUNuQixJQUFJQyxxQkFBcUI7WUFDekIsTUFBTUMsc0JBQXNCO1lBRTVCLFNBQVNDO2dCQUNQLE1BQU1DLGlCQUFpQkMsU0FBU0MsYUFBYSxDQUFDO2dCQUM5QyxPQUFPRixtQkFBbUI7WUFDNUI7WUFFQSxNQUFNRyxjQUFjZixvREFBUUE7b0RBQUMsT0FBT2dCO29CQUNsQyxJQUFJUixnQkFBZ0IsQ0FBQ0csMEJBQTBCO29CQUUvQyxNQUFNTSxNQUFNQyxLQUFLRCxHQUFHO29CQUNwQixJQUFJQSxNQUFNUixxQkFBcUJDLHFCQUFxQjtvQkFFcERNLE1BQU1HLGNBQWM7b0JBRXBCLElBQUlDO29CQUNKLElBQUlKLE1BQU1LLE1BQU0sR0FBRyxHQUFHO3dCQUNwQkQsY0FBYyxDQUFDZCxlQUFlLEtBQUtKLFVBQVVvQixNQUFNO29CQUNyRCxPQUFPO3dCQUNMRixjQUFjLENBQUNkLGVBQWUsSUFBSUosVUFBVW9CLE1BQU0sSUFBSXBCLFVBQVVvQixNQUFNO29CQUN4RTtvQkFFQSxNQUFNQyxhQUFhckIsU0FBUyxDQUFDa0IsWUFBWTtvQkFFekNaLGVBQWU7b0JBQ2ZDLHFCQUFxQlE7b0JBRXJCLElBQUk7d0JBQ0ZoQiw0REFBV0E7Z0VBQUMsSUFBTUcsT0FBT29CLElBQUksQ0FBQ0Q7O3dCQUM5QmpCLGVB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QztvQkFFQUU7K0RBQVc7NEJBQ1RuQixlQUFlO3dCQUNqQjs4REFBRztnQkFDTDtzREFBRztZQUVILElBQUlHLDBCQUEwQjtnQkFDNUJFLFNBQVNnQyxnQkFBZ0IsQ0FBQyxTQUFTOUIsYUFBYTtvQkFBRStCLFNBQVM7Z0JBQU07Z0JBQ2pFakMsU0FBU2dDLGdCQUFnQixDQUFDLFdBQVdqQjtnQkFDckNmLFNBQVNnQyxnQkFBZ0IsQ0FBQyxjQUFjWixrQkFBa0I7b0JBQUVhLFNBQVM7Z0JBQUs7Z0JBQzFFakMsU0FBU2dDLGdCQUFnQixDQUFDLFlBQVlQLGdCQUFnQjtvQkFBRVEsU0FBUztnQkFBTTtZQUN6RTtZQUVBO3dDQUFPO29CQUNMakMsU0FBU2tDLG1CQUFtQixDQUFDLFNBQVNoQztvQkFDdENGLFNBQVNrQyxtQkFBbUIsQ0FBQyxXQUFXbkI7b0JBQ3hDZixTQUFTa0MsbUJBQW1CLENBQUMsY0FBY2Q7b0JBQzNDcEIsU0FBU2tDLG1CQUFtQixDQUFDLFlBQVlUO2dCQUMzQzs7UUFDRjsrQkFBRztRQUFDbEM7UUFBUUM7S0FBUztJQUVyQixPQUFPO0FBQ1Q7R0FwS3dCRjs7UUFDUEwsc0RBQVNBO1FBQ1BDLHdEQUFXQTs7O0tBRk5JIiwic291cmNlcyI6WyIvVXNlcnMveXZlcy9SZXBvc2l0b3JpZXMveXZlc3lpbC54eXovYXBwL2NvbXBvbmVudHMvTmF2aWdhdGlvbi50c3giXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xuXG5pbXBvcnQgeyB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VSb3V0ZXIsIHVzZVBhdGhuYW1lIH0gZnJvbSAnbmV4dC9uYXZpZ2F0aW9uJztcbmltcG9ydCB7IGRlYm91bmNlIH0gZnJvbSAnLi4vbGliL3V0aWxzJztcbmltcG9ydCB7IGZhZGVPdXRUaGVuIH0gZnJvbSAnLi4vbGliL25hdmlnYXRpb24nO1xuXG5jb25zdCBwYWdlT3JkZXIgPSBbJy8nLCAnL3dob2FtaScsICcvcHJvamVjdHMnLCAnL3dyaXRpbmdzJywgJy9jb250YWN0J107XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIE5hdmlnYXRpb24oKSB7XG4gIGNvbnN0IHJvdXRlciA9IHVzZVJvdXRlcigpO1xuICBjb25zdCBwYXRobmFtZSA9IHVzZVBhdGhuYW1lKCk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBsZXQgY3VycmVudEluZGV4ID0gcGFnZU9yZGVyLmluZGV4T2YocGF0aG5hbWUpO1xuICAgIGlmIChjdXJyZW50SW5kZXggPT09IC0xKSBjdXJyZW50SW5kZXggPSAwO1xuXG4gICAgbGV0IGlzTmF2aWdhdGluZyA9IGZhbHNlO1xuICAgIGxldCBsYXN0TmF2aWdhdGlvblRpbWUgPSAwO1xuICAgIGNvbnN0IE5BVklHQVRJT05fQ09PTERPV04gPSAyNTA7XG5cbiAgICBmdW5jdGlvbiBzaG91bGRFbmFibGVOYXZpZ2F0aW9uKCk6IGJvb2xlYW4ge1xuICAgICAgY29uc3QgY29udGVudEVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuY29udGVudC1uYXZpZ2F0aW9uLWVuYWJsZWQnKTtcbiAgICAgIHJldHVybiBjb250ZW50RWxlbWVudCAhPT0gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCBoYW5kbGVXaGVlbCA9IGRlYm91bmNlKGFzeW5jIChldmVudDogV2hlZWxFdmVudCkgPT4ge1xuICAgICAgaWYgKGlzTmF2aWdhdGluZyB8fCAhc2hvdWxkRW5hYmxlTmF2aWdhdGlvbigpKSByZXR1cm47XG4gICAgICBcbiAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICBpZiAobm93IC0gbGFzdE5hdmlnYXRpb25UaW1lIDwgTkFWSUdBVElPTl9DT09MRE9XTikgcmV0dXJuO1xuICAgICAgXG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgXG4gICAgICBsZXQgdGFyZ2V0SW5kZXg6IG51bWJlcjtcbiAgICAgIGlmIChldmVudC5kZWx0YVkgPiAwKSB7XG4gICAgICAgIHRhcmdldEluZGV4ID0gKGN1cnJlbnRJbmRleCArIDEpICUgcGFnZU9yZGVyLmxlbmd0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhcmdldEluZGV4ID0gKGN1cnJlbnRJbmRleCAtIDEgKyBwYWdlT3JkZXIubGVuZ3RoKSAlIHBhZ2VPcmRlci5sZW5ndGg7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IHRhcmdldFBhZ2UgPSBwYWdlT3JkZXJbdGFyZ2V0SW5kZXhdO1xuICAgICAgXG4gICAgICBpc05hdmlnYXRpbmcgPSB0cnVlO1xuICAgICAgbGFzdE5hdmlnYXRpb25UaW1lID0gbm93O1xuICAgICAgXG4gICAgICB0cnkge1xuICAgICAgICBmYWRlT3V0VGhlbigoKSA9PiByb3V0ZXIucHVzaCh0YXJnZXRQYWdlKSk7XG4gICAgICAgIGN1cnJlbnRJbmRleCA9IHRhcmdldEluZGV4O1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignTmF2aWdhdGlvbiBlcnJvcjonLCBlcnJvcik7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpc05hdmlnYXRpbmcgPSBmYWxzZTtcbiAgICAgIH0sIDE1MCk7XG4gICAgfSwgMzApO1xuXG4gICAgY29uc3QgaGFuZGxlS2V5RG93biA9IGFzeW5jIChldmVudDogS2V5Ym9hcmRFdmVudCk6IFByb21pc2U8dm9pZD4gPT4ge1xuICAgICAgaWYgKGlzTmF2aWdhdGluZyB8fCAhc2hvdWxkRW5hYmxlTmF2aWdhdGlvbigpKSByZXR1cm47XG4gICAgICBcbiAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICBpZiAobm93IC0gbGFzdE5hdmlnYXRpb25UaW1lIDwgTkFWSUdBVElPTl9DT09MRE9XTikgcmV0dXJuO1xuICAgICAgXG4gICAgICBsZXQgdGFyZ2V0SW5kZXg6IG51bWJlcjtcbiAgICAgIHN3aXRjaChldmVudC5rZXkpIHtcbiAgICAgICAgY2FzZSAnQXJyb3dEb3duJzpcbiAgICAgICAgY2FzZSAnICc6XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB0YXJnZXRJbmRleCA9IChjdXJyZW50SW5kZXggKyAxKSAlIHBhZ2VPcmRlci5sZW5ndGg7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0Fycm93VXAnOlxuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgdGFyZ2V0SW5kZXggPSAoY3VycmVudEluZGV4IC0gMSArIHBhZ2VPcmRlci5sZW5ndGgpICUgcGFnZU9yZGVyLmxlbmd0aDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IHRhcmdldFBhZ2UgPSBwYWdlT3JkZXJbdGFyZ2V0SW5kZXhdO1xuICAgICAgXG4gICAgICBpc05hdmlnYXRpbmcgPSB0cnVlO1xuICAgICAgbGFzdE5hdmlnYXRpb25UaW1lID0gbm93O1xuICAgICAgXG4gICAgICB0cnkge1xuICAgICAgICBmYWRlT3V0VGhlbigoKSA9PiByb3V0ZXIucHVzaCh0YXJnZXRQYWdlKSk7XG4gICAgICAgIGN1cnJlbnRJbmRleCA9IHRhcmdldEluZGV4O1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignTmF2aWdhdGlvbiBlcnJvcjonLCBlcnJvcik7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpc05hdmlnYXRpbmcgPSBmYWxzZTtcbiAgICAgIH0sIDE1MCk7XG4gICAgfTtcblxuICAgIC8vIFRvdWNoIG5hdmlnYXRpb25cbiAgICBsZXQgdG91Y2hTdGFydFkgPSAwO1xuICAgIGxldCB0b3VjaFN0YXJ0WCA9IDA7XG4gICAgbGV0IHRvdWNoU3RhcnRUaW1lID0gMDtcblxuICAgIGNvbnN0IGhhbmRsZVRvdWNoU3RhcnQgPSAoZXZlbnQ6IFRvdWNoRXZlbnQpOiB2b2lkID0+IHtcbiAgICAgIGlmICghc2hvdWxkRW5hYmxlTmF2aWdhdGlvbigpKSByZXR1cm47XG4gICAgICBcbiAgICAgIGNvbnN0IHRvdWNoID0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF07XG4gICAgICB0b3VjaFN0YXJ0WSA9IHRvdWNoLnNjcmVlblk7XG4gICAgICB0b3VjaFN0YXJ0WCA9IHRvdWNoLnNjcmVlblg7XG4gICAgICB0b3VjaFN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgfTtcblxuICAgIGNvbnN0IGhhbmRsZVRvdWNoRW5kID0gZGVib3VuY2UoYXN5bmMgKGV2ZW50OiBUb3VjaEV2ZW50KSA9PiB7XG4gICAgICBpZiAoaXNOYXZpZ2F0aW5nIHx8ICFzaG91bGRFbmFibGVOYXZpZ2F0aW9uKCkpIHJldHVybjtcbiAgICAgIFxuICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgIGlmIChub3cgLSBsYXN0TmF2aWdhdGlvblRpbWUgPCBOQVZJR0FUSU9OX0NPT0xET1dOKSByZXR1cm47XG4gICAgICBcbiAgICAgIGNvbnN0IHRvdWNoID0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF07XG4gICAgICBjb25zdCB0b3VjaEVuZFkgPSB0b3VjaC5zY3JlZW5ZO1xuICAgICAgY29uc3QgdG91Y2hFbmRYID0gdG91Y2guc2NyZWVuWDtcbiAgICAgIFxuICAgICAgY29uc3QgZGVsdGFZID0gdG91Y2hTdGFydFkgLSB0b3VjaEVuZFk7XG4gICAgICBjb25zdCBkZWx0YVggPSBNYXRoLmFicyh0b3VjaFN0YXJ0WCAtIHRvdWNoRW5kWCk7XG4gICAgICBjb25zdCB0b3VjaER1cmF0aW9uID0gRGF0ZS5ub3coKSAtIHRvdWNoU3RhcnRUaW1lO1xuICAgICAgXG4gICAgICBpZiAoTWF0aC5hYnMoZGVsdGFZKSA8IDMwIHx8IFxuICAgICAgICAgIGRlbHRhWCA+IE1hdGguYWJzKGRlbHRhWSkgfHwgXG4gICAgICAgICAgdG91Y2hEdXJhdGlvbiA+IDUwMCB8fCBcbiAgICAgICAgICB0b3VjaER1cmF0aW9uIDwgMzApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgXG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgXG4gICAgICBsZXQgdGFyZ2V0SW5kZXg6IG51bWJlcjtcbiAgICAgIGlmIChkZWx0YVkgPiAwKSB7XG4gICAgICAgIHRhcmdldEluZGV4ID0gKGN1cnJlbnRJbmRleCArIDEpICUgcGFnZU9yZGVyLmxlbmd0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhcmdldEluZGV4ID0gKGN1cnJlbnRJbmRleCAtIDEgKyBwYWdlT3JkZXIubGVuZ3RoKSAlIHBhZ2VPcmRlci5sZW5ndGg7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IHRhcmdldFBhZ2UgPSBwYWdlT3JkZXJbdGFyZ2V0SW5kZXhdO1xuICAgICAgXG4gICAgICBpc05hdmlnYXRpbmcgPSB0cnVlO1xuICAgICAgbGFzdE5hdmlnYXRpb25UaW1lID0gbm93O1xuICAgICAgXG4gICAgICB0cnkge1xuICAgICAgICBmYWRlT3V0VGhlbigoKSA9PiByb3V0ZXIucHVzaCh0YXJnZXRQYWdlKSk7XG4gICAgICAgIGN1cnJlbnRJbmRleCA9IHRhcmdldEluZGV4O1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignTmF2aWdhdGlvbiBlcnJvcjonLCBlcnJvcik7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpc05hdmlnYXRpbmcgPSBmYWxzZTtcbiAgICAgIH0sIDE1MCk7XG4gICAgfSwgMjUpO1xuXG4gICAgaWYgKHNob3VsZEVuYWJsZU5hdmlnYXRpb24oKSkge1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignd2hlZWwnLCBoYW5kbGVXaGVlbCwgeyBwYXNzaXZlOiBmYWxzZSB9KTtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBoYW5kbGVLZXlEb3duKTtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBoYW5kbGVUb3VjaFN0YXJ0LCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIGhhbmRsZVRvdWNoRW5kLCB7IHBhc3NpdmU6IGZhbHNlIH0pO1xuICAgIH1cblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd3aGVlbCcsIGhhbmRsZVdoZWVsKTtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBoYW5kbGVLZXlEb3duKTtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBoYW5kbGVUb3VjaFN0YXJ0KTtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgaGFuZGxlVG91Y2hFbmQpO1xuICAgIH07XG4gIH0sIFtyb3V0ZXIsIHBhdGhuYW1lXSk7XG5cbiAgcmV0dXJuIG51bGw7XG59XG4iXSwibmFtZXMiOlsidXNlRWZmZWN0IiwidXNlUm91dGVyIiwidXNlUGF0aG5hbWUiLCJkZWJvdW5jZSIsImZhZGVPdXRUaGVuIiwicGFnZU9yZGVyIiwiTmF2aWdhdGlvbiIsInJvdXRlciIsInBhdGhuYW1lIiwiY3VycmVudEluZGV4IiwiaW5kZXhPZiIsImlzTmF2aWdhdGluZyIsImxhc3ROYXZpZ2F0aW9uVGltZSIsIk5BVklHQVRJT05fQ09PTERPV04iLCJzaG91bGRFbmFibGVOYXZpZ2F0aW9uIiwiY29udGVudEVsZW1lbnQiLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3IiLCJoYW5kbGVXaGVlbCIsImV2ZW50Iiwibm93IiwiRGF0ZSIsInByZXZlbnREZWZhdWx0IiwidGFyZ2V0SW5kZXgiLCJkZWx0YVkiLCJsZW5ndGgiLCJ0YXJnZXRQYWdlIiwicHVzaCIsImVycm9yIiwiY29uc29sZSIsInNldFRpbWVvdXQiLCJoYW5kbGVLZXlEb3duIiwia2V5IiwidG91Y2hTdGFydFkiLCJ0b3VjaFN0YXJ0WCIsInRvdWNoU3RhcnRUaW1lIiwiaGFuZGxlVG91Y2hTdGFydCIsInRvdWNoIiwiY2hhbmdlZFRvdWNoZXMiLCJzY3JlZW5ZIiwic2NyZWVuWCIsImhhbmRsZVRvdWNoRW5kIiwidG91Y2hFbmRZIiwidG91Y2hFbmRYIiwiZGVsdGFYIiwiTWF0aCIsImFicyIsInRvdWNoRHVyYXRpb24iLCJhZGRFdmVudExpc3RlbmVyIiwicGFzc2l2ZSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/components/Navigation.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/lib/navigation.ts":
/*!*******************************!*\
  !*** ./app/lib/navigation.ts ***!
  \*******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cleanupNavigation: () => (/* binding */ cleanupNavigation),\n/* harmony export */   fadeOutThen: () => (/* binding */ fadeOutThen),\n/* harmony export */   initializeNavigation: () => (/* binding */ initializeNavigation)\n/* harmony export */ });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ \"(app-pages-browser)/./app/lib/utils.ts\");\nfunction fadeOutThen(navigate) {\n    let durationMs = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 250;\n    const container = document.querySelector('.page-content');\n    if (!container) {\n        navigate();\n        return;\n    }\n    container.style.transition = 'opacity 250ms ease-in-out';\n    container.style.opacity = '1';\n    // Force reflow to apply transition consistently\n    void container.offsetHeight;\n    container.style.opacity = '0';\n    setTimeout(()=>{\n        navigate();\n    }, durationMs);\n}\n\n// Page navigation order\nconst pageOrder = [\n    '/',\n    '/whoami',\n    '/projects',\n    '/writings',\n    '/contact'\n];\nlet currentIndex = 0;\nlet isNavigating = false;\nlet listenersAttached = false;\nlet lastNavigationTime = 0;\nconst NAVIGATION_COOLDOWN = 250;\n// Function to check if current page should have scroll navigation\nfunction shouldEnableNavigation() {\n    if (false) {}\n    const contentElement = document.querySelector('.content-navigation-enabled');\n    return contentElement !== null;\n}\n// Function to update current index based on current path\nfunction updateCurrentIndex() {\n    if (false) {}\n    const currentPath = window.location.pathname;\n    const index = pageOrder.indexOf(currentPath);\n    currentIndex = index !== -1 ? index : 0;\n}\n// Navigation function using Next.js router\nfunction navigateToPage(targetPage) {\n    if (false) {}\n    // Use Next.js client-side navigation\n    window.location.href = targetPage;\n}\n// Handle wheel events for scroll navigation\nconst handleWheel = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.debounce)(async (event)=>{\n    if (isNavigating || !shouldEnableNavigation()) return;\n    const now = Date.now();\n    if (now - lastNavigationTime < NAVIGATION_COOLDOWN) return;\n    event.preventDefault();\n    let targetIndex;\n    if (event.deltaY > 0) {\n        targetIndex = (currentIndex + 1) % pageOrder.length;\n    } else {\n        targetIndex = (currentIndex - 1 + pageOrder.length) % pageOrder.length;\n    }\n    const targetPage = pageOrder[targetIndex];\n    isNavigating = true;\n    lastNavigationTime = now;\n    try {\n        navigateToPage(targetPage);\n    } catch (error) {\n        console.error('Navigation error:', error);\n    }\n    setTimeout(()=>{\n        isNavigating = false;\n    }, 150);\n}, 30);\n// Handle touch events for mobile\nlet touchStartY = 0;\nlet touchEndY = 0;\nlet touchStartX = 0;\nlet touchEndX = 0;\nlet touchStartTime = 0;\nconst handleTouchStart = (event)=>{\n    if (!shouldEnableNavigation()) return;\n    const touch = event.changedTouches[0];\n    touchStartY = touch.screenY;\n    touchStartX = touch.screenX;\n    touchStartTime = Date.now();\n};\nconst handleTouchEnd = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.debounce)(async (event)=>{\n    if (isNavigating || !shouldEnableNavigation()) return;\n    const now = Date.now();\n    if (now - lastNavigationTime < NAVIGATION_COOLDOWN) return;\n    const touch = event.changedTouches[0];\n    touchEndY = touch.screenY;\n    touchEndX = touch.screenX;\n    const deltaY = touchStartY - touchEndY;\n    const deltaX = Math.abs(touchStartX - touchEndX);\n    const touchDuration = Date.now() - touchStartTime;\n    if (Math.abs(deltaY) < 30 || deltaX > Math.abs(deltaY) || touchDuration > 500 || touchDuration < 30) {\n        return;\n    }\n    event.preventDefault();\n    let targetIndex;\n    if (deltaY > 0) {\n        targetIndex = (currentIndex + 1) % pageOrder.length;\n    } else {\n        targetIndex = (currentIndex - 1 + pageOrder.length) % pageOrder.length;\n    }\n    const targetPage = pageOrder[targetIndex];\n    isNavigating = true;\n    lastNavigationTime = now;\n    try {\n        navigateToPage(targetPage);\n    } catch (error) {\n        console.error('Navigation error:', error);\n    }\n    setTimeout(()=>{\n        isNavigating = false;\n    }, 150);\n}, 25);\n// Handle keyboard navigation\nconst handleKeyDown = async (event)=>{\n    if (isNavigating || !shouldEnableNavigation()) return;\n    const now = Date.now();\n    if (now - lastNavigationTime < NAVIGATION_COOLDOWN) return;\n    let targetIndex;\n    switch(event.key){\n        case 'ArrowDown':\n        case ' ':\n            event.preventDefault();\n            targetIndex = (currentIndex + 1) % pageOrder.length;\n            break;\n        case 'ArrowUp':\n            event.preventDefault();\n            targetIndex = (currentIndex - 1 + pageOrder.length) % pageOrder.length;\n            break;\n        default:\n            return;\n    }\n    const targetPage = pageOrder[targetIndex];\n    isNavigating = true;\n    lastNavigationTime = now;\n    try {\n        navigateToPage(targetPage);\n    } catch (error) {\n        console.error('Navigation error:', error);\n    }\n    setTimeout(()=>{\n        isNavigating = false;\n    }, 150);\n};\n// Function to attach event listeners\nfunction attachListeners() {\n    if (typeof document === 'undefined' || listenersAttached) return;\n    document.addEventListener('wheel', handleWheel, {\n        passive: false\n    });\n    document.addEventListener('touchstart', handleTouchStart, {\n        passive: true\n    });\n    document.addEventListener('touchend', handleTouchEnd, {\n        passive: false\n    });\n    document.addEventListener('keydown', handleKeyDown);\n    listenersAttached = true;\n}\n// Function to remove event listeners\nfunction removeListeners() {\n    if (typeof document === 'undefined' || !listenersAttached) return;\n    document.removeEventListener('wheel', handleWheel);\n    document.removeEventListener('touchstart', handleTouchStart);\n    document.removeEventListener('touchend', handleTouchEnd);\n    document.removeEventListener('keydown', handleKeyDown);\n    listenersAttached = false;\n}\n// Function to initialize navigation\nfunction initializeNavigation() {\n    if (false) {}\n    updateCurrentIndex();\n    if (shouldEnableNavigation()) {\n        attachListeners();\n    } else {\n        removeListeners();\n    }\n}\n// Clean up function\nfunction cleanupNavigation() {\n    removeListeners();\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9saWIvbmF2aWdhdGlvbi50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQU8sU0FBU0EsWUFBWUMsUUFBb0I7UUFBRUMsYUFBQUEsaUVBQWE7SUFDN0QsTUFBTUMsWUFBWUMsU0FBU0MsYUFBYSxDQUFDO0lBQ3pDLElBQUksQ0FBQ0YsV0FBVztRQUNkRjtRQUNBO0lBQ0Y7SUFFQUUsVUFBVUcsS0FBSyxDQUFDQyxVQUFVLEdBQUc7SUFDN0JKLFVBQVVHLEtBQUssQ0FBQ0UsT0FBTyxHQUFHO0lBRTFCLGdEQUFnRDtJQUNoRCxLQUFLTCxVQUFVTSxZQUFZO0lBRTNCTixVQUFVRyxLQUFLLENBQUNFLE9BQU8sR0FBRztJQUMxQkUsV0FBVztRQUNUVDtJQUNGLEdBQUdDO0FBQ0w7QUFFbUM7QUFFbkMsd0JBQXdCO0FBQ3hCLE1BQU1VLFlBQVk7SUFBQztJQUFLO0lBQVc7SUFBYTtJQUFhO0NBQVc7QUFFeEUsSUFBSUMsZUFBZTtBQUNuQixJQUFJQyxlQUFlO0FBQ25CLElBQUlDLG9CQUFvQjtBQUN4QixJQUFJQyxxQkFBcUI7QUFDekIsTUFBTUMsc0JBQXNCO0FBRTVCLGtFQUFrRTtBQUNsRSxTQUFTQztJQUNQLElBQUksS0FBNkIsRUFBRSxFQUFhO0lBQ2hELE1BQU1DLGlCQUFpQmYsU0FBU0MsYUFBYSxDQUFDO0lBQzlDLE9BQU9jLG1CQUFtQjtBQUM1QjtBQUVBLHlEQUF5RDtBQUN6RCxTQUFTQztJQUNQLElBQUksS0FBNkIsRUFBRSxFQUFPO0lBQzFDLE1BQU1DLGNBQWNDLE9BQU9DLFFBQVEsQ0FBQ0MsUUFBUTtJQUM1QyxNQUFNQyxRQUFRYixVQUFVYyxPQUFPLENBQUNMO0lBQ2hDUixlQUFlWSxVQUFVLENBQUMsSUFBSUEsUUFBUTtBQUN4QztBQUVBLDJDQUEyQztBQUMzQyxTQUFTRSxlQUFlQyxVQUFrQjtJQUN4QyxJQUFJLEtBQTZCLEVBQUUsRUFBTztJQUUxQyxxQ0FBcUM7SUFDckNOLE9BQU9DLFFBQVEsQ0FB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O0lBRTFDMUM7SUFFQSxJQUFJRiwwQkFBMEI7UUFDNUJ1QztJQUNGLE9BQU87UUFDTEc7SUFDRjtBQUNGO0FBRUEsb0JBQW9CO0FBQ2IsU0FBU0c7SUFDZEg7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL3l2ZXMvUmVwb3NpdG9yaWVzL3l2ZXN5aWwueHl6L2FwcC9saWIvbmF2aWdhdGlvbi50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gZmFkZU91dFRoZW4obmF2aWdhdGU6ICgpID0+IHZvaWQsIGR1cmF0aW9uTXMgPSAyNTApIHtcbiAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnBhZ2UtY29udGVudCcpIGFzIEhUTUxFbGVtZW50IHwgbnVsbFxuICBpZiAoIWNvbnRhaW5lcikge1xuICAgIG5hdmlnYXRlKClcbiAgICByZXR1cm5cbiAgfVxuXG4gIGNvbnRhaW5lci5zdHlsZS50cmFuc2l0aW9uID0gJ29wYWNpdHkgMjUwbXMgZWFzZS1pbi1vdXQnXG4gIGNvbnRhaW5lci5zdHlsZS5vcGFjaXR5ID0gJzEnXG5cbiAgLy8gRm9yY2UgcmVmbG93IHRvIGFwcGx5IHRyYW5zaXRpb24gY29uc2lzdGVudGx5XG4gIHZvaWQgY29udGFpbmVyLm9mZnNldEhlaWdodFxuXG4gIGNvbnRhaW5lci5zdHlsZS5vcGFjaXR5ID0gJzAnXG4gIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIG5hdmlnYXRlKClcbiAgfSwgZHVyYXRpb25Ncylcbn1cblxuaW1wb3J0IHsgZGVib3VuY2UgfSBmcm9tICcuL3V0aWxzJztcblxuLy8gUGFnZSBuYXZpZ2F0aW9uIG9yZGVyXG5jb25zdCBwYWdlT3JkZXIgPSBbJy8nLCAnL3dob2FtaScsICcvcHJvamVjdHMnLCAnL3dyaXRpbmdzJywgJy9jb250YWN0J107XG5cbmxldCBjdXJyZW50SW5kZXggPSAwO1xubGV0IGlzTmF2aWdhdGluZyA9IGZhbHNlO1xubGV0IGxpc3RlbmVyc0F0dGFjaGVkID0gZmFsc2U7XG5sZXQgbGFzdE5hdmlnYXRpb25UaW1lID0gMDtcbmNvbnN0IE5BVklHQVRJT05fQ09PTERPV04gPSAyNTA7XG5cbi8vIEZ1bmN0aW9uIHRvIGNoZWNrIGlmIGN1cnJlbnQgcGFnZSBzaG91bGQgaGF2ZSBzY3JvbGwgbmF2aWdhdGlvblxuZnVuY3Rpb24gc2hvdWxkRW5hYmxlTmF2aWdhdGlvbigpOiBib29sZWFuIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IGNvbnRlbnRFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmNvbnRlbnQtbmF2aWdhdGlvbi1lbmFibGVkJyk7XG4gIHJldHVybiBjb250ZW50RWxlbWVudCAhPT0gbnVsbDtcbn1cblxuLy8gRnVuY3Rpb24gdG8gdXBkYXRlIGN1cnJlbnQgaW5kZXggYmFzZWQgb24gY3VycmVudCBwYXRoXG5mdW5jdGlvbiB1cGRhdGVDdXJyZW50SW5kZXgoKTogdm9pZCB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuO1xuICBjb25zdCBjdXJyZW50UGF0aCA9IHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZTtcbiAgY29uc3QgaW5kZXggPSBwYWdlT3JkZXIuaW5kZXhPZihjdXJyZW50UGF0aCk7XG4gIGN1cnJlbnRJbmRleCA9IGluZGV4ICE9PSAtMSA/IGluZGV4IDogMDtcbn1cblxuLy8gTmF2aWdhdGlvbiBmdW5jdGlvbiB1c2luZyBOZXh0LmpzIHJvdXRlclxuZnVuY3Rpb24gbmF2aWdhdGVUb1BhZ2UodGFyZ2V0UGFnZTogc3RyaW5nKTogdm9pZCB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuO1xuICBcbiAgLy8gVXNlIE5leHQuanMgY2xpZW50LXNpZGUgbmF2aWdhdGlvblxuICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IHRhcmdldFBhZ2U7XG59XG5cbi8vIEhhbmRsZSB3aGVlbCBldmVudHMgZm9yIHNjcm9sbCBuYXZpZ2F0aW9uXG5jb25zdCBoYW5kbGVXaGVlbCA9IGRlYm91bmNlKGFzeW5jIChldmVudDogV2hlZWxFdmVudCkgPT4ge1xuICBpZiAoaXNOYXZpZ2F0aW5nIHx8ICFzaG91bGRFbmFibGVOYXZpZ2F0aW9uKCkpIHJldHVybjtcbiAgXG4gIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gIGlmIChub3cgLSBsYXN0TmF2aWdhdGlvblRpbWUgPCBOQVZJR0FUSU9OX0NPT0xET1dOKSByZXR1cm47XG4gIFxuICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICBcbiAgbGV0IHRhcmdldEluZGV4OiBudW1iZXI7XG4gIGlmIChldmVudC5kZWx0YVkgPiAwKSB7XG4gICAgdGFyZ2V0SW5kZXggPSAoY3VycmVudEluZGV4ICsgMSkgJSBwYWdlT3JkZXIubGVuZ3RoO1xuICB9IGVsc2Uge1xuICAgIHRhcmdldEluZGV4ID0gKGN1cnJlbnRJbmRleCAtIDEgKyBwYWdlT3JkZXIubGVuZ3RoKSAlIHBhZ2VPcmRlci5sZW5ndGg7XG4gIH1cbiAgXG4gIGNvbnN0IHRhcmdldFBhZ2UgPSBwYWdlT3JkZXJbdGFyZ2V0SW5kZXhdO1xuICBcbiAgaXNOYXZpZ2F0aW5nID0gdHJ1ZTtcbiAgbGFzdE5hdmlnYXRpb25UaW1lID0gbm93O1xuICBcbiAgdHJ5IHtcbiAgICBuYXZpZ2F0ZVRvUGFnZSh0YXJnZXRQYWdlKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdOYXZpZ2F0aW9uIGVycm9yOicsIGVycm9yKTtcbiAgfVxuICBcbiAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgaXNOYXZpZ2F0aW5nID0gZmFsc2U7XG4gIH0sIDE1MCk7XG59LCAzMCk7XG5cbi8vIEhhbmRsZSB0b3VjaCBldmVudHMgZm9yIG1vYmlsZVxubGV0IHRvdWNoU3RhcnRZID0gMDtcbmxldCB0b3VjaEVuZFkgPSAwO1xubGV0IHRvdWNoU3RhcnRYID0gMDtcbmxldCB0b3VjaEVuZFggPSAwO1xubGV0IHRvdWNoU3RhcnRUaW1lID0gMDtcblxuY29uc3QgaGFuZGxlVG91Y2hTdGFydCA9IChldmVudDogVG91Y2hFdmVudCk6IHZvaWQgPT4ge1xuICBpZiAoIXNob3VsZEVuYWJsZU5hdmlnYXRpb24oKSkgcmV0dXJuO1xuICBcbiAgY29uc3QgdG91Y2ggPSBldmVudC5jaGFuZ2VkVG91Y2hlc1swXTtcbiAgdG91Y2hTdGFydFkgPSB0b3VjaC5zY3JlZW5ZO1xuICB0b3VjaFN0YXJ0WCA9IHRvdWNoLnNjcmVlblg7XG4gIHRvdWNoU3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbn07XG5cbmNvbnN0IGhhbmRsZVRvdWNoRW5kID0gZGVib3VuY2UoYXN5bmMgKGV2ZW50OiBUb3VjaEV2ZW50KSA9PiB7XG4gIGlmIChpc05hdmlnYXRpbmcgfHwgIXNob3VsZEVuYWJsZU5hdmlnYXRpb24oKSkgcmV0dXJuO1xuICBcbiAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgaWYgKG5vdyAtIGxhc3ROYXZpZ2F0aW9uVGltZSA8IE5BVklHQVRJT05fQ09PTERPV04pIHJldHVybjtcbiAgXG4gIGNvbnN0IHRvdWNoID0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF07XG4gIHRvdWNoRW5kWSA9IHRvdWNoLnNjcmVlblk7XG4gIHRvdWNoRW5kWCA9IHRvdWNoLnNjcmVlblg7XG4gIFxuICBjb25zdCBkZWx0YVkgPSB0b3VjaFN0YXJ0WSAtIHRvdWNoRW5kWTtcbiAgY29uc3QgZGVsdGFYID0gTWF0aC5hYnModG91Y2hTdGFydFggLSB0b3VjaEVuZFgpO1xuICBjb25zdCB0b3VjaER1cmF0aW9uID0gRGF0ZS5ub3coKSAtIHRvdWNoU3RhcnRUaW1lO1xuICBcbiAgaWYgKE1hdGguYWJzKGRlbHRhWSkgPCAzMCB8fCBcbiAgICAgIGRlbHRhWCA+IE1hdGguYWJzKGRlbHRhWSkgfHwgXG4gICAgICB0b3VjaER1cmF0aW9uID4gNTAwIHx8IFxuICAgICAgdG91Y2hEdXJhdGlvbiA8IDMwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIFxuICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICBcbiAgbGV0IHRhcmdldEluZGV4OiBudW1iZXI7XG4gIGlmIChkZWx0YVkgPiAwKSB7XG4gICAgdGFyZ2V0SW5kZXggPSAoY3VycmVudEluZGV4ICsgMSkgJSBwYWdlT3JkZXIubGVuZ3RoO1xuICB9IGVsc2Uge1xuICAgIHRhcmdldEluZGV4ID0gKGN1cnJlbnRJbmRleCAtIDEgKyBwYWdlT3JkZXIubGVuZ3RoKSAlIHBhZ2VPcmRlci5sZW5ndGg7XG4gIH1cbiAgXG4gIGNvbnN0IHRhcmdldFBhZ2UgPSBwYWdlT3JkZXJbdGFyZ2V0SW5kZXhdO1xuICBcbiAgaXNOYXZpZ2F0aW5nID0gdHJ1ZTtcbiAgbGFzdE5hdmlnYXRpb25UaW1lID0gbm93O1xuICBcbiAgdHJ5IHtcbiAgICBuYXZpZ2F0ZVRvUGFnZSh0YXJnZXRQYWdlKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdOYXZpZ2F0aW9uIGVycm9yOicsIGVycm9yKTtcbiAgfVxuICBcbiAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgaXNOYXZpZ2F0aW5nID0gZmFsc2U7XG4gIH0sIDE1MCk7XG59LCAyNSk7XG5cbi8vIEhhbmRsZSBrZXlib2FyZCBuYXZpZ2F0aW9uXG5jb25zdCBoYW5kbGVLZXlEb3duID0gYXN5bmMgKGV2ZW50OiBLZXlib2FyZEV2ZW50KTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gIGlmIChpc05hdmlnYXRpbmcgfHwgIXNob3VsZEVuYWJsZU5hdmlnYXRpb24oKSkgcmV0dXJuO1xuICBcbiAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgaWYgKG5vdyAtIGxhc3ROYXZpZ2F0aW9uVGltZSA8IE5BVklHQVRJT05fQ09PTERPV04pIHJldHVybjtcbiAgXG4gIGxldCB0YXJnZXRJbmRleDogbnVtYmVyO1xuICBzd2l0Y2goZXZlbnQua2V5KSB7XG4gICAgY2FzZSAnQXJyb3dEb3duJzpcbiAgICBjYXNlICcgJzpcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB0YXJnZXRJbmRleCA9IChjdXJyZW50SW5kZXggKyAxKSAlIHBhZ2VPcmRlci5sZW5ndGg7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdBcnJvd1VwJzpcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB0YXJnZXRJbmRleCA9IChjdXJyZW50SW5kZXggLSAxICsgcGFnZU9yZGVyLmxlbmd0aCkgJSBwYWdlT3JkZXIubGVuZ3RoO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybjtcbiAgfVxuICBcbiAgY29uc3QgdGFyZ2V0UGFnZSA9IHBhZ2VPcmRlclt0YXJnZXRJbmRleF07XG4gIFxuICBpc05hdmlnYXRpbmcgPSB0cnVlO1xuICBsYXN0TmF2aWdhdGlvblRpbWUgPSBub3c7XG4gIFxuICB0cnkge1xuICAgIG5hdmlnYXRlVG9QYWdlKHRhcmdldFBhZ2UpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ05hdmlnYXRpb24gZXJyb3I6JywgZXJyb3IpO1xuICB9XG4gIFxuICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICBpc05hdmlnYXRpbmcgPSBmYWxzZTtcbiAgfSwgMTUwKTtcbn07XG5cbi8vIEZ1bmN0aW9uIHRvIGF0dGFjaCBldmVudCBsaXN0ZW5lcnNcbmZ1bmN0aW9uIGF0dGFjaExpc3RlbmVycygpOiB2b2lkIHtcbiAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcgfHwgbGlzdGVuZXJzQXR0YWNoZWQpIHJldHVybjtcbiAgXG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3doZWVsJywgaGFuZGxlV2hlZWwsIHsgcGFzc2l2ZTogZmFsc2UgfSk7XG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBoYW5kbGVUb3VjaFN0YXJ0LCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgaGFuZGxlVG91Y2hFbmQsIHsgcGFzc2l2ZTogZmFsc2UgfSk7XG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBoYW5kbGVLZXlEb3duKTtcbiAgXG4gIGxpc3RlbmVyc0F0dGFjaGVkID0gdHJ1ZTtcbn1cblxuLy8gRnVuY3Rpb24gdG8gcmVtb3ZlIGV2ZW50IGxpc3RlbmVyc1xuZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXJzKCk6IHZvaWQge1xuICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJyB8fCAhbGlzdGVuZXJzQXR0YWNoZWQpIHJldHVybjtcbiAgXG4gIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3doZWVsJywgaGFuZGxlV2hlZWwpO1xuICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgaGFuZGxlVG91Y2hTdGFydCk7XG4gIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgaGFuZGxlVG91Y2hFbmQpO1xuICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgaGFuZGxlS2V5RG93bik7XG4gIFxuICBsaXN0ZW5lcnNBdHRhY2hlZCA9IGZhbHNlO1xufVxuXG4vLyBGdW5jdGlvbiB0byBpbml0aWFsaXplIG5hdmlnYXRpb25cbmV4cG9ydCBmdW5jdGlvbiBpbml0aWFsaXplTmF2aWdhdGlvbigpOiB2b2lkIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm47XG4gIFxuICB1cGRhdGVDdXJyZW50SW5kZXgoKTtcbiAgXG4gIGlmIChzaG91bGRFbmFibGVOYXZpZ2F0aW9uKCkpIHtcbiAgICBhdHRhY2hMaXN0ZW5lcnMoKTtcbiAgfSBlbHNlIHtcbiAgICByZW1vdmVMaXN0ZW5lcnMoKTtcbiAgfVxufVxuXG4vLyBDbGVhbiB1cCBmdW5jdGlvblxuZXhwb3J0IGZ1bmN0aW9uIGNsZWFudXBOYXZpZ2F0aW9uKCk6IHZvaWQge1xuICByZW1vdmVMaXN0ZW5lcnMoKTtcbn1cbiJdLCJuYW1lcyI6WyJmYWRlT3V0VGhlbiIsIm5hdmlnYXRlIiwiZHVyYXRpb25NcyIsImNvbnRhaW5lciIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvciIsInN0eWxlIiwidHJhbnNpdGlvbiIsIm9wYWNpdHkiLCJvZmZzZXRIZWlnaHQiLCJzZXRUaW1lb3V0IiwiZGVib3VuY2UiLCJwYWdlT3JkZXIiLCJjdXJyZW50SW5kZXgiLCJpc05hdmlnYXRpbmciLCJsaXN0ZW5lcnNBdHRhY2hlZCIsImxhc3ROYXZpZ2F0aW9uVGltZSIsIk5BVklHQVRJT05fQ09PTERPV04iLCJzaG91bGRFbmFibGVOYXZpZ2F0aW9uIiwiY29udGVudEVsZW1lbnQiLCJ1cGRhdGVDdXJyZW50SW5kZXgiLCJjdXJyZW50UGF0aCIsIndpbmRvdyIsImxvY2F0aW9uIiwicGF0aG5hbWUiLCJpbmRleCIsImluZGV4T2YiLCJuYXZpZ2F0ZVRvUGFnZSIsInRhcmdldFBhZ2UiLCJocmVmIiwiaGFuZGxlV2hlZWwiLCJldmVudCIsIm5vdyIsIkRhdGUiLCJwcmV2ZW50RGVmYXVsdCIsInRhcmdldEluZGV4IiwiZGVsdGFZIiwibGVuZ3RoIiwiZXJyb3IiLCJjb25zb2xlIiwidG91Y2hTdGFydFkiLCJ0b3VjaEVuZFkiLCJ0b3VjaFN0YXJ0WCIsInRvdWNoRW5kWCIsInRvdWNoU3RhcnRUaW1lIiwiaGFuZGxlVG91Y2hTdGFydCIsInRvdWNoIiwiY2hhbmdlZFRvdWNoZXMiLCJzY3JlZW5ZIiwic2NyZWVuWCIsImhhbmRsZVRvdWNoRW5kIiwiZGVsdGFYIiwiTWF0aCIsImFicyIsInRvdWNoRHVyYXRpb24iLCJoYW5kbGVLZXlEb3duIiwia2V5IiwiYXR0YWNoTGlzdGVuZXJzIiwiYWRkRXZlbnRMaXN0ZW5lciIsInBhc3NpdmUiLCJyZW1vdmVMaXN0ZW5lcnMiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiaW5pdGlhbGl6ZU5hdmlnYXRpb24iLCJjbGVhbnVwTmF2aWdhdGlvbiJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/lib/navigation.ts\n"));

/***/ })

});