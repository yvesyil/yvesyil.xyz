"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_app-pages-browser_app_lib_fluid_ts",{

/***/ "(app-pages-browser)/./app/lib/fluid.ts":
/*!**************************!*\
  !*** ./app/lib/fluid.ts ***!
  \**************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cleanupFluidSimulation: function() { return /* binding */ cleanupFluidSimulation; },\n/* harmony export */   initFluidSimulation: function() { return /* binding */ initFluidSimulation; }\n/* harmony export */ });\n// Working Fluid Simulation for Next.js\n// Simplified but effective implementation that recreates the original look\nlet fluidInitialized = false;\nlet canvas = null;\nlet ctx = null;\n// Fluid state\nlet trails = [];\nlet mouseX = 0;\nlet mouseY = 0;\nlet lastMouseX = 0;\nlet lastMouseY = 0;\nlet animationId = null;\n// Configuration matching original\nconst config = {\n    maxTrails: 200,\n    trailLife: 120,\n    fadeRate: 0.98,\n    splatRadius: 25,\n    velocityMultiplier: 0.3,\n    colorIntensity: 0.8,\n    grainAmount: 0.02\n};\nfunction generateColor() {\n    let intensity = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;\n    // Colors similar to original: red/orange tones\n    const hue = Math.random() * 60; // 0-60 degrees (red to yellow)\n    const saturation = 0.8 + Math.random() * 0.2;\n    const value = 0.6 + intensity * 0.4;\n    return hsvToRgb(hue, saturation, value);\n}\nfunction hsvToRgb(h, s, v) {\n    const c = v * s;\n    const x = c * (1 - Math.abs(h / 60 % 2 - 1));\n    const m = v - c;\n    let r = 0, g = 0, b = 0;\n    if (0 <= h && h < 60) {\n        r = c;\n        g = x;\n        b = 0;\n    } else if (60 <= h && h < 120) {\n        r = x;\n        g = c;\n        b = 0;\n    } else if (120 <= h && h < 180) {\n        r = 0;\n        g = c;\n        b = x;\n    } else if (180 <= h && h < 240) {\n        r = 0;\n        g = x;\n        b = c;\n    } else if (240 <= h && h < 300) {\n        r = x;\n        g = 0;\n        b = c;\n    } else if (300 <= h && h < 360) {\n        r = c;\n        g = 0;\n        b = x;\n    }\n    return {\n        r: Math.round((r + m) * 255) * 0.4,\n        g: Math.round((g + m) * 255) * 0.05,\n        b: Math.round((b + m) * 255) * 0.2 // Some blue\n    };\n}\nfunction createTrail(x, y, vx, vy) {\n    const speed = Math.sqrt(vx * vx + vy * vy);\n    const intensity = Math.min(speed * 0.1, 1);\n    return {\n        x,\n        y,\n        vx: vx * config.velocityMultiplier + (Math.random() - 0.5) * 2,\n        vy: vy * config.velocityMultiplier + (Math.random() - 0.5) * 2,\n        life: config.trailLife,\n        maxLife: config.trailLife,\n        size: 2 + Math.random() * 4,\n        color: generateColor(intensity),\n        intensity: intensity\n    };\n}\nfunction updateTrails() {\n    // Update existing trails\n    for(let i = trails.length - 1; i >= 0; i--){\n        const trail = trails[i];\n        // Update position with fluid-like motion\n        trail.x += trail.vx;\n        trail.y += trail.vy;\n        // Apply drag and curl effects\n        trail.vx *= 0.985;\n        trail.vy *= 0.985;\n        // Add some curl/swirl\n        const curl = 0.02;\n        const temp = trail.vx;\n        trail.vx += trail.vy * curl;\n        trail.vy -= temp * curl;\n        // Update life\n        trail.life--;\n        trail.intensity = trail.life / trail.maxLife * config.colorIntensity;\n        // Remove dead trails\n        if (trail.life <= 0) {\n            trails.splice(i, 1);\n        }\n    }\n    // Add new trails based on mouse movement\n    const dx = mouseX - lastMouseX;\n    const dy = mouseY - lastMouseY;\n    const speed = Math.sqrt(dx * dx + dy * dy);\n    if (speed > 1 && trails.length < config.maxTrails) {\n        const numTrails = Math.min(Math.floor(speed * 0.3), 8);\n        for(let i = 0; i < numTrails; i++){\n            const offsetX = (Math.random() - 0.5) * 15;\n            const offsetY = (Math.random() - 0.5) * 15;\n            trails.push(createTrail(mouseX + offsetX, mouseY + offsetY, dx * 0.5 + (Math.random() - 0.5) * 3, dy * 0.5 + (Math.random() - 0.5) * 3));\n        }\n    }\n    lastMouseX = mouseX;\n    lastMouseY = mouseY;\n}\nfunction drawFluid() {\n    if (!ctx || !canvas) return;\n    // Clear with dark background and fade effect\n    ctx.fillStyle = \"rgba(7, 10, 7, 0.03)\"; // Very subtle fade\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n    // Draw trails with glow effect\n    trails.forEach((trail)=>{\n        const alpha = trail.intensity;\n        if (alpha > 0.01) {\n            // Main trail blob\n            ctx.beginPath();\n            ctx.arc(trail.x, trail.y, trail.size, 0, Math.PI * 2);\n            const gradient = ctx.createRadialGradient(trail.x, trail.y, 0, trail.x, trail.y, trail.size * 3);\n            gradient.addColorStop(0, \"rgba(\".concat(trail.color.r, \", \").concat(trail.color.g, \", \").concat(trail.color.b, \", \").concat(alpha * 0.8, \")\"));\n            gradient.addColorStop(0.5, \"rgba(\".concat(trail.color.r, \", \").concat(trail.color.g, \", \").concat(trail.color.b, \", \").concat(alpha * 0.4, \")\"));\n            gradient.addColorStop(1, \"rgba(\".concat(trail.color.r, \", \").concat(trail.color.g, \", \").concat(trail.color.b, \", 0)\"));\n            ctx.fillStyle = gradient;\n            ctx.fill();\n            // Additional glow layer\n            ctx.beginPath();\n            ctx.arc(trail.x, trail.y, trail.size * 2, 0, Math.PI * 2);\n            const outerGradient = ctx.createRadialGradient(trail.x, trail.y, 0, trail.x, trail.y, trail.size * 6);\n            outerGradient.addColorStop(0, \"rgba(\".concat(trail.color.r * 1.2, \", \").concat(trail.color.g * 1.2, \", \").concat(trail.color.b * 1.2, \", \").concat(alpha * 0.3, \")\"));\n            outerGradient.addColorStop(1, \"rgba(0, 0, 0, 0)\");\n            ctx.fillStyle = outerGradient;\n            ctx.fill();\n        }\n    });\n    // Add film grain effect\n    if (Math.random() < 0.3) {\n        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n        const data = imageData.data;\n        for(let i = 0; i < data.length; i += 4){\n            const grain = (Math.random() - 0.5) * config.grainAmount * 255;\n            data[i] += grain; // R\n            data[i + 1] += grain * 0.5; // G\n            data[i + 2] += grain; // B\n        }\n        ctx.putImageData(imageData, 0, 0);\n    }\n}\nfunction animate() {\n    updateTrails();\n    drawFluid();\n    animationId = requestAnimationFrame(animate);\n}\nfunction resizeCanvas() {\n    if (!canvas) return;\n    const rect = canvas.getBoundingClientRect();\n    const dpr = window.devicePixelRatio || 1;\n    canvas.width = rect.width * dpr;\n    canvas.height = rect.height * dpr;\n    if (ctx) {\n        ctx.scale(dpr, dpr);\n    }\n    canvas.style.width = rect.width + \"px\";\n    canvas.style.height = rect.height + \"px\";\n}\n// Event handlers\nfunction attachEventListeners() {\n    if ( false || !canvas) return;\n    const body = document.querySelector(\"body\");\n    if (!body) return;\n    const mouseMoveHandler = (e)=>{\n        const rect = canvas.getBoundingClientRect();\n        mouseX = e.clientX - rect.left;\n        mouseY = e.clientY - rect.top;\n    };\n    const touchMoveHandler = (e)=>{\n        e.preventDefault();\n        if (e.touches.length > 0) {\n            const rect = canvas.getBoundingClientRect();\n            const touch = e.touches[0];\n            mouseX = touch.clientX - rect.left;\n            mouseY = touch.clientY - rect.top;\n        }\n    };\n    const resizeHandler = ()=>{\n        resizeCanvas();\n    };\n    body.addEventListener(\"mousemove\", mouseMoveHandler);\n    body.addEventListener(\"touchmove\", touchMoveHandler, {\n        passive: false\n    });\n    window.addEventListener(\"resize\", resizeHandler);\n}\n// Main initialization function\nfunction initFluidSimulation() {\n    if (false) {}\n    if (fluidInitialized) {\n        console.log(\"Fluid already initialized\");\n        return;\n    }\n    console.log(\"Initializing working fluid simulation...\");\n    canvas = document.getElementById(\"fluid\");\n    if (!canvas) {\n        console.error(\"Fluid canvas not found\");\n        return;\n    }\n    ctx = canvas.getContext(\"2d\");\n    if (!ctx) {\n        console.error(\"Could not get 2D context\");\n        return;\n    }\n    // Setup canvas\n    resizeCanvas();\n    // Initialize mouse position\n    const rect = canvas.getBoundingClientRect();\n    mouseX = rect.width / 2;\n    mouseY = rect.height / 2;\n    lastMouseX = mouseX;\n    lastMouseY = mouseY;\n    // Set initial dark background\n    ctx.fillStyle = \"rgb(7, 10, 7)\";\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n    // Attach event listeners\n    attachEventListeners();\n    // Start animation loop\n    animate();\n    fluidInitialized = true;\n    console.log(\"Working fluid simulation initialized successfully!\");\n}\n// Cleanup function\nfunction cleanupFluidSimulation() {\n    if (animationId) {\n        cancelAnimationFrame(animationId);\n        animationId = null;\n    }\n    trails = [];\n    fluidInitialized = false;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LEVBQWEsRUFBTztJQUUxQyxJQUFJNUcsa0JBQWtCO1FBQ3BCNkcsUUFBUUMsR0FBRyxDQUFDO1FBQ1o7SUFDRjtJQUVBRCxRQUFRQyxHQUFHLENBQUM7SUFFWjdHLFNBQVM0RixTQUFTa0IsY0FBYyxDQUFDO0lBRWpDLElBQUksQ0FBQzlHLFFBQVE7UUFDWDRHLFFBQVFHLEtBQUssQ0FBQztRQUNkO0lBQ0Y7SUFFQTlHLE1BQU1ELE9BQU9nSCxVQUFVLENBQUM7SUFDeEIsSUFBSSxDQUFDL0csS0FBSztRQUNSMkcsUUFBUUcsS0FBSyxDQUFDO1FBQ2Q7SUFDRjtJQUVBLGVBQWU7SUFDZjdCO0lBRUEsNEJBQTRCO0lBQzVCLE1BQU1DLE9BQU9uRixPQUFPb0YscUJBQXFCO0lBQ3pDakYsU0FBU2dGLEtBQUtwQixLQUFLLEdBQUc7SUFDdEIzRCxTQUFTK0UsS0FBS25CLE1BQU0sR0FBRztJQUN2QjNELGFBQWFGO0lBQ2JHLGFBQWFGO0lBRWIsOEJBQThCO0lBQzlCSCxJQUFJNEQsU0FBUyxHQUFHO0lBQ2hCNUQsSUFBSTZELFFBQVEsQ0FBQyxHQUFHLEdBQUc5RCxPQUFPK0QsS0FBSyxFQUFFL0QsT0FBT2dFLE1BQU07SUFFOUMseUJBQXlCO0lBQ3pCMEI7SUFFQSx1QkFBdUI7SUFDdkJWO0lBRUFqRixtQkFBbUI7SUFDbkI2RyxRQUFRQyxHQUFHLENBQUM7QUFDZDtBQUVBLG1CQUFtQjtBQUNaLFNBQVNJO0lBQ2QsSUFBSTFHLGFBQWE7UUFDZjJHLHFCQUFxQjNHO1FBQ3JCQSxjQUFjO0lBQ2hCO0lBQ0FMLFNBQVMsRUFBRTtJQUNYSCxtQkFBbUI7QUFDckIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vYXBwL2xpYi9mbHVpZC50cz9mYjNkIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFdvcmtpbmcgRmx1aWQgU2ltdWxhdGlvbiBmb3IgTmV4dC5qc1xuLy8gU2ltcGxpZmllZCBidXQgZWZmZWN0aXZlIGltcGxlbWVudGF0aW9uIHRoYXQgcmVjcmVhdGVzIHRoZSBvcmlnaW5hbCBsb29rXG5cbmxldCBmbHVpZEluaXRpYWxpemVkID0gZmFsc2U7XG5sZXQgY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCB8IG51bGwgPSBudWxsO1xubGV0IGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEIHwgbnVsbCA9IG51bGw7XG5cbi8vIEZsdWlkIHN0YXRlXG5sZXQgdHJhaWxzOiBGbHVpZFRyYWlsW10gPSBbXTtcbmxldCBtb3VzZVggPSAwO1xubGV0IG1vdXNlWSA9IDA7XG5sZXQgbGFzdE1vdXNlWCA9IDA7XG5sZXQgbGFzdE1vdXNlWSA9IDA7XG5sZXQgYW5pbWF0aW9uSWQ6IG51bWJlciB8IG51bGwgPSBudWxsO1xuXG5pbnRlcmZhY2UgRmx1aWRUcmFpbCB7XG4gIHg6IG51bWJlcjtcbiAgeTogbnVtYmVyO1xuICB2eDogbnVtYmVyO1xuICB2eTogbnVtYmVyO1xuICBsaWZlOiBudW1iZXI7XG4gIG1heExpZmU6IG51bWJlcjtcbiAgc2l6ZTogbnVtYmVyO1xuICBjb2xvcjogeyByOiBudW1iZXI7IGc6IG51bWJlcjsgYjogbnVtYmVyIH07XG4gIGludGVuc2l0eTogbnVtYmVyO1xufVxuXG4vLyBDb25maWd1cmF0aW9uIG1hdGNoaW5nIG9yaWdpbmFsXG5jb25zdCBjb25maWcgPSB7XG4gIG1heFRyYWlsczogMjAwLFxuICB0cmFpbExpZmU6IDEyMCxcbiAgZmFkZVJhdGU6IDAuOTgsXG4gIHNwbGF0UmFkaXVzOiAyNSxcbiAgdmVsb2NpdHlNdWx0aXBsaWVyOiAwLjMsXG4gIGNvbG9ySW50ZW5zaXR5OiAwLjgsXG4gIGdyYWluQW1vdW50OiAwLjAyLFxufTtcblxuZnVuY3Rpb24gZ2VuZXJhdGVDb2xvcihpbnRlbnNpdHk6IG51bWJlciA9IDEpOiB7IHI6IG51bWJlcjsgZzogbnVtYmVyOyBiOiBudW1iZXIgfSB7XG4gIC8vIENvbG9ycyBzaW1pbGFyIHRvIG9yaWdpbmFsOiByZWQvb3JhbmdlIHRvbmVzXG4gIGNvbnN0IGh1ZSA9IE1hdGgucmFuZG9tKCkgKiA2MDsgLy8gMC02MCBkZWdyZWVzIChyZWQgdG8geWVsbG93KVxuICBjb25zdCBzYXR1cmF0aW9uID0gMC44ICsgTWF0aC5yYW5kb20oKSAqIDAuMjtcbiAgY29uc3QgdmFsdWUgPSAwLjYgKyBpbnRlbnNpdHkgKiAwLjQ7XG4gIFxuICByZXR1cm4gaHN2VG9SZ2IoaHVlLCBzYXR1cmF0aW9uLCB2YWx1ZSk7XG59XG5cbmZ1bmN0aW9uIGhzdlRvUmdiKGg6IG51bWJlciwgczogbnVtYmVyLCB2OiBudW1iZXIpOiB7IHI6IG51bWJlcjsgZzogbnVtYmVyOyBiOiBudW1iZXIgfSB7XG4gIGNvbnN0IGMgPSB2ICogcztcbiAgY29uc3QgeCA9IGMgKiAoMSAtIE1hdGguYWJzKChoIC8gNjApICUgMiAtIDEpKTtcbiAgY29uc3QgbSA9IHYgLSBjO1xuICBcbiAgbGV0IHIgPSAwLCBnID0gMCwgYiA9IDA7XG4gIFxuICBpZiAoMCA8PSBoICYmIGggPCA2MCkge1xuICAgIHIgPSBjOyBnID0geDsgYiA9IDA7XG4gIH0gZWxzZSBpZiAoNjAgPD0gaCAmJiBoIDwgMTIwKSB7XG4gICAgciA9IHg7IGcgPSBjOyBiID0gMDtcbiAgfSBlbHNlIGlmICgxMjAgPD0gaCAmJiBoIDwgMTgwKSB7XG4gICAgciA9IDA7IGcgPSBjOyBiID0geDtcbiAgfSBlbHNlIGlmICgxODAgPD0gaCAmJiBoIDwgMjQwKSB7XG4gICAgciA9IDA7IGcgPSB4OyBiID0gYztcbiAgfSBlbHNlIGlmICgyNDAgPD0gaCAmJiBoIDwgMzAwKSB7XG4gICAgciA9IHg7IGcgPSAwOyBiID0gYztcbiAgfSBlbHNlIGlmICgzMDAgPD0gaCAmJiBoIDwgMzYwKSB7XG4gICAgciA9IGM7IGcgPSAwOyBiID0geDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcjogTWF0aC5yb3VuZCgociArIG0pICogMjU1KSAqIDAuNCwgLy8gUmVkdWNlIGludGVuc2l0eSBsaWtlIG9yaWdpbmFsXG4gICAgZzogTWF0aC5yb3VuZCgoZyArIG0pICogMjU1KSAqIDAuMDUsIC8vIFZlcnkgbG93IGdyZWVuXG4gICAgYjogTWF0aC5yb3VuZCgoYiArIG0pICogMjU1KSAqIDAuMiAgIC8vIFNvbWUgYmx1ZVxuICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVUcmFpbCh4OiBudW1iZXIsIHk6IG51bWJlciwgdng6IG51bWJlciwgdnk6IG51bWJlcik6IEZsdWlkVHJhaWwge1xuICBjb25zdCBzcGVlZCA9IE1hdGguc3FydCh2eCAqIHZ4ICsgdnkgKiB2eSk7XG4gIGNvbnN0IGludGVuc2l0eSA9IE1hdGgubWluKHNwZWVkICogMC4xLCAxKTtcbiAgXG4gIHJldHVybiB7XG4gICAgeCxcbiAgICB5LFxuICAgIHZ4OiB2eCAqIGNvbmZpZy52ZWxvY2l0eU11bHRpcGxpZXIgKyAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAyLFxuICAgIHZ5OiB2eSAqIGNvbmZpZy52ZWxvY2l0eU11bHRpcGxpZXIgKyAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAyLFxuICAgIGxpZmU6IGNvbmZpZy50cmFpbExpZmUsXG4gICAgbWF4TGlmZTogY29uZmlnLnRyYWlsTGlmZSxcbiAgICBzaXplOiAyICsgTWF0aC5yYW5kb20oKSAqIDQsXG4gICAgY29sb3I6IGdlbmVyYXRlQ29sb3IoaW50ZW5zaXR5KSxcbiAgICBpbnRlbnNpdHk6IGludGVuc2l0eVxuICB9O1xufVxuXG5mdW5jdGlvbiB1cGRhdGVUcmFpbHMoKSB7XG4gIC8vIFVwZGF0ZSBleGlzdGluZyB0cmFpbHNcbiAgZm9yIChsZXQgaSA9IHRyYWlscy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGNvbnN0IHRyYWlsID0gdHJhaWxzW2ldO1xuICAgIFxuICAgIC8vIFVwZGF0ZSBwb3NpdGlvbiB3aXRoIGZsdWlkLWxpa2UgbW90aW9uXG4gICAgdHJhaWwueCArPSB0cmFpbC52eDtcbiAgICB0cmFpbC55ICs9IHRyYWlsLnZ5O1xuICAgIFxuICAgIC8vIEFwcGx5IGRyYWcgYW5kIGN1cmwgZWZmZWN0c1xuICAgIHRyYWlsLnZ4ICo9IDAuOTg1O1xuICAgIHRyYWlsLnZ5ICo9IDAuOTg1O1xuICAgIFxuICAgIC8vIEFkZCBzb21lIGN1cmwvc3dpcmxcbiAgICBjb25zdCBjdXJsID0gMC4wMjtcbiAgICBjb25zdCB0ZW1wID0gdHJhaWwudng7XG4gICAgdHJhaWwudnggKz0gdHJhaWwudnkgKiBjdXJsO1xuICAgIHRyYWlsLnZ5IC09IHRlbXAgKiBjdXJsO1xuICAgIFxuICAgIC8vIFVwZGF0ZSBsaWZlXG4gICAgdHJhaWwubGlmZS0tO1xuICAgIHRyYWlsLmludGVuc2l0eSA9ICh0cmFpbC5saWZlIC8gdHJhaWwubWF4TGlmZSkgKiBjb25maWcuY29sb3JJbnRlbnNpdHk7XG4gICAgXG4gICAgLy8gUmVtb3ZlIGRlYWQgdHJhaWxzXG4gICAgaWYgKHRyYWlsLmxpZmUgPD0gMCkge1xuICAgICAgdHJhaWxzLnNwbGljZShpLCAxKTtcbiAgICB9XG4gIH1cbiAgXG4gIC8vIEFkZCBuZXcgdHJhaWxzIGJhc2VkIG9uIG1vdXNlIG1vdmVtZW50XG4gIGNvbnN0IGR4ID0gbW91c2VYIC0gbGFzdE1vdXNlWDtcbiAgY29uc3QgZHkgPSBtb3VzZVkgLSBsYXN0TW91c2VZO1xuICBjb25zdCBzcGVlZCA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gIFxuICBpZiAoc3BlZWQgPiAxICYmIHRyYWlscy5sZW5ndGggPCBjb25maWcubWF4VHJhaWxzKSB7XG4gICAgY29uc3QgbnVtVHJhaWxzID0gTWF0aC5taW4oTWF0aC5mbG9vcihzcGVlZCAqIDAuMyksIDgpO1xuICAgIFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtVHJhaWxzOyBpKyspIHtcbiAgICAgIGNvbnN0IG9mZnNldFggPSAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAxNTtcbiAgICAgIGNvbnN0IG9mZnNldFkgPSAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAxNTtcbiAgICAgIFxuICAgICAgdHJhaWxzLnB1c2goY3JlYXRlVHJhaWwoXG4gICAgICAgIG1vdXNlWCArIG9mZnNldFgsXG4gICAgICAgIG1vdXNlWSArIG9mZnNldFksXG4gICAgICAgIGR4ICogMC41ICsgKE1hdGgucmFuZG9tKCkgLSAwLjUpICogMyxcbiAgICAgICAgZHkgKiAwLjUgKyAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAzXG4gICAgICApKTtcbiAgICB9XG4gIH1cbiAgXG4gIGxhc3RNb3VzZVggPSBtb3VzZVg7XG4gIGxhc3RNb3VzZVkgPSBtb3VzZVk7XG59XG5cbmZ1bmN0aW9uIGRyYXdGbHVpZCgpIHtcbiAgaWYgKCFjdHggfHwgIWNhbnZhcykgcmV0dXJuO1xuICBcbiAgLy8gQ2xlYXIgd2l0aCBkYXJrIGJhY2tncm91bmQgYW5kIGZhZGUgZWZmZWN0XG4gIGN0eC5maWxsU3R5bGUgPSAncmdiYSg3LCAxMCwgNywgMC4wMyknOyAvLyBWZXJ5IHN1YnRsZSBmYWRlXG4gIGN0eC5maWxsUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICBcbiAgLy8gRHJhdyB0cmFpbHMgd2l0aCBnbG93IGVmZmVjdFxuICB0cmFpbHMuZm9yRWFjaCh0cmFpbCA9PiB7XG4gICAgY29uc3QgYWxwaGEgPSB0cmFpbC5pbnRlbnNpdHk7XG4gICAgXG4gICAgaWYgKGFscGhhID4gMC4wMSkge1xuICAgICAgLy8gTWFpbiB0cmFpbCBibG9iXG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHguYXJjKHRyYWlsLngsIHRyYWlsLnksIHRyYWlsLnNpemUsIDAsIE1hdGguUEkgKiAyKTtcbiAgICAgIFxuICAgICAgY29uc3QgZ3JhZGllbnQgPSBjdHguY3JlYXRlUmFkaWFsR3JhZGllbnQoXG4gICAgICAgIHRyYWlsLngsIHRyYWlsLnksIDAsXG4gICAgICAgIHRyYWlsLngsIHRyYWlsLnksIHRyYWlsLnNpemUgKiAzXG4gICAgICApO1xuICAgICAgXG4gICAgICBncmFkaWVudC5hZGRDb2xvclN0b3AoMCwgYHJnYmEoJHt0cmFpbC5jb2xvci5yfSwgJHt0cmFpbC5jb2xvci5nfSwgJHt0cmFpbC5jb2xvci5ifSwgJHthbHBoYSAqIDAuOH0pYCk7XG4gICAgICBncmFkaWVudC5hZGRDb2xvclN0b3AoMC41LCBgcmdiYSgke3RyYWlsLmNvbG9yLnJ9LCAke3RyYWlsLmNvbG9yLmd9LCAke3RyYWlsLmNvbG9yLmJ9LCAke2FscGhhICogMC40fSlgKTtcbiAgICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcCgxLCBgcmdiYSgke3RyYWlsLmNvbG9yLnJ9LCAke3RyYWlsLmNvbG9yLmd9LCAke3RyYWlsLmNvbG9yLmJ9LCAwKWApO1xuICAgICAgXG4gICAgICBjdHguZmlsbFN0eWxlID0gZ3JhZGllbnQ7XG4gICAgICBjdHguZmlsbCgpO1xuICAgICAgXG4gICAgICAvLyBBZGRpdGlvbmFsIGdsb3cgbGF5ZXJcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5hcmModHJhaWwueCwgdHJhaWwueSwgdHJhaWwuc2l6ZSAqIDIsIDAsIE1hdGguUEkgKiAyKTtcbiAgICAgIFxuICAgICAgY29uc3Qgb3V0ZXJHcmFkaWVudCA9IGN0eC5jcmVhdGVSYWRpYWxHcmFkaWVudChcbiAgICAgICAgdHJhaWwueCwgdHJhaWwueSwgMCxcbiAgICAgICAgdHJhaWwueCwgdHJhaWwueSwgdHJhaWwuc2l6ZSAqIDZcbiAgICAgICk7XG4gICAgICBcbiAgICAgIG91dGVyR3JhZGllbnQuYWRkQ29sb3JTdG9wKDAsIGByZ2JhKCR7dHJhaWwuY29sb3IuciAqIDEuMn0sICR7dHJhaWwuY29sb3IuZyAqIDEuMn0sICR7dHJhaWwuY29sb3IuYiAqIDEuMn0sICR7YWxwaGEgKiAwLjN9KWApO1xuICAgICAgb3V0ZXJHcmFkaWVudC5hZGRDb2xvclN0b3AoMSwgJ3JnYmEoMCwgMCwgMCwgMCknKTtcbiAgICAgIFxuICAgICAgY3R4LmZpbGxTdHlsZSA9IG91dGVyR3JhZGllbnQ7XG4gICAgICBjdHguZmlsbCgpO1xuICAgIH1cbiAgfSk7XG4gIFxuICAvLyBBZGQgZmlsbSBncmFpbiBlZmZlY3RcbiAgaWYgKE1hdGgucmFuZG9tKCkgPCAwLjMpIHtcbiAgICBjb25zdCBpbWFnZURhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgY29uc3QgZGF0YSA9IGltYWdlRGF0YS5kYXRhO1xuICAgIFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkgKz0gNCkge1xuICAgICAgY29uc3QgZ3JhaW4gPSAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiBjb25maWcuZ3JhaW5BbW91bnQgKiAyNTU7XG4gICAgICBkYXRhW2ldICs9IGdyYWluOyAgICAgLy8gUlxuICAgICAgZGF0YVtpICsgMV0gKz0gZ3JhaW4gKiAwLjU7IC8vIEdcbiAgICAgIGRhdGFbaSArIDJdICs9IGdyYWluOyAvLyBCXG4gICAgfVxuICAgIFxuICAgIGN0eC5wdXRJbWFnZURhdGEoaW1hZ2VEYXRhLCAwLCAwKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhbmltYXRlKCkge1xuICB1cGRhdGVUcmFpbHMoKTtcbiAgZHJhd0ZsdWlkKCk7XG4gIGFuaW1hdGlvbklkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpO1xufVxuXG5mdW5jdGlvbiByZXNpemVDYW52YXMoKSB7XG4gIGlmICghY2FudmFzKSByZXR1cm47XG4gIFxuICBjb25zdCByZWN0ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICBjb25zdCBkcHIgPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xuICBcbiAgY2FudmFzLndpZHRoID0gcmVjdC53aWR0aCAqIGRwcjtcbiAgY2FudmFzLmhlaWdodCA9IHJlY3QuaGVpZ2h0ICogZHByO1xuICBcbiAgaWYgKGN0eCkge1xuICAgIGN0eC5zY2FsZShkcHIsIGRwcik7XG4gIH1cbiAgXG4gIGNhbnZhcy5zdHlsZS53aWR0aCA9IHJlY3Qud2lkdGggKyAncHgnO1xuICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gcmVjdC5oZWlnaHQgKyAncHgnO1xufVxuXG4vLyBFdmVudCBoYW5kbGVyc1xuZnVuY3Rpb24gYXR0YWNoRXZlbnRMaXN0ZW5lcnMoKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyB8fCAhY2FudmFzKSByZXR1cm47XG5cbiAgY29uc3QgYm9keSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2JvZHknKTtcbiAgaWYgKCFib2R5KSByZXR1cm47XG5cbiAgY29uc3QgbW91c2VNb3ZlSGFuZGxlciA9IChlOiBNb3VzZUV2ZW50KSA9PiB7XG4gICAgY29uc3QgcmVjdCA9IGNhbnZhcyEuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgbW91c2VYID0gZS5jbGllbnRYIC0gcmVjdC5sZWZ0O1xuICAgIG1vdXNlWSA9IGUuY2xpZW50WSAtIHJlY3QudG9wO1xuICB9O1xuXG4gIGNvbnN0IHRvdWNoTW92ZUhhbmRsZXIgPSAoZTogVG91Y2hFdmVudCkgPT4ge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBpZiAoZS50b3VjaGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IHJlY3QgPSBjYW52YXMhLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgY29uc3QgdG91Y2ggPSBlLnRvdWNoZXNbMF07XG4gICAgICBtb3VzZVggPSB0b3VjaC5jbGllbnRYIC0gcmVjdC5sZWZ0O1xuICAgICAgbW91c2VZID0gdG91Y2guY2xpZW50WSAtIHJlY3QudG9wO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCByZXNpemVIYW5kbGVyID0gKCkgPT4ge1xuICAgIHJlc2l6ZUNhbnZhcygpO1xuICB9O1xuXG4gIGJvZHkuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBtb3VzZU1vdmVIYW5kbGVyKTtcbiAgYm9keS5hZGRFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIHRvdWNoTW92ZUhhbmRsZXIsIHsgcGFzc2l2ZTogZmFsc2UgfSk7XG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHJlc2l6ZUhhbmRsZXIpO1xufVxuXG4vLyBNYWluIGluaXRpYWxpemF0aW9uIGZ1bmN0aW9uXG5leHBvcnQgZnVuY3Rpb24gaW5pdEZsdWlkU2ltdWxhdGlvbigpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm47XG4gIFxuICBpZiAoZmx1aWRJbml0aWFsaXplZCkge1xuICAgIGNvbnNvbGUubG9nKCdGbHVpZCBhbHJlYWR5IGluaXRpYWxpemVkJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc29sZS5sb2coJ0luaXRpYWxpemluZyB3b3JraW5nIGZsdWlkIHNpbXVsYXRpb24uLi4nKTtcblxuICBjYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImZsdWlkXCIpIGFzIEhUTUxDYW52YXNFbGVtZW50O1xuICBcbiAgaWYgKCFjYW52YXMpIHtcbiAgICBjb25zb2xlLmVycm9yKCdGbHVpZCBjYW52YXMgbm90IGZvdW5kJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gIGlmICghY3R4KSB7XG4gICAgY29uc29sZS5lcnJvcignQ291bGQgbm90IGdldCAyRCBjb250ZXh0Jyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gU2V0dXAgY2FudmFzXG4gIHJlc2l6ZUNhbnZhcygpO1xuICBcbiAgLy8gSW5pdGlhbGl6ZSBtb3VzZSBwb3NpdGlvblxuICBjb25zdCByZWN0ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICBtb3VzZVggPSByZWN0LndpZHRoIC8gMjtcbiAgbW91c2VZID0gcmVjdC5oZWlnaHQgLyAyO1xuICBsYXN0TW91c2VYID0gbW91c2VYO1xuICBsYXN0TW91c2VZID0gbW91c2VZO1xuXG4gIC8vIFNldCBpbml0aWFsIGRhcmsgYmFja2dyb3VuZFxuICBjdHguZmlsbFN0eWxlID0gJ3JnYig3LCAxMCwgNyknO1xuICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcblxuICAvLyBBdHRhY2ggZXZlbnQgbGlzdGVuZXJzXG4gIGF0dGFjaEV2ZW50TGlzdGVuZXJzKCk7XG4gIFxuICAvLyBTdGFydCBhbmltYXRpb24gbG9vcFxuICBhbmltYXRlKCk7XG5cbiAgZmx1aWRJbml0aWFsaXplZCA9IHRydWU7XG4gIGNvbnNvbGUubG9nKCdXb3JraW5nIGZsdWlkIHNpbXVsYXRpb24gaW5pdGlhbGl6ZWQgc3VjY2Vzc2Z1bGx5IScpO1xufVxuXG4vLyBDbGVhbnVwIGZ1bmN0aW9uXG5leHBvcnQgZnVuY3Rpb24gY2xlYW51cEZsdWlkU2ltdWxhdGlvbigpIHtcbiAgaWYgKGFuaW1hdGlvbklkKSB7XG4gICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoYW5pbWF0aW9uSWQpO1xuICAgIGFuaW1hdGlvbklkID0gbnVsbDtcbiAgfVxuICB0cmFpbHMgPSBbXTtcbiAgZmx1aWRJbml0aWFsaXplZCA9IGZhbHNlO1xufSJdLCJuYW1lcyI6WyJmbHVpZEluaXRpYWxpemVkIiwiY2FudmFzIiwiY3R4IiwidHJhaWxzIiwibW91c2VYIiwibW91c2VZIiwibGFzdE1vdXNlWCIsImxhc3RNb3VzZVkiLCJhbmltYXRpb25JZCIsImNvbmZpZyIsIm1heFRyYWlscyIsInRyYWlsTGlmZSIsImZhZGVSYXRlIiwic3BsYXRSYWRpdXMiLCJ2ZWxvY2l0eU11bHRpcGxpZXIiLCJjb2xvckludGVuc2l0eSIsImdyYWluQW1vdW50IiwiZ2VuZXJhdGVDb2xvciIsImludGVuc2l0eSIsImh1ZSIsIk1hdGgiLCJyYW5kb20iLCJzYXR1cmF0aW9uIiwidmFsdWUiLCJoc3ZUb1JnYiIsImgiLCJzIiwidiIsImMiLCJ4IiwiYWJzIiwibSIsInIiLCJnIiwiYiIsInJvdW5kIiwiY3JlYXRlVHJhaWwiLCJ5IiwidngiLCJ2eSIsInNwZWVkIiwic3FydCIsIm1pbiIsImxpZmUiLCJtYXhMaWZlIiwic2l6ZSIsImNvbG9yIiwidXBkYXRlVHJhaWxzIiwiaSIsImxlbmd0aCIsInRyYWlsIiwiY3VybCIsInRlbXAiLCJzcGxpY2UiLCJkeCIsImR5IiwibnVtVHJhaWxzIiwiZmxvb3IiLCJvZmZzZXRYIiwib2Zmc2V0WSIsInB1c2giLCJkcmF3Rmx1aWQiLCJmaWxsU3R5bGUiLCJmaWxsUmVjdCIsIndpZHRoIiwiaGVpZ2h0IiwiZm9yRWFjaCIsImFscGhhIiwiYmVnaW5QYXRoIiwiYXJjIiwiUEkiLCJncmFkaWVudCIsImNyZWF0ZVJhZGlhbEdyYWRpZW50IiwiYWRkQ29sb3JTdG9wIiwiZmlsbCIsIm91dGVyR3JhZGllbnQiLCJpbWFnZURhdGEiLCJnZXRJbWFnZURhdGEiLCJkYXRhIiwiZ3JhaW4iLCJwdXRJbWFnZURhdGEiLCJhbmltYXRlIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwicmVzaXplQ2FudmFzIiwicmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImRwciIsIndpbmRvdyIsImRldmljZVBpeGVsUmF0aW8iLCJzY2FsZSIsInN0eWxlIiwiYXR0YWNoRXZlbnRMaXN0ZW5lcnMiLCJib2R5IiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yIiwibW91c2VNb3ZlSGFuZGxlciIsImUiLCJjbGllbnRYIiwibGVmdCIsImNsaWVudFkiLCJ0b3AiLCJ0b3VjaE1vdmVIYW5kbGVyIiwicHJldmVudERlZmF1bHQiLCJ0b3VjaGVzIiwidG91Y2giLCJyZXNpemVIYW5kbGVyIiwiYWRkRXZlbnRMaXN0ZW5lciIsInBhc3NpdmUiLCJpbml0Rmx1aWRTaW11bGF0aW9uIiwiY29uc29sZSIsImxvZyIsImdldEVsZW1lbnRCeUlkIiwiZXJyb3IiLCJnZXRDb250ZXh0IiwiY2xlYW51cEZsdWlkU2ltdWxhdGlvbiIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/lib/fluid.ts\n"));

/***/ })

});