"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_app-pages-browser_app_lib_fluid_ts",{

/***/ "(app-pages-browser)/./app/lib/fluid.ts":
/*!**************************!*\
  !*** ./app/lib/fluid.ts ***!
  \**************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   initFluidSimulation: function() { return /* binding */ initFluidSimulation; }\n/* harmony export */ });\n// Simplified fluid simulation for Next.js\n// This is a TypeScript version of the original fluid.js with Next.js compatibility\nlet fluidInitialized = false;\nlet canvas = null;\nlet gl = null;\n// Global variables for the simulation\nlet config;\nlet pointers = [];\nlet dye, velocity;\nlet lastUpdateTime = 0;\nlet startTime = 0;\n// Utility functions\nfunction scaleByPixelRatio(input) {\n    const pixelRatio =  true ? window.devicePixelRatio || 1 : 0;\n    return Math.floor(input * pixelRatio);\n}\nfunction HSVtoRGB(h, s, v) {\n    let r, g, b, i, f, p, q, t;\n    i = Math.floor(h * 6);\n    f = h * 6 - i;\n    p = v * (1 - s);\n    q = v * (1 - f * s);\n    t = v * (1 - (1 - f) * s);\n    switch(i % 6){\n        case 0:\n            r = v;\n            g = t;\n            b = p;\n            break;\n        case 1:\n            r = q;\n            g = v;\n            b = p;\n            break;\n        case 2:\n            r = p;\n            g = v;\n            b = t;\n            break;\n        case 3:\n            r = p;\n            g = q;\n            b = v;\n            break;\n        case 4:\n            r = t;\n            g = p;\n            b = v;\n            break;\n        case 5:\n            r = v;\n            g = p;\n            b = q;\n            break;\n        default:\n            r = g = b = 0;\n    }\n    return {\n        r,\n        g,\n        b\n    };\n}\nfunction generateColor() {\n    const c = HSVtoRGB(Math.random(), 1.0, 1.0);\n    c.r *= 0.40;\n    c.g *= 0.01;\n    c.b *= 0.10;\n    return c;\n}\n// Pointer class\nclass PointerPrototype {\n    constructor(){\n        this.id = -1;\n        this.texcoordX = 0;\n        this.texcoordY = 0;\n        this.prevTexcoordX = 0;\n        this.prevTexcoordY = 0;\n        this.deltaX = 0;\n        this.deltaY = 0;\n        this.down = false;\n        this.moved = false;\n        this.color = {\n            r: 30,\n            g: 0,\n            b: 300\n        };\n    }\n}\n// Basic WebGL setup\nfunction getWebGLContext(canvas) {\n    const params = {\n        alpha: true,\n        depth: false,\n        stencil: false,\n        antialias: false,\n        preserveDrawingBuffer: false\n    };\n    let gl = canvas.getContext(\"webgl2\", params);\n    const isWebGL2 = !!gl;\n    if (!isWebGL2) {\n        gl = canvas.getContext(\"webgl\", params) || canvas.getContext(\"experimental-webgl\", params);\n    }\n    if (!gl) {\n        console.error(\"WebGL not supported\");\n        return null;\n    }\n    gl.clearColor(0.0, 0.0, 0.0, 1.0);\n    return gl;\n}\n// Simplified render loop\nfunction render() {\n    if (!gl || !canvas) return;\n    gl.clear(gl.COLOR_BUFFER_BIT);\n    // Create a simple animated background effect\n    const time = (Date.now() - startTime) / 1000;\n    const r = Math.sin(time * 0.3) * 0.5 + 0.5;\n    const g = Math.sin(time * 0.5) * 0.5 + 0.5;\n    const b = Math.sin(time * 0.7) * 0.5 + 0.5;\n    gl.clearColor(r * 0.1, g * 0.02, b * 0.05, 1.0);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n    requestAnimationFrame(render);\n}\n// Resize canvas\nfunction resizeCanvas() {\n    if (!canvas) return false;\n    const width = scaleByPixelRatio(canvas.clientWidth);\n    const height = scaleByPixelRatio(canvas.clientHeight);\n    if (canvas.width !== width || canvas.height !== height) {\n        canvas.width = width;\n        canvas.height = height;\n        return true;\n    }\n    return false;\n}\n// Event handlers\nfunction updatePointerMoveData(pointer, posX, posY) {\n    if (!canvas) return;\n    pointer.prevTexcoordX = pointer.texcoordX;\n    pointer.prevTexcoordY = pointer.texcoordY;\n    pointer.texcoordX = posX / canvas.width;\n    pointer.texcoordY = 1.0 - posY / canvas.height;\n    pointer.deltaX = pointer.texcoordX - pointer.prevTexcoordX;\n    pointer.deltaY = pointer.texcoordY - pointer.prevTexcoordY;\n    pointer.moved = Math.abs(pointer.deltaX) > 0 || Math.abs(pointer.deltaY) > 0;\n}\nfunction correctDeltaX(delta) {\n    if (!canvas) return delta;\n    const aspectRatio = canvas.width / canvas.height;\n    if (aspectRatio < 1) delta *= aspectRatio;\n    return delta;\n}\nfunction correctDeltaY(delta) {\n    if (!canvas) return delta;\n    const aspectRatio = canvas.width / canvas.height;\n    if (aspectRatio > 1) delta /= aspectRatio;\n    return delta;\n}\nfunction splatPointer(pointer) {\n    const dx = correctDeltaX(pointer.deltaX) * config.SPLAT_FORCE;\n    const dy = correctDeltaY(pointer.deltaY) * config.SPLAT_FORCE;\n    splat(pointer.texcoordX, pointer.texcoordY, dx, dy, pointer.color);\n}\nfunction splat(x, y, dx, dy, color) {\n    // This is a simplified splat effect - in the full version this would update fluid textures\n    // For now, we'll just create a visual effect\n    if (!gl || !canvas) return;\n    // Create a simple colored circle effect\n    const centerX = x * canvas.width;\n    const centerY = (1 - y) * canvas.height;\n    const radius = 50;\n// This would normally update the fluid simulation textures\n// For now, just trigger a visual update\n}\n// Event listeners\nfunction attachEventListeners() {\n    if ( false || !canvas) return;\n    const body = document.querySelector(\"body\");\n    if (!body) return;\n    const mouseMoveHandler = (e)=>{\n        if (!pointers || !pointers[0]) return;\n        const pointer = pointers[0];\n        const posX = scaleByPixelRatio(e.clientX);\n        const posY = scaleByPixelRatio(e.clientY);\n        updatePointerMoveData(pointer, posX, posY);\n        // Apply splat effect when mouse moves\n        if (pointer.moved) {\n            pointer.moved = false;\n            splatPointer(pointer);\n        }\n    };\n    const touchStartHandler = (e)=>{\n        e.preventDefault();\n        if (!pointers) return;\n        const touches = e.targetTouches;\n        while(touches.length >= pointers.length){\n            pointers.push(new PointerPrototype());\n        }\n        for(let i = 0; i < touches.length; i++){\n            const posX = scaleByPixelRatio(touches[i].clientX);\n            const posY = scaleByPixelRatio(touches[i].clientY);\n            const pointer = pointers[i + 1];\n            if (pointer) {\n                pointer.id = touches[i].identifier;\n                pointer.down = true;\n                pointer.moved = false;\n                pointer.texcoordX = posX / canvas.width;\n                pointer.texcoordY = 1.0 - posY / canvas.height;\n                pointer.prevTexcoordX = pointer.texcoordX;\n                pointer.prevTexcoordY = pointer.texcoordY;\n                pointer.deltaX = 0;\n                pointer.deltaY = 0;\n                pointer.color = generateColor();\n            }\n        }\n    };\n    const touchMoveHandler = (e)=>{\n        e.preventDefault();\n        if (!pointers) return;\n        const touches = e.targetTouches;\n        for(let i = 0; i < touches.length; i++){\n            const pointer = pointers[i + 1];\n            if (!pointer || !pointer.down) continue;\n            const posX = scaleByPixelRatio(touches[i].clientX);\n            const posY = scaleByPixelRatio(touches[i].clientY);\n            updatePointerMoveData(pointer, posX, posY);\n        }\n    };\n    const touchEndHandler = (e)=>{\n        if (!pointers) return;\n        const touches = e.changedTouches;\n        for(let i = 0; i < touches.length; i++){\n            const pointer = pointers.find((p)=>p.id === touches[i].identifier);\n            if (pointer) {\n                pointer.down = false;\n            }\n        }\n    };\n    body.addEventListener(\"mousemove\", mouseMoveHandler);\n    body.addEventListener(\"touchstart\", touchStartHandler);\n    body.addEventListener(\"touchmove\", touchMoveHandler, {\n        passive: false\n    });\n    window.addEventListener(\"touchend\", touchEndHandler);\n}\n// Main initialization function\nfunction initFluidSimulation() {\n    if (false) {}\n    if (fluidInitialized) {\n        console.log(\"Fluid already initialized, skipping WebGL setup...\");\n        attachEventListeners();\n        return;\n    }\n    console.log(\"Initializing fluid simulation...\");\n    canvas = document.getElementById(\"fluid\");\n    if (!canvas) {\n        console.error(\"Fluid canvas not found\");\n        return;\n    }\n    resizeCanvas();\n    gl = getWebGLContext(canvas);\n    if (!gl) {\n        console.error(\"Failed to get WebGL context\");\n        return;\n    }\n    // Initialize basic config\n    config = {\n        DENSITY_DISSIPATION: 2,\n        VELOCITY_DISSIPATION: 0.1,\n        PRESSURE: 0.01,\n        CURL: 100,\n        SPLAT_RADIUS: 0.13,\n        SPLAT_FORCE: 5000,\n        COLORFUL: true,\n        COLOR_UPDATE_SPEED: 3,\n        PAUSED: false\n    };\n    // Initialize pointers\n    pointers = [];\n    pointers.push(new PointerPrototype());\n    // Start render loop\n    lastUpdateTime = Date.now();\n    startTime = Date.now();\n    // Attach event listeners\n    attachEventListeners();\n    // Start rendering\n    render();\n    fluidInitialized = true;\n    console.log(\"Fluid simulation initialized successfully!\");\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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RUEsc0JBQXNCO0lBQ3RCakgsV0FBVyxFQUFFO0lBQ2JBLFNBQVMrRixJQUFJLENBQUMsSUFBSXBFO0lBRWxCLG9CQUFvQjtJQUNwQnhCLGlCQUFpQm1ELEtBQUtDLEdBQUc7SUFDekJuRCxZQUFZa0QsS0FBS0MsR0FBRztJQUVwQix5QkFBeUI7SUFDekIyQjtJQUVBLGtCQUFrQjtJQUNsQmhDO0lBRUF0RCxtQkFBbUI7SUFDbkJtRCxRQUFReUQsR0FBRyxDQUFDO0FBQ2QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vYXBwL2xpYi9mbHVpZC50cz9mYjNkIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFNpbXBsaWZpZWQgZmx1aWQgc2ltdWxhdGlvbiBmb3IgTmV4dC5qc1xuLy8gVGhpcyBpcyBhIFR5cGVTY3JpcHQgdmVyc2lvbiBvZiB0aGUgb3JpZ2luYWwgZmx1aWQuanMgd2l0aCBOZXh0LmpzIGNvbXBhdGliaWxpdHlcblxubGV0IGZsdWlkSW5pdGlhbGl6ZWQgPSBmYWxzZTtcbmxldCBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50IHwgbnVsbCA9IG51bGw7XG5sZXQgZ2w6IFdlYkdMUmVuZGVyaW5nQ29udGV4dCB8IG51bGwgPSBudWxsO1xuXG4vLyBHbG9iYWwgdmFyaWFibGVzIGZvciB0aGUgc2ltdWxhdGlvblxubGV0IGNvbmZpZzogYW55O1xubGV0IHBvaW50ZXJzOiBhbnlbXSA9IFtdO1xubGV0IGR5ZTogYW55LCB2ZWxvY2l0eTogYW55O1xubGV0IGxhc3RVcGRhdGVUaW1lID0gMDtcbmxldCBzdGFydFRpbWUgPSAwO1xuXG4vLyBVdGlsaXR5IGZ1bmN0aW9uc1xuZnVuY3Rpb24gc2NhbGVCeVBpeGVsUmF0aW8oaW5wdXQ6IG51bWJlcik6IG51bWJlciB7XG4gIGNvbnN0IHBpeGVsUmF0aW8gPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDEgOiAxO1xuICByZXR1cm4gTWF0aC5mbG9vcihpbnB1dCAqIHBpeGVsUmF0aW8pO1xufVxuXG5mdW5jdGlvbiBIU1Z0b1JHQihoOiBudW1iZXIsIHM6IG51bWJlciwgdjogbnVtYmVyKTogeyByOiBudW1iZXI7IGc6IG51bWJlcjsgYjogbnVtYmVyIH0ge1xuICBsZXQgcjogbnVtYmVyLCBnOiBudW1iZXIsIGI6IG51bWJlciwgaTogbnVtYmVyLCBmOiBudW1iZXIsIHA6IG51bWJlciwgcTogbnVtYmVyLCB0OiBudW1iZXI7XG4gIGkgPSBNYXRoLmZsb29yKGggKiA2KTtcbiAgZiA9IGggKiA2IC0gaTtcbiAgcCA9IHYgKiAoMSAtIHMpO1xuICBxID0gdiAqICgxIC0gZiAqIHMpO1xuICB0ID0gdiAqICgxIC0gKDEgLSBmKSAqIHMpO1xuXG4gIHN3aXRjaCAoaSAlIDYpIHtcbiAgICBjYXNlIDA6IHIgPSB2OyBnID0gdDsgYiA9IHA7IGJyZWFrO1xuICAgIGNhc2UgMTogciA9IHE7IGcgPSB2OyBiID0gcDsgYnJlYWs7XG4gICAgY2FzZSAyOiByID0gcDsgZyA9IHY7IGIgPSB0OyBicmVhaztcbiAgICBjYXNlIDM6IHIgPSBwOyBnID0gcTsgYiA9IHY7IGJyZWFrO1xuICAgIGNhc2UgNDogciA9IHQ7IGcgPSBwOyBiID0gdjsgYnJlYWs7XG4gICAgY2FzZSA1OiByID0gdjsgZyA9IHA7IGIgPSBxOyBicmVhaztcbiAgICBkZWZhdWx0OiByID0gZyA9IGIgPSAwO1xuICB9XG5cbiAgcmV0dXJuIHsgciwgZywgYiB9O1xufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZUNvbG9yKCk6IHsgcjogbnVtYmVyOyBnOiBudW1iZXI7IGI6IG51bWJlciB9IHtcbiAgY29uc3QgYyA9IEhTVnRvUkdCKE1hdGgucmFuZG9tKCksIDEuMCwgMS4wKTtcbiAgYy5yICo9IDAuNDA7XG4gIGMuZyAqPSAwLjAxO1xuICBjLmIgKj0gMC4xMDtcbiAgcmV0dXJuIGM7XG59XG5cbi8vIFBvaW50ZXIgY2xhc3NcbmNsYXNzIFBvaW50ZXJQcm90b3R5cGUge1xuICBpZCA9IC0xO1xuICB0ZXhjb29yZFggPSAwO1xuICB0ZXhjb29yZFkgPSAwO1xuICBwcmV2VGV4Y29vcmRYID0gMDtcbiAgcHJldlRleGNvb3JkWSA9IDA7XG4gIGRlbHRhWCA9IDA7XG4gIGRlbHRhWSA9IDA7XG4gIGRvd24gPSBmYWxzZTtcbiAgbW92ZWQgPSBmYWxzZTtcbiAgY29sb3IgPSB7IHI6IDMwLCBnOiAwLCBiOiAzMDAgfTtcbn1cblxuLy8gQmFzaWMgV2ViR0wgc2V0dXBcbmZ1bmN0aW9uIGdldFdlYkdMQ29udGV4dChjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KSB7XG4gIGNvbnN0IHBhcmFtcyA9IHtcbiAgICBhbHBoYTogdHJ1ZSxcbiAgICBkZXB0aDogZmFsc2UsXG4gICAgc3RlbmNpbDogZmFsc2UsXG4gICAgYW50aWFsaWFzOiBmYWxzZSxcbiAgICBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IGZhbHNlXG4gIH07XG5cbiAgbGV0IGdsID0gY2FudmFzLmdldENvbnRleHQoXCJ3ZWJnbDJcIiwgcGFyYW1zKSBhcyBXZWJHTDJSZW5kZXJpbmdDb250ZXh0O1xuICBjb25zdCBpc1dlYkdMMiA9ICEhZ2w7XG4gIFxuICBpZiAoIWlzV2ViR0wyKSB7XG4gICAgZ2wgPSBjYW52YXMuZ2V0Q29udGV4dChcIndlYmdsXCIsIHBhcmFtcykgYXMgV2ViR0wyUmVuZGVyaW5nQ29udGV4dCB8fFxuICAgICAgICAgY2FudmFzLmdldENvbnRleHQoXCJleHBlcmltZW50YWwtd2ViZ2xcIiwgcGFyYW1zKSBhcyBXZWJHTDJSZW5kZXJpbmdDb250ZXh0O1xuICB9XG5cbiAgaWYgKCFnbCkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ1dlYkdMIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGdsLmNsZWFyQ29sb3IoMC4wLCAwLjAsIDAuMCwgMS4wKTtcbiAgcmV0dXJuIGdsO1xufVxuXG4vLyBTaW1wbGlmaWVkIHJlbmRlciBsb29wXG5mdW5jdGlvbiByZW5kZXIoKSB7XG4gIGlmICghZ2wgfHwgIWNhbnZhcykgcmV0dXJuO1xuICBcbiAgZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCk7XG4gIFxuICAvLyBDcmVhdGUgYSBzaW1wbGUgYW5pbWF0ZWQgYmFja2dyb3VuZCBlZmZlY3RcbiAgY29uc3QgdGltZSA9IChEYXRlLm5vdygpIC0gc3RhcnRUaW1lKSAvIDEwMDA7XG4gIGNvbnN0IHIgPSBNYXRoLnNpbih0aW1lICogMC4zKSAqIDAuNSArIDAuNTtcbiAgY29uc3QgZyA9IE1hdGguc2luKHRpbWUgKiAwLjUpICogMC41ICsgMC41O1xuICBjb25zdCBiID0gTWF0aC5zaW4odGltZSAqIDAuNykgKiAwLjUgKyAwLjU7XG4gIFxuICBnbC5jbGVhckNvbG9yKHIgKiAwLjEsIGcgKiAwLjAyLCBiICogMC4wNSwgMS4wKTtcbiAgZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCk7XG4gIFxuICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmVuZGVyKTtcbn1cblxuLy8gUmVzaXplIGNhbnZhc1xuZnVuY3Rpb24gcmVzaXplQ2FudmFzKCkge1xuICBpZiAoIWNhbnZhcykgcmV0dXJuIGZhbHNlO1xuICBcbiAgY29uc3Qgd2lkdGggPSBzY2FsZUJ5UGl4ZWxSYXRpbyhjYW52YXMuY2xpZW50V2lkdGgpO1xuICBjb25zdCBoZWlnaHQgPSBzY2FsZUJ5UGl4ZWxSYXRpbyhjYW52YXMuY2xpZW50SGVpZ2h0KTtcbiAgXG4gIGlmIChjYW52YXMud2lkdGggIT09IHdpZHRoIHx8IGNhbnZhcy5oZWlnaHQgIT09IGhlaWdodCkge1xuICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBFdmVudCBoYW5kbGVyc1xuZnVuY3Rpb24gdXBkYXRlUG9pbnRlck1vdmVEYXRhKHBvaW50ZXI6IFBvaW50ZXJQcm90b3R5cGUsIHBvc1g6IG51bWJlciwgcG9zWTogbnVtYmVyKSB7XG4gIGlmICghY2FudmFzKSByZXR1cm47XG4gIFxuICBwb2ludGVyLnByZXZUZXhjb29yZFggPSBwb2ludGVyLnRleGNvb3JkWDtcbiAgcG9pbnRlci5wcmV2VGV4Y29vcmRZID0gcG9pbnRlci50ZXhjb29yZFk7XG4gIHBvaW50ZXIudGV4Y29vcmRYID0gcG9zWCAvIGNhbnZhcy53aWR0aDtcbiAgcG9pbnRlci50ZXhjb29yZFkgPSAxLjAgLSBwb3NZIC8gY2FudmFzLmhlaWdodDtcbiAgcG9pbnRlci5kZWx0YVggPSBwb2ludGVyLnRleGNvb3JkWCAtIHBvaW50ZXIucHJldlRleGNvb3JkWDtcbiAgcG9pbnRlci5kZWx0YVkgPSBwb2ludGVyLnRleGNvb3JkWSAtIHBvaW50ZXIucHJldlRleGNvb3JkWTtcbiAgcG9pbnRlci5tb3ZlZCA9IE1hdGguYWJzKHBvaW50ZXIuZGVsdGFYKSA+IDAgfHwgTWF0aC5hYnMocG9pbnRlci5kZWx0YVkpID4gMDtcbn1cblxuZnVuY3Rpb24gY29ycmVjdERlbHRhWChkZWx0YTogbnVtYmVyKTogbnVtYmVyIHtcbiAgaWYgKCFjYW52YXMpIHJldHVybiBkZWx0YTtcbiAgY29uc3QgYXNwZWN0UmF0aW8gPSBjYW52YXMud2lkdGggLyBjYW52YXMuaGVpZ2h0O1xuICBpZiAoYXNwZWN0UmF0aW8gPCAxKSBkZWx0YSAqPSBhc3BlY3RSYXRpbztcbiAgcmV0dXJuIGRlbHRhO1xufVxuXG5mdW5jdGlvbiBjb3JyZWN0RGVsdGFZKGRlbHRhOiBudW1iZXIpOiBudW1iZXIge1xuICBpZiAoIWNhbnZhcykgcmV0dXJuIGRlbHRhO1xuICBjb25zdCBhc3BlY3RSYXRpbyA9IGNhbnZhcy53aWR0aCAvIGNhbnZhcy5oZWlnaHQ7XG4gIGlmIChhc3BlY3RSYXRpbyA+IDEpIGRlbHRhIC89IGFzcGVjdFJhdGlvO1xuICByZXR1cm4gZGVsdGE7XG59XG5cbmZ1bmN0aW9uIHNwbGF0UG9pbnRlcihwb2ludGVyOiBQb2ludGVyUHJvdG90eXBlKSB7XG4gIGNvbnN0IGR4ID0gY29ycmVjdERlbHRhWChwb2ludGVyLmRlbHRhWCkgKiBjb25maWcuU1BMQVRfRk9SQ0U7XG4gIGNvbnN0IGR5ID0gY29ycmVjdERlbHRhWShwb2ludGVyLmRlbHRhWSkgKiBjb25maWcuU1BMQVRfRk9SQ0U7XG4gIHNwbGF0KHBvaW50ZXIudGV4Y29vcmRYLCBwb2ludGVyLnRleGNvb3JkWSwgZHgsIGR5LCBwb2ludGVyLmNvbG9yKTtcbn1cblxuZnVuY3Rpb24gc3BsYXQoeDogbnVtYmVyLCB5OiBudW1iZXIsIGR4OiBudW1iZXIsIGR5OiBudW1iZXIsIGNvbG9yOiB7IHI6IG51bWJlcjsgZzogbnVtYmVyOyBiOiBudW1iZXIgfSkge1xuICAvLyBUaGlzIGlzIGEgc2ltcGxpZmllZCBzcGxhdCBlZmZlY3QgLSBpbiB0aGUgZnVsbCB2ZXJzaW9uIHRoaXMgd291bGQgdXBkYXRlIGZsdWlkIHRleHR1cmVzXG4gIC8vIEZvciBub3csIHdlJ2xsIGp1c3QgY3JlYXRlIGEgdmlzdWFsIGVmZmVjdFxuICBpZiAoIWdsIHx8ICFjYW52YXMpIHJldHVybjtcbiAgXG4gIC8vIENyZWF0ZSBhIHNpbXBsZSBjb2xvcmVkIGNpcmNsZSBlZmZlY3RcbiAgY29uc3QgY2VudGVyWCA9IHggKiBjYW52YXMud2lkdGg7XG4gIGNvbnN0IGNlbnRlclkgPSAoMSAtIHkpICogY2FudmFzLmhlaWdodDtcbiAgY29uc3QgcmFkaXVzID0gNTA7XG4gIFxuICAvLyBUaGlzIHdvdWxkIG5vcm1hbGx5IHVwZGF0ZSB0aGUgZmx1aWQgc2ltdWxhdGlvbiB0ZXh0dXJlc1xuICAvLyBGb3Igbm93LCBqdXN0IHRyaWdnZXIgYSB2aXN1YWwgdXBkYXRlXG59XG5cbi8vIEV2ZW50IGxpc3RlbmVyc1xuZnVuY3Rpb24gYXR0YWNoRXZlbnRMaXN0ZW5lcnMoKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyB8fCAhY2FudmFzKSByZXR1cm47XG5cbiAgY29uc3QgYm9keSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2JvZHknKTtcbiAgaWYgKCFib2R5KSByZXR1cm47XG5cbiAgY29uc3QgbW91c2VNb3ZlSGFuZGxlciA9IChlOiBNb3VzZUV2ZW50KSA9PiB7XG4gICAgaWYgKCFwb2ludGVycyB8fCAhcG9pbnRlcnNbMF0pIHJldHVybjtcbiAgICBjb25zdCBwb2ludGVyID0gcG9pbnRlcnNbMF07XG4gICAgY29uc3QgcG9zWCA9IHNjYWxlQnlQaXhlbFJhdGlvKGUuY2xpZW50WCk7XG4gICAgY29uc3QgcG9zWSA9IHNjYWxlQnlQaXhlbFJhdGlvKGUuY2xpZW50WSk7XG4gICAgdXBkYXRlUG9pbnRlck1vdmVEYXRhKHBvaW50ZXIsIHBvc1gsIHBvc1kpO1xuICAgIFxuICAgIC8vIEFwcGx5IHNwbGF0IGVmZmVjdCB3aGVuIG1vdXNlIG1vdmVzXG4gICAgaWYgKHBvaW50ZXIubW92ZWQpIHtcbiAgICAgIHBvaW50ZXIubW92ZWQgPSBmYWxzZTtcbiAgICAgIHNwbGF0UG9pbnRlcihwb2ludGVyKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgdG91Y2hTdGFydEhhbmRsZXIgPSAoZTogVG91Y2hFdmVudCkgPT4ge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBpZiAoIXBvaW50ZXJzKSByZXR1cm47XG4gICAgY29uc3QgdG91Y2hlcyA9IGUudGFyZ2V0VG91Y2hlcztcbiAgICBcbiAgICB3aGlsZSAodG91Y2hlcy5sZW5ndGggPj0gcG9pbnRlcnMubGVuZ3RoKSB7XG4gICAgICBwb2ludGVycy5wdXNoKG5ldyBQb2ludGVyUHJvdG90eXBlKCkpO1xuICAgIH1cbiAgICBcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRvdWNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHBvc1ggPSBzY2FsZUJ5UGl4ZWxSYXRpbyh0b3VjaGVzW2ldLmNsaWVudFgpO1xuICAgICAgY29uc3QgcG9zWSA9IHNjYWxlQnlQaXhlbFJhdGlvKHRvdWNoZXNbaV0uY2xpZW50WSk7XG4gICAgICBjb25zdCBwb2ludGVyID0gcG9pbnRlcnNbaSArIDFdO1xuICAgICAgaWYgKHBvaW50ZXIpIHtcbiAgICAgICAgcG9pbnRlci5pZCA9IHRvdWNoZXNbaV0uaWRlbnRpZmllcjtcbiAgICAgICAgcG9pbnRlci5kb3duID0gdHJ1ZTtcbiAgICAgICAgcG9pbnRlci5tb3ZlZCA9IGZhbHNlO1xuICAgICAgICBwb2ludGVyLnRleGNvb3JkWCA9IHBvc1ggLyBjYW52YXMhLndpZHRoO1xuICAgICAgICBwb2ludGVyLnRleGNvb3JkWSA9IDEuMCAtIHBvc1kgLyBjYW52YXMhLmhlaWdodDtcbiAgICAgICAgcG9pbnRlci5wcmV2VGV4Y29vcmRYID0gcG9pbnRlci50ZXhjb29yZFg7XG4gICAgICAgIHBvaW50ZXIucHJldlRleGNvb3JkWSA9IHBvaW50ZXIudGV4Y29vcmRZO1xuICAgICAgICBwb2ludGVyLmRlbHRhWCA9IDA7XG4gICAgICAgIHBvaW50ZXIuZGVsdGFZID0gMDtcbiAgICAgICAgcG9pbnRlci5jb2xvciA9IGdlbmVyYXRlQ29sb3IoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgY29uc3QgdG91Y2hNb3ZlSGFuZGxlciA9IChlOiBUb3VjaEV2ZW50KSA9PiB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGlmICghcG9pbnRlcnMpIHJldHVybjtcbiAgICBjb25zdCB0b3VjaGVzID0gZS50YXJnZXRUb3VjaGVzO1xuICAgIFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG91Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcG9pbnRlciA9IHBvaW50ZXJzW2kgKyAxXTtcbiAgICAgIGlmICghcG9pbnRlciB8fCAhcG9pbnRlci5kb3duKSBjb250aW51ZTtcbiAgICAgIGNvbnN0IHBvc1ggPSBzY2FsZUJ5UGl4ZWxSYXRpbyh0b3VjaGVzW2ldLmNsaWVudFgpO1xuICAgICAgY29uc3QgcG9zWSA9IHNjYWxlQnlQaXhlbFJhdGlvKHRvdWNoZXNbaV0uY2xpZW50WSk7XG4gICAgICB1cGRhdGVQb2ludGVyTW92ZURhdGEocG9pbnRlciwgcG9zWCwgcG9zWSk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IHRvdWNoRW5kSGFuZGxlciA9IChlOiBUb3VjaEV2ZW50KSA9PiB7XG4gICAgaWYgKCFwb2ludGVycykgcmV0dXJuO1xuICAgIGNvbnN0IHRvdWNoZXMgPSBlLmNoYW5nZWRUb3VjaGVzO1xuICAgIFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG91Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcG9pbnRlciA9IHBvaW50ZXJzLmZpbmQoKHA6IFBvaW50ZXJQcm90b3R5cGUpID0+IHAuaWQgPT09IHRvdWNoZXNbaV0uaWRlbnRpZmllcik7XG4gICAgICBpZiAocG9pbnRlcikge1xuICAgICAgICBwb2ludGVyLmRvd24gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgYm9keS5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIG1vdXNlTW92ZUhhbmRsZXIpO1xuICBib2R5LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsIHRvdWNoU3RhcnRIYW5kbGVyKTtcbiAgYm9keS5hZGRFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIHRvdWNoTW92ZUhhbmRsZXIsIHsgcGFzc2l2ZTogZmFsc2UgfSk7XG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgdG91Y2hFbmRIYW5kbGVyKTtcbn1cblxuLy8gTWFpbiBpbml0aWFsaXphdGlvbiBmdW5jdGlvblxuZXhwb3J0IGZ1bmN0aW9uIGluaXRGbHVpZFNpbXVsYXRpb24oKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuO1xuICBcbiAgaWYgKGZsdWlkSW5pdGlhbGl6ZWQpIHtcbiAgICBjb25zb2xlLmxvZygnRmx1aWQgYWxyZWFkeSBpbml0aWFsaXplZCwgc2tpcHBpbmcgV2ViR0wgc2V0dXAuLi4nKTtcbiAgICBhdHRhY2hFdmVudExpc3RlbmVycygpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnNvbGUubG9nKCdJbml0aWFsaXppbmcgZmx1aWQgc2ltdWxhdGlvbi4uLicpO1xuXG4gIGNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZmx1aWRcIikgYXMgSFRNTENhbnZhc0VsZW1lbnQ7XG4gIFxuICBpZiAoIWNhbnZhcykge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0ZsdWlkIGNhbnZhcyBub3QgZm91bmQnKTtcbiAgICByZXR1cm47XG4gIH1cblxuICByZXNpemVDYW52YXMoKTtcbiAgXG4gIGdsID0gZ2V0V2ViR0xDb250ZXh0KGNhbnZhcyk7XG4gIGlmICghZ2wpIHtcbiAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gZ2V0IFdlYkdMIGNvbnRleHQnKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBJbml0aWFsaXplIGJhc2ljIGNvbmZpZ1xuICBjb25maWcgPSB7XG4gICAgREVOU0lUWV9ESVNTSVBBVElPTjogMixcbiAgICBWRUxPQ0lUWV9ESVNTSVBBVElPTjogMC4xLFxuICAgIFBSRVNTVVJFOiAwLjAxLFxuICAgIENVUkw6IDEwMCxcbiAgICBTUExBVF9SQURJVVM6IDAuMTMsXG4gICAgU1BMQVRfRk9SQ0U6IDUwMDAsXG4gICAgQ09MT1JGVUw6IHRydWUsXG4gICAgQ09MT1JfVVBEQVRFX1NQRUVEOiAzLFxuICAgIFBBVVNFRDogZmFsc2UsXG4gIH07XG5cbiAgLy8gSW5pdGlhbGl6ZSBwb2ludGVyc1xuICBwb2ludGVycyA9IFtdO1xuICBwb2ludGVycy5wdXNoKG5ldyBQb2ludGVyUHJvdG90eXBlKCkpO1xuXG4gIC8vIFN0YXJ0IHJlbmRlciBsb29wXG4gIGxhc3RVcGRhdGVUaW1lID0gRGF0ZS5ub3coKTtcbiAgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgXG4gIC8vIEF0dGFjaCBldmVudCBsaXN0ZW5lcnNcbiAgYXR0YWNoRXZlbnRMaXN0ZW5lcnMoKTtcbiAgXG4gIC8vIFN0YXJ0IHJlbmRlcmluZ1xuICByZW5kZXIoKTtcblxuICBmbHVpZEluaXRpYWxpemVkID0gdHJ1ZTtcbiAgY29uc29sZS5sb2coJ0ZsdWlkIHNpbXVsYXRpb24gaW5pdGlhbGl6ZWQgc3VjY2Vzc2Z1bGx5IScpO1xufVxuIl0sIm5hbWVzIjpbImZsdWlkSW5pdGlhbGl6ZWQiLCJjYW52YXMiLCJnbCIsImNvbmZpZyIsInBvaW50ZXJzIiwiZHllIiwidmVsb2NpdHkiLCJsYXN0VXBkYXRlVGltZSIsInN0YXJ0VGltZSIsInNjYWxlQnlQaXhlbFJhdGlvIiwiaW5wdXQiLCJwaXhlbFJhdGlvIiwid2luZG93IiwiZGV2aWNlUGl4ZWxSYXRpbyIsIk1hdGgiLCJmbG9vciIsIkhTVnRvUkdCIiwiaCIsInMiLCJ2IiwiciIsImciLCJiIiwiaSIsImYiLCJwIiwicSIsInQiLCJnZW5lcmF0ZUNvbG9yIiwiYyIsInJhbmRvbSIsIlBvaW50ZXJQcm90b3R5cGUiLCJpZCIsInRleGNvb3JkWCIsInRleGNvb3JkWSIsInByZXZUZXhjb29yZFgiLCJwcmV2VGV4Y29vcmRZIiwiZGVsdGFYIiwiZGVsdGFZIiwiZG93biIsIm1vdmVkIiwiY29sb3IiLCJnZXRXZWJHTENvbnRleHQiLCJwYXJhbXMiLCJhbHBoYSIsImRlcHRoIiwic3RlbmNpbCIsImFudGlhbGlhcyIsInByZXNlcnZlRHJhd2luZ0J1ZmZlciIsImdldENvbnRleHQiLCJpc1dlYkdMMiIsImNvbnNvbGUiLCJlcnJvciIsImNsZWFyQ29sb3IiLCJyZW5kZXIiLCJjbGVhciIsIkNPTE9SX0JVRkZFUl9CSVQiLCJ0aW1lIiwiRGF0ZSIsIm5vdyIsInNpbiIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsInJlc2l6ZUNhbnZhcyIsIndpZHRoIiwiY2xpZW50V2lkdGgiLCJoZWlnaHQiLCJjbGllbnRIZWlnaHQiLCJ1cGRhdGVQb2ludGVyTW92ZURhdGEiLCJwb2ludGVyIiwicG9zWCIsInBvc1kiLCJhYnMiLCJjb3JyZWN0RGVsdGFYIiwiZGVsdGEiLCJhc3BlY3RSYXRpbyIsImNvcnJlY3REZWx0YVkiLCJzcGxhdFBvaW50ZXIiLCJkeCIsIlNQTEFUX0ZPUkNFIiwiZHkiLCJzcGxhdCIsIngiLCJ5IiwiY2VudGVyWCIsImNlbnRlclkiLCJyYWRpdXMiLCJhdHRhY2hFdmVudExpc3RlbmVycyIsImJvZHkiLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3IiLCJtb3VzZU1vdmVIYW5kbGVyIiwiZSIsImNsaWVudFgiLCJjbGllbnRZIiwidG91Y2hTdGFydEhhbmRsZXIiLCJwcmV2ZW50RGVmYXVsdCIsInRvdWNoZXMiLCJ0YXJnZXRUb3VjaGVzIiwibGVuZ3RoIiwicHVzaCIsImlkZW50aWZpZXIiLCJ0b3VjaE1vdmVIYW5kbGVyIiwidG91Y2hFbmRIYW5kbGVyIiwiY2hhbmdlZFRvdWNoZXMiLCJmaW5kIiwiYWRkRXZlbnRMaXN0ZW5lciIsInBhc3NpdmUiLCJpbml0Rmx1aWRTaW11bGF0aW9uIiwibG9nIiwiZ2V0RWxlbWVudEJ5SWQiLCJERU5TSVRZX0RJU1NJUEFUSU9OIiwiVkVMT0NJVFlfRElTU0lQQVRJT04iLCJQUkVTU1VSRSIsIkNVUkwiLCJTUExBVF9SQURJVVMiLCJDT0xPUkZVTCIsIkNPTE9SX1VQREFURV9TUEVFRCIsIlBBVVNFRCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/lib/fluid.ts\n"));

/***/ })

});