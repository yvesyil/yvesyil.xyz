"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_app-pages-browser_app_lib_polaroid-cursor_ts",{

/***/ "(app-pages-browser)/./app/lib/polaroid-cursor.ts":
/*!************************************!*\
  !*** ./app/lib/polaroid-cursor.ts ***!
  \************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cleanupPolaroidCursor: function() { return /* binding */ cleanupPolaroidCursor; },\n/* harmony export */   initPolaroidCursor: function() { return /* binding */ initPolaroidCursor; }\n/* harmony export */ });\n// Polaroid Cursor Effect\n// Creates polaroid photos that follow mouse movement\nlet polaroidInitialized = false;\nlet container = null;\nlet polaroids = [];\nlet mouseX = 0;\nlet mouseY = 0;\nlet lastMouseX = 0;\nlet lastMouseY = 0;\nlet spawnTimer = 0; // Timer for consistent spawning\nlet isMouseMoving = false;\n// All available photos - only from public/photos/\nconst photoList = [\n    \"/photos/AStreetInHaarlem.jpg\",\n    \"/photos/Autopark.jpg\",\n    \"/photos/DeBurcht.jpg\",\n    \"/photos/SAIL.jpg\",\n    \"/photos/SintBonifatiuskerk.jpg\"\n];\nconst config = {\n    maxPolaroids: 10,\n    polaroidLife: 180,\n    spawnInterval: 8,\n    fadeOutDuration: 45,\n    minMovementThreshold: 2,\n    polaroidSize: 140\n};\nfunction getRandomPhoto() {\n    return photoList[Math.floor(Math.random() * photoList.length)];\n}\nfunction createPolaroidElement(x, y) {\n    const element = document.createElement(\"div\");\n    const image = getRandomPhoto();\n    element.className = \"polaroid-photo\";\n    element.innerHTML = '\\n    <div class=\"polaroid-inner\">\\n      <img src=\"'.concat(image, '\" alt=\"Random photo\" />\\n      <div class=\"polaroid-caption\"></div>\\n    </div>\\n  ');\n    // Random rotation and slight scale variation\n    const rotation = (Math.random() - 0.5) * 30; // -15 to 15 degrees\n    const scale = 0.8 + Math.random() * 0.4; // 0.8 to 1.2\n    element.style.cssText = \"\\n    position: fixed;\\n    width: \".concat(config.polaroidSize, \"px;\\n    height: \").concat(config.polaroidSize * 1.2, \"px;\\n    pointer-events: none;\\n    z-index: 1000;\\n    transform: translate(-50%, -50%) rotate(\").concat(rotation, \"deg) scale(\").concat(scale, \");\\n    transition: none;\\n  \");\n    const polaroidElement = {\n        element,\n        x,\n        y,\n        rotation,\n        scale,\n        opacity: 1,\n        life: config.polaroidLife,\n        maxLife: config.polaroidLife,\n        vx: (Math.random() - 0.5) * 2,\n        vy: (Math.random() - 0.5) * 2,\n        image\n    };\n    if (container) {\n        container.appendChild(element);\n    }\n    return polaroidElement;\n}\nfunction updatePolaroids() {\n    // Update existing polaroids\n    for(let i = polaroids.length - 1; i >= 0; i--){\n        const polaroid = polaroids[i];\n        // Update position with slight drift\n        polaroid.x += polaroid.vx;\n        polaroid.y += polaroid.vy;\n        // Apply slight drag\n        polaroid.vx *= 0.98;\n        polaroid.vy *= 0.98;\n        // Update life\n        polaroid.life--;\n        // Calculate opacity based on remaining life\n        if (polaroid.life < config.fadeOutDuration) {\n            polaroid.opacity = polaroid.life / config.fadeOutDuration;\n        }\n        // Update element position and opacity\n        polaroid.element.style.left = \"\".concat(polaroid.x, \"px\");\n        polaroid.element.style.top = \"\".concat(polaroid.y, \"px\");\n        polaroid.element.style.opacity = polaroid.opacity.toString();\n        // Remove dead polaroids\n        if (polaroid.life <= 0) {\n            if (container && polaroid.element.parentNode) {\n                container.removeChild(polaroid.element);\n            }\n            polaroids.splice(i, 1);\n        }\n    }\n    // Timer-based continuous spawning - predictable and smooth\n    const dx = mouseX - lastMouseX;\n    const dy = mouseY - lastMouseY;\n    const movement = Math.sqrt(dx * dx + dy * dy);\n    // Check if mouse is moving\n    isMouseMoving = movement > config.minMovementThreshold;\n    // Increment spawn timer\n    spawnTimer++;\n    // Spawn at regular intervals while mouse is moving\n    if (isMouseMoving && polaroids.length < config.maxPolaroids) {\n        // Regular spawning every N frames\n        if (spawnTimer >= config.spawnInterval) {\n            const spawnX = mouseX + (Math.random() - 0.5) * 50;\n            const spawnY = mouseY + (Math.random() - 0.5) * 50;\n            polaroids.push(createPolaroidElement(spawnX, spawnY));\n            spawnTimer = 0; // Reset timer\n        }\n        // Additional spawning for fast movement\n        if (movement > 10 && spawnTimer >= config.spawnInterval / 2) {\n            const spawnX = mouseX + (Math.random() - 0.5) * 40;\n            const spawnY = mouseY + (Math.random() - 0.5) * 40;\n            polaroids.push(createPolaroidElement(spawnX, spawnY));\n            spawnTimer = 0; // Reset timer\n        }\n    }\n    // Reset timer if mouse stops moving\n    if (!isMouseMoving) {\n        spawnTimer = 0;\n    }\n    lastMouseX = mouseX;\n    lastMouseY = mouseY;\n}\nfunction animate() {\n    updatePolaroids();\n    requestAnimationFrame(animate);\n}\n// Event handlers\nfunction attachEventListeners() {\n    if (false) {}\n    const mouseMoveHandler = (e)=>{\n        mouseX = e.clientX;\n        mouseY = e.clientY;\n    };\n    const mouseEnterHandler = (e)=>{\n        // Initialize mouse position when entering the page\n        mouseX = e.clientX;\n        mouseY = e.clientY;\n        lastMouseX = mouseX;\n        lastMouseY = mouseY;\n    };\n    const touchMoveHandler = (e)=>{\n        e.preventDefault();\n        if (e.touches.length > 0) {\n            const touch = e.touches[0];\n            mouseX = touch.clientX;\n            mouseY = touch.clientY;\n        }\n    };\n    const touchStartHandler = (e)=>{\n        if (e.touches.length > 0) {\n            const touch = e.touches[0];\n            mouseX = touch.clientX;\n            mouseY = touch.clientY;\n            lastMouseX = mouseX;\n            lastMouseY = mouseY;\n        }\n    };\n    document.addEventListener(\"mousemove\", mouseMoveHandler);\n    document.addEventListener(\"mouseenter\", mouseEnterHandler);\n    document.addEventListener(\"touchmove\", touchMoveHandler, {\n        passive: false\n    });\n    document.addEventListener(\"touchstart\", touchStartHandler, {\n        passive: true\n    });\n}\n// Main initialization function\nfunction initPolaroidCursor() {\n    if (false) {}\n    if (polaroidInitialized) {\n        console.log(\"Polaroid cursor already initialized\");\n        return;\n    }\n    console.log(\"Initializing polaroid cursor effect...\");\n    // Create container for polaroids\n    container = document.createElement(\"div\");\n    container.id = \"polaroid-container\";\n    container.style.cssText = \"\\n    position: fixed;\\n    top: 0;\\n    left: 0;\\n    width: 100vw;\\n    height: 100vh;\\n    pointer-events: none;\\n    z-index: 1000;\\n  \";\n    document.body.appendChild(container);\n    // Initialize mouse position to center, but will be updated on first mouse move\n    mouseX = window.innerWidth / 2;\n    mouseY = window.innerHeight / 2;\n    lastMouseX = mouseX;\n    lastMouseY = mouseY;\n    // Get actual mouse position if available\n    document.addEventListener(\"mousemove\", (e)=>{\n        if (mouseX === window.innerWidth / 2 && mouseY === window.innerHeight / 2) {\n            // First mouse move - initialize properly\n            mouseX = e.clientX;\n            mouseY = e.clientY;\n            lastMouseX = mouseX;\n            lastMouseY = mouseY;\n        }\n    }, {\n        once: true\n    });\n    // Attach event listeners\n    attachEventListeners();\n    // Start animation loop\n    animate();\n    polaroidInitialized = true;\n    console.log(\"Polaroid cursor effect initialized successfully!\");\n}\n// Cleanup function\nfunction cleanupPolaroidCursor() {\n    if (container && container.parentNode) {\n        document.body.removeChild(container);\n    }\n    polaroids.forEach((polaroid)=>{\n        if (polaroid.element.parentNode) {\n            polaroid.element.parentNode.removeChild(polaroid.element);\n        }\n    });\n    polaroids = [];\n    container = null;\n    polaroidInitialized = false;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9saWIvcG9sYXJvaWQtY3Vyc29yLnRzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUEseUJBQXlCO0FBQ3pCLHFEQUFxRDtBQUVyRCxJQUFJQSxzQkFBc0I7QUFDMUIsSUFBSUMsWUFBbUM7QUFDdkMsSUFBSUMsWUFBK0IsRUFBRTtBQUNyQyxJQUFJQyxTQUFTO0FBQ2IsSUFBSUMsU0FBUztBQUNiLElBQUlDLGFBQWE7QUFDakIsSUFBSUMsYUFBYTtBQUNqQixJQUFJQyxhQUFhLEdBQUcsZ0NBQWdDO0FBQ3BELElBQUlDLGdCQUFnQjtBQWdCcEIsa0RBQWtEO0FBQ2xELE1BQU1DLFlBQVk7SUFDaEI7SUFDQTtJQUNBO0lBQ0E7SUFDQTtDQUNEO0FBRUQsTUFBTUMsU0FBUztJQUNiQyxjQUFjO0lBQ2RDLGNBQWM7SUFDZEMsZUFBZTtJQUNmQyxpQkFBaUI7SUFDakJDLHNCQUFzQjtJQUN0QkMsY0FBYztBQUNoQjtBQUVBLFNBQVNDO0lBQ1AsT0FBT1IsU0FBUyxDQUFDUyxLQUFLQyxLQUFLLENBQUNELEtBQUtFLE1BQU0sS0FBS1gsVUFBVVksTUFBTSxFQUFFO0FBQ2hFO0FBRUEsU0FBU0Msc0JBQXNCQyxDQUFTLEVBQUVDLENBQVM7SUFDakQsTUFBTUMsVUFBVUMsU0FBU0MsYUFBYSxDQUFDO0lBQ3ZDLE1BQU1DLFFBQVFYO0lBRWRRLFFBQVFJLFNBQVMsR0FBRztJQUNwQkosUUFBUUssU0FBUyxHQUFHLHVEQUVFLE9BQU5GLE9BQU07SUFLdEIsNkNBQTZDO0lBQzdDLE1BQU1HLFdBQVcsQ0FBQ2IsS0FBS0UsTUFBTSxLQUFLLEdBQUUsSUFBSyxJQUFJLG9CQUFvQjtJQUNqRSxNQUFNWSxRQUFRLE1BQU1kLEtBQUtFLE1BQU0sS0FBSyxLQUFLLGFBQWE7SUFFdERLLFFBQVFRLEtBQUssQ0FBQ0MsT0FBTyxHQUFHLHNDQUdaeEIsT0FEREEsT0FBT00sWUFBWSxFQUFDLHFCQUlhZSxPQUhoQ3JCLE9BQU9NLFlBQVksR0FBRyxL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QUFJLENBQUM1QixXQUFXLENBQUNoRDtJQUM1QjtJQUVBQyxVQUFVaUYsT0FBTyxDQUFDdkMsQ0FBQUE7UUFDaEIsSUFBSUEsU0FBU25CLE9BQU8sQ0FBQ3VCLFVBQVUsRUFBRTtZQUMvQkosU0FBU25CLE9BQU8sQ0FBQ3VCLFVBQVUsQ0FBQ0MsV0FBVyxDQUFDTCxTQUFTbkIsT0FBTztRQUMxRDtJQUNGO0lBRUF2QixZQUFZLEVBQUU7SUFDZEQsWUFBWTtJQUNaRCxzQkFBc0I7QUFDeEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vYXBwL2xpYi9wb2xhcm9pZC1jdXJzb3IudHM/ODI2NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBQb2xhcm9pZCBDdXJzb3IgRWZmZWN0XG4vLyBDcmVhdGVzIHBvbGFyb2lkIHBob3RvcyB0aGF0IGZvbGxvdyBtb3VzZSBtb3ZlbWVudFxuXG5sZXQgcG9sYXJvaWRJbml0aWFsaXplZCA9IGZhbHNlO1xubGV0IGNvbnRhaW5lcjogSFRNTERpdkVsZW1lbnQgfCBudWxsID0gbnVsbDtcbmxldCBwb2xhcm9pZHM6IFBvbGFyb2lkRWxlbWVudFtdID0gW107XG5sZXQgbW91c2VYID0gMDtcbmxldCBtb3VzZVkgPSAwO1xubGV0IGxhc3RNb3VzZVggPSAwO1xubGV0IGxhc3RNb3VzZVkgPSAwO1xubGV0IHNwYXduVGltZXIgPSAwOyAvLyBUaW1lciBmb3IgY29uc2lzdGVudCBzcGF3bmluZ1xubGV0IGlzTW91c2VNb3ZpbmcgPSBmYWxzZTtcblxuaW50ZXJmYWNlIFBvbGFyb2lkRWxlbWVudCB7XG4gIGVsZW1lbnQ6IEhUTUxEaXZFbGVtZW50O1xuICB4OiBudW1iZXI7XG4gIHk6IG51bWJlcjtcbiAgcm90YXRpb246IG51bWJlcjtcbiAgc2NhbGU6IG51bWJlcjtcbiAgb3BhY2l0eTogbnVtYmVyO1xuICBsaWZlOiBudW1iZXI7XG4gIG1heExpZmU6IG51bWJlcjtcbiAgdng6IG51bWJlcjtcbiAgdnk6IG51bWJlcjtcbiAgaW1hZ2U6IHN0cmluZztcbn1cblxuLy8gQWxsIGF2YWlsYWJsZSBwaG90b3MgLSBvbmx5IGZyb20gcHVibGljL3Bob3Rvcy9cbmNvbnN0IHBob3RvTGlzdCA9IFtcbiAgJy9waG90b3MvQVN0cmVldEluSGFhcmxlbS5qcGcnLFxuICAnL3Bob3Rvcy9BdXRvcGFyay5qcGcnLFxuICAnL3Bob3Rvcy9EZUJ1cmNodC5qcGcnLFxuICAnL3Bob3Rvcy9TQUlMLmpwZycsXG4gICcvcGhvdG9zL1NpbnRCb25pZmF0aXVza2Vyay5qcGcnLFxuXTtcblxuY29uc3QgY29uZmlnID0ge1xuICBtYXhQb2xhcm9pZHM6IDEwLCAvLyBHb29kIGJhbGFuY2UgZm9yIGNvbnRpbnVvdXMgZmxvd1xuICBwb2xhcm9pZExpZmU6IDE4MCwgLy8gTGlmZSBpbiBmcmFtZXMgKDMgc2Vjb25kcyBhdCA2MGZwcylcbiAgc3Bhd25JbnRlcnZhbDogOCwgLy8gU3Bhd24gZXZlcnkgOCBmcmFtZXMgKGFib3V0IDcuNSB0aW1lcyBwZXIgc2Vjb25kKVxuICBmYWRlT3V0RHVyYXRpb246IDQ1LCAvLyBGYWRlIGR1cmF0aW9uIGluIGZyYW1lc1xuICBtaW5Nb3ZlbWVudFRocmVzaG9sZDogMiwgLy8gTWluaW11bSBtb3ZlbWVudCB0byB0cmlnZ2VyIHNwYXduaW5nXG4gIHBvbGFyb2lkU2l6ZTogMTQwLCAvLyBCaWdnZXIgcGhvdG9zXG59O1xuXG5mdW5jdGlvbiBnZXRSYW5kb21QaG90bygpOiBzdHJpbmcge1xuICByZXR1cm4gcGhvdG9MaXN0W01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHBob3RvTGlzdC5sZW5ndGgpXTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUG9sYXJvaWRFbGVtZW50KHg6IG51bWJlciwgeTogbnVtYmVyKTogUG9sYXJvaWRFbGVtZW50IHtcbiAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBjb25zdCBpbWFnZSA9IGdldFJhbmRvbVBob3RvKCk7XG4gIFxuICBlbGVtZW50LmNsYXNzTmFtZSA9ICdwb2xhcm9pZC1waG90byc7XG4gIGVsZW1lbnQuaW5uZXJIVE1MID0gYFxuICAgIDxkaXYgY2xhc3M9XCJwb2xhcm9pZC1pbm5lclwiPlxuICAgICAgPGltZyBzcmM9XCIke2ltYWdlfVwiIGFsdD1cIlJhbmRvbSBwaG90b1wiIC8+XG4gICAgICA8ZGl2IGNsYXNzPVwicG9sYXJvaWQtY2FwdGlvblwiPjwvZGl2PlxuICAgIDwvZGl2PlxuICBgO1xuICBcbiAgLy8gUmFuZG9tIHJvdGF0aW9uIGFuZCBzbGlnaHQgc2NhbGUgdmFyaWF0aW9uXG4gIGNvbnN0IHJvdGF0aW9uID0gKE1hdGgucmFuZG9tKCkgLSAwLjUpICogMzA7IC8vIC0xNSB0byAxNSBkZWdyZWVzXG4gIGNvbnN0IHNjYWxlID0gMC44ICsgTWF0aC5yYW5kb20oKSAqIDAuNDsgLy8gMC44IHRvIDEuMlxuICBcbiAgZWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gYFxuICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICB3aWR0aDogJHtjb25maWcucG9sYXJvaWRTaXplfXB4O1xuICAgIGhlaWdodDogJHtjb25maWcucG9sYXJvaWRTaXplICogMS4yfXB4O1xuICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICAgIHotaW5kZXg6IDEwMDA7XG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTUwJSwgLTUwJSkgcm90YXRlKCR7cm90YXRpb259ZGVnKSBzY2FsZSgke3NjYWxlfSk7XG4gICAgdHJhbnNpdGlvbjogbm9uZTtcbiAgYDtcbiAgXG4gIGNvbnN0IHBvbGFyb2lkRWxlbWVudDogUG9sYXJvaWRFbGVtZW50ID0ge1xuICAgIGVsZW1lbnQsXG4gICAgeCxcbiAgICB5LFxuICAgIHJvdGF0aW9uLFxuICAgIHNjYWxlLFxuICAgIG9wYWNpdHk6IDEsXG4gICAgbGlmZTogY29uZmlnLnBvbGFyb2lkTGlmZSxcbiAgICBtYXhMaWZlOiBjb25maWcucG9sYXJvaWRMaWZlLFxuICAgIHZ4OiAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAyLFxuICAgIHZ5OiAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAyLFxuICAgIGltYWdlXG4gIH07XG4gIFxuICBpZiAoY29udGFpbmVyKSB7XG4gICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICB9XG4gIFxuICByZXR1cm4gcG9sYXJvaWRFbGVtZW50O1xufVxuXG5mdW5jdGlvbiB1cGRhdGVQb2xhcm9pZHMoKSB7XG4gIC8vIFVwZGF0ZSBleGlzdGluZyBwb2xhcm9pZHNcbiAgZm9yIChsZXQgaSA9IHBvbGFyb2lkcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGNvbnN0IHBvbGFyb2lkID0gcG9sYXJvaWRzW2ldO1xuICAgIFxuICAgIC8vIFVwZGF0ZSBwb3NpdGlvbiB3aXRoIHNsaWdodCBkcmlmdFxuICAgIHBvbGFyb2lkLnggKz0gcG9sYXJvaWQudng7XG4gICAgcG9sYXJvaWQueSArPSBwb2xhcm9pZC52eTtcbiAgICBcbiAgICAvLyBBcHBseSBzbGlnaHQgZHJhZ1xuICAgIHBvbGFyb2lkLnZ4ICo9IDAuOTg7XG4gICAgcG9sYXJvaWQudnkgKj0gMC45ODtcbiAgICBcbiAgICAvLyBVcGRhdGUgbGlmZVxuICAgIHBvbGFyb2lkLmxpZmUtLTtcbiAgICBcbiAgICAvLyBDYWxjdWxhdGUgb3BhY2l0eSBiYXNlZCBvbiByZW1haW5pbmcgbGlmZVxuICAgIGlmIChwb2xhcm9pZC5saWZlIDwgY29uZmlnLmZhZGVPdXREdXJhdGlvbikge1xuICAgICAgcG9sYXJvaWQub3BhY2l0eSA9IHBvbGFyb2lkLmxpZmUgLyBjb25maWcuZmFkZU91dER1cmF0aW9uO1xuICAgIH1cbiAgICBcbiAgICAvLyBVcGRhdGUgZWxlbWVudCBwb3NpdGlvbiBhbmQgb3BhY2l0eVxuICAgIHBvbGFyb2lkLmVsZW1lbnQuc3R5bGUubGVmdCA9IGAke3BvbGFyb2lkLnh9cHhgO1xuICAgIHBvbGFyb2lkLmVsZW1lbnQuc3R5bGUudG9wID0gYCR7cG9sYXJvaWQueX1weGA7XG4gICAgcG9sYXJvaWQuZWxlbWVudC5zdHlsZS5vcGFjaXR5ID0gcG9sYXJvaWQub3BhY2l0eS50b1N0cmluZygpO1xuICAgIFxuICAgIC8vIFJlbW92ZSBkZWFkIHBvbGFyb2lkc1xuICAgIGlmIChwb2xhcm9pZC5saWZlIDw9IDApIHtcbiAgICAgIGlmIChjb250YWluZXIgJiYgcG9sYXJvaWQuZWxlbWVudC5wYXJlbnROb2RlKSB7XG4gICAgICAgIGNvbnRhaW5lci5yZW1vdmVDaGlsZChwb2xhcm9pZC5lbGVtZW50KTtcbiAgICAgIH1cbiAgICAgIHBvbGFyb2lkcy5zcGxpY2UoaSwgMSk7XG4gICAgfVxuICB9XG4gIFxuICAvLyBUaW1lci1iYXNlZCBjb250aW51b3VzIHNwYXduaW5nIC0gcHJlZGljdGFibGUgYW5kIHNtb290aFxuICBjb25zdCBkeCA9IG1vdXNlWCAtIGxhc3RNb3VzZVg7XG4gIGNvbnN0IGR5ID0gbW91c2VZIC0gbGFzdE1vdXNlWTtcbiAgY29uc3QgbW92ZW1lbnQgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICBcbiAgLy8gQ2hlY2sgaWYgbW91c2UgaXMgbW92aW5nXG4gIGlzTW91c2VNb3ZpbmcgPSBtb3ZlbWVudCA+IGNvbmZpZy5taW5Nb3ZlbWVudFRocmVzaG9sZDtcbiAgXG4gIC8vIEluY3JlbWVudCBzcGF3biB0aW1lclxuICBzcGF3blRpbWVyKys7XG4gIFxuICAvLyBTcGF3biBhdCByZWd1bGFyIGludGVydmFscyB3aGlsZSBtb3VzZSBpcyBtb3ZpbmdcbiAgaWYgKGlzTW91c2VNb3ZpbmcgJiYgcG9sYXJvaWRzLmxlbmd0aCA8IGNvbmZpZy5tYXhQb2xhcm9pZHMpIHtcbiAgICAvLyBSZWd1bGFyIHNwYXduaW5nIGV2ZXJ5IE4gZnJhbWVzXG4gICAgaWYgKHNwYXduVGltZXIgPj0gY29uZmlnLnNwYXduSW50ZXJ2YWwpIHtcbiAgICAgIGNvbnN0IHNwYXduWCA9IG1vdXNlWCArIChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIDUwO1xuICAgICAgY29uc3Qgc3Bhd25ZID0gbW91c2VZICsgKE1hdGgucmFuZG9tKCkgLSAwLjUpICogNTA7XG4gICAgICBwb2xhcm9pZHMucHVzaChjcmVhdGVQb2xhcm9pZEVsZW1lbnQoc3Bhd25YLCBzcGF3blkpKTtcbiAgICAgIHNwYXduVGltZXIgPSAwOyAvLyBSZXNldCB0aW1lclxuICAgIH1cbiAgICBcbiAgICAvLyBBZGRpdGlvbmFsIHNwYXduaW5nIGZvciBmYXN0IG1vdmVtZW50XG4gICAgaWYgKG1vdmVtZW50ID4gMTAgJiYgc3Bhd25UaW1lciA+PSBjb25maWcuc3Bhd25JbnRlcnZhbCAvIDIpIHtcbiAgICAgIGNvbnN0IHNwYXduWCA9IG1vdXNlWCArIChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIDQwO1xuICAgICAgY29uc3Qgc3Bhd25ZID0gbW91c2VZICsgKE1hdGgucmFuZG9tKCkgLSAwLjUpICogNDA7XG4gICAgICBwb2xhcm9pZHMucHVzaChjcmVhdGVQb2xhcm9pZEVsZW1lbnQoc3Bhd25YLCBzcGF3blkpKTtcbiAgICAgIHNwYXduVGltZXIgPSAwOyAvLyBSZXNldCB0aW1lclxuICAgIH1cbiAgfVxuICBcbiAgLy8gUmVzZXQgdGltZXIgaWYgbW91c2Ugc3RvcHMgbW92aW5nXG4gIGlmICghaXNNb3VzZU1vdmluZykge1xuICAgIHNwYXduVGltZXIgPSAwO1xuICB9XG4gIFxuICBsYXN0TW91c2VYID0gbW91c2VYO1xuICBsYXN0TW91c2VZID0gbW91c2VZO1xufVxuXG5mdW5jdGlvbiBhbmltYXRlKCkge1xuICB1cGRhdGVQb2xhcm9pZHMoKTtcbiAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpO1xufVxuXG4vLyBFdmVudCBoYW5kbGVyc1xuZnVuY3Rpb24gYXR0YWNoRXZlbnRMaXN0ZW5lcnMoKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuO1xuXG4gIGNvbnN0IG1vdXNlTW92ZUhhbmRsZXIgPSAoZTogTW91c2VFdmVudCkgPT4ge1xuICAgIG1vdXNlWCA9IGUuY2xpZW50WDtcbiAgICBtb3VzZVkgPSBlLmNsaWVudFk7XG4gIH07XG5cbiAgY29uc3QgbW91c2VFbnRlckhhbmRsZXIgPSAoZTogTW91c2VFdmVudCkgPT4ge1xuICAgIC8vIEluaXRpYWxpemUgbW91c2UgcG9zaXRpb24gd2hlbiBlbnRlcmluZyB0aGUgcGFnZVxuICAgIG1vdXNlWCA9IGUuY2xpZW50WDtcbiAgICBtb3VzZVkgPSBlLmNsaWVudFk7XG4gICAgbGFzdE1vdXNlWCA9IG1vdXNlWDtcbiAgICBsYXN0TW91c2VZID0gbW91c2VZO1xuICB9O1xuXG4gIGNvbnN0IHRvdWNoTW92ZUhhbmRsZXIgPSAoZTogVG91Y2hFdmVudCkgPT4ge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBpZiAoZS50b3VjaGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IHRvdWNoID0gZS50b3VjaGVzWzBdO1xuICAgICAgbW91c2VYID0gdG91Y2guY2xpZW50WDtcbiAgICAgIG1vdXNlWSA9IHRvdWNoLmNsaWVudFk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IHRvdWNoU3RhcnRIYW5kbGVyID0gKGU6IFRvdWNoRXZlbnQpID0+IHtcbiAgICBpZiAoZS50b3VjaGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IHRvdWNoID0gZS50b3VjaGVzWzBdO1xuICAgICAgbW91c2VYID0gdG91Y2guY2xpZW50WDtcbiAgICAgIG1vdXNlWSA9IHRvdWNoLmNsaWVudFk7XG4gICAgICBsYXN0TW91c2VYID0gbW91c2VYO1xuICAgICAgbGFzdE1vdXNlWSA9IG1vdXNlWTtcbiAgICB9XG4gIH07XG5cbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBtb3VzZU1vdmVIYW5kbGVyKTtcbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZW50ZXJcIiwgbW91c2VFbnRlckhhbmRsZXIpO1xuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIHRvdWNoTW92ZUhhbmRsZXIsIHsgcGFzc2l2ZTogZmFsc2UgfSk7XG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsIHRvdWNoU3RhcnRIYW5kbGVyLCB7IHBhc3NpdmU6IHRydWUgfSk7XG59XG5cbi8vIE1haW4gaW5pdGlhbGl6YXRpb24gZnVuY3Rpb25cbmV4cG9ydCBmdW5jdGlvbiBpbml0UG9sYXJvaWRDdXJzb3IoKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuO1xuICBcbiAgaWYgKHBvbGFyb2lkSW5pdGlhbGl6ZWQpIHtcbiAgICBjb25zb2xlLmxvZygnUG9sYXJvaWQgY3Vyc29yIGFscmVhZHkgaW5pdGlhbGl6ZWQnKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zb2xlLmxvZygnSW5pdGlhbGl6aW5nIHBvbGFyb2lkIGN1cnNvciBlZmZlY3QuLi4nKTtcblxuICAvLyBDcmVhdGUgY29udGFpbmVyIGZvciBwb2xhcm9pZHNcbiAgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGNvbnRhaW5lci5pZCA9ICdwb2xhcm9pZC1jb250YWluZXInO1xuICBjb250YWluZXIuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgdG9wOiAwO1xuICAgIGxlZnQ6IDA7XG4gICAgd2lkdGg6IDEwMHZ3O1xuICAgIGhlaWdodDogMTAwdmg7XG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gICAgei1pbmRleDogMTAwMDtcbiAgYDtcbiAgXG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcblxuICAvLyBJbml0aWFsaXplIG1vdXNlIHBvc2l0aW9uIHRvIGNlbnRlciwgYnV0IHdpbGwgYmUgdXBkYXRlZCBvbiBmaXJzdCBtb3VzZSBtb3ZlXG4gIG1vdXNlWCA9IHdpbmRvdy5pbm5lcldpZHRoIC8gMjtcbiAgbW91c2VZID0gd2luZG93LmlubmVySGVpZ2h0IC8gMjtcbiAgbGFzdE1vdXNlWCA9IG1vdXNlWDtcbiAgbGFzdE1vdXNlWSA9IG1vdXNlWTtcblxuICAvLyBHZXQgYWN0dWFsIG1vdXNlIHBvc2l0aW9uIGlmIGF2YWlsYWJsZVxuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCAoZSkgPT4ge1xuICAgIGlmIChtb3VzZVggPT09IHdpbmRvdy5pbm5lcldpZHRoIC8gMiAmJiBtb3VzZVkgPT09IHdpbmRvdy5pbm5lckhlaWdodCAvIDIpIHtcbiAgICAgIC8vIEZpcnN0IG1vdXNlIG1vdmUgLSBpbml0aWFsaXplIHByb3Blcmx5XG4gICAgICBtb3VzZVggPSBlLmNsaWVudFg7XG4gICAgICBtb3VzZVkgPSBlLmNsaWVudFk7XG4gICAgICBsYXN0TW91c2VYID0gbW91c2VYO1xuICAgICAgbGFzdE1vdXNlWSA9IG1vdXNlWTtcbiAgICB9XG4gIH0sIHsgb25jZTogdHJ1ZSB9KTtcblxuICAvLyBBdHRhY2ggZXZlbnQgbGlzdGVuZXJzXG4gIGF0dGFjaEV2ZW50TGlzdGVuZXJzKCk7XG4gIFxuICAvLyBTdGFydCBhbmltYXRpb24gbG9vcFxuICBhbmltYXRlKCk7XG5cbiAgcG9sYXJvaWRJbml0aWFsaXplZCA9IHRydWU7XG4gIGNvbnNvbGUubG9nKCdQb2xhcm9pZCBjdXJzb3IgZWZmZWN0IGluaXRpYWxpemVkIHN1Y2Nlc3NmdWxseSEnKTtcbn1cblxuLy8gQ2xlYW51cCBmdW5jdGlvblxuZXhwb3J0IGZ1bmN0aW9uIGNsZWFudXBQb2xhcm9pZEN1cnNvcigpIHtcbiAgaWYgKGNvbnRhaW5lciAmJiBjb250YWluZXIucGFyZW50Tm9kZSkge1xuICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoY29udGFpbmVyKTtcbiAgfVxuICBcbiAgcG9sYXJvaWRzLmZvckVhY2gocG9sYXJvaWQgPT4ge1xuICAgIGlmIChwb2xhcm9pZC5lbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgIHBvbGFyb2lkLmVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChwb2xhcm9pZC5lbGVtZW50KTtcbiAgICB9XG4gIH0pO1xuICBcbiAgcG9sYXJvaWRzID0gW107XG4gIGNvbnRhaW5lciA9IG51bGw7XG4gIHBvbGFyb2lkSW5pdGlhbGl6ZWQgPSBmYWxzZTtcbn1cbiJdLCJuYW1lcyI6WyJwb2xhcm9pZEluaXRpYWxpemVkIiwiY29udGFpbmVyIiwicG9sYXJvaWRzIiwibW91c2VYIiwibW91c2VZIiwibGFzdE1vdXNlWCIsImxhc3RNb3VzZVkiLCJzcGF3blRpbWVyIiwiaXNNb3VzZU1vdmluZyIsInBob3RvTGlzdCIsImNvbmZpZyIsIm1heFBvbGFyb2lkcyIsInBvbGFyb2lkTGlmZSIsInNwYXduSW50ZXJ2YWwiLCJmYWRlT3V0RHVyYXRpb24iLCJtaW5Nb3ZlbWVudFRocmVzaG9sZCIsInBvbGFyb2lkU2l6ZSIsImdldFJhbmRvbVBob3RvIiwiTWF0aCIsImZsb29yIiwicmFuZG9tIiwibGVuZ3RoIiwiY3JlYXRlUG9sYXJvaWRFbGVtZW50IiwieCIsInkiLCJlbGVtZW50IiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiaW1hZ2UiLCJjbGFzc05hbWUiLCJpbm5lckhUTUwiLCJyb3RhdGlvbiIsInNjYWxlIiwic3R5bGUiLCJjc3NUZXh0IiwicG9sYXJvaWRFbGVtZW50Iiwib3BhY2l0eSIsImxpZmUiLCJtYXhMaWZlIiwidngiLCJ2eSIsImFwcGVuZENoaWxkIiwidXBkYXRlUG9sYXJvaWRzIiwiaSIsInBvbGFyb2lkIiwibGVmdCIsInRvcCIsInRvU3RyaW5nIiwicGFyZW50Tm9kZSIsInJlbW92ZUNoaWxkIiwic3BsaWNlIiwiZHgiLCJkeSIsIm1vdmVtZW50Iiwic3FydCIsInNwYXduWCIsInNwYXduWSIsInB1c2giLCJhbmltYXRlIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiYXR0YWNoRXZlbnRMaXN0ZW5lcnMiLCJtb3VzZU1vdmVIYW5kbGVyIiwiZSIsImNsaWVudFgiLCJjbGllbnRZIiwibW91c2VFbnRlckhhbmRsZXIiLCJ0b3VjaE1vdmVIYW5kbGVyIiwicHJldmVudERlZmF1bHQiLCJ0b3VjaGVzIiwidG91Y2giLCJ0b3VjaFN0YXJ0SGFuZGxlciIsImFkZEV2ZW50TGlzdGVuZXIiLCJwYXNzaXZlIiwiaW5pdFBvbGFyb2lkQ3Vyc29yIiwiY29uc29sZSIsImxvZyIsImlkIiwiYm9keSIsIndpbmRvdyIsImlubmVyV2lkdGgiLCJpbm5lckhlaWdodCIsIm9uY2UiLCJjbGVhbnVwUG9sYXJvaWRDdXJzb3IiLCJmb3JFYWNoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/lib/polaroid-cursor.ts\n"));

/***/ })

});