"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_app-pages-browser_app_lib_fluid_ts",{

/***/ "(app-pages-browser)/./app/lib/fluid.ts":
/*!**************************!*\
  !*** ./app/lib/fluid.ts ***!
  \**************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   initFluidSimulation: function() { return /* binding */ initFluidSimulation; }\n/* harmony export */ });\n// Simplified fluid simulation for Next.js\n// This is a TypeScript version of the original fluid.js with Next.js compatibility\nlet fluidInitialized = false;\nlet canvas = null;\nlet gl = null;\n// Global variables for the simulation\nlet config;\nlet pointers = [];\nlet dye, velocity;\nlet lastUpdateTime = 0;\nlet startTime = 0;\n// Utility functions\nfunction scaleByPixelRatio(input) {\n    const pixelRatio =  true ? window.devicePixelRatio || 1 : 0;\n    return Math.floor(input * pixelRatio);\n}\nfunction HSVtoRGB(h, s, v) {\n    let r, g, b, i, f, p, q, t;\n    i = Math.floor(h * 6);\n    f = h * 6 - i;\n    p = v * (1 - s);\n    q = v * (1 - f * s);\n    t = v * (1 - (1 - f) * s);\n    switch(i % 6){\n        case 0:\n            r = v;\n            g = t;\n            b = p;\n            break;\n        case 1:\n            r = q;\n            g = v;\n            b = p;\n            break;\n        case 2:\n            r = p;\n            g = v;\n            b = t;\n            break;\n        case 3:\n            r = p;\n            g = q;\n            b = v;\n            break;\n        case 4:\n            r = t;\n            g = p;\n            b = v;\n            break;\n        case 5:\n            r = v;\n            g = p;\n            b = q;\n            break;\n        default:\n            r = g = b = 0;\n    }\n    return {\n        r,\n        g,\n        b\n    };\n}\nfunction generateColor() {\n    const c = HSVtoRGB(Math.random(), 1.0, 1.0);\n    c.r *= 0.40;\n    c.g *= 0.01;\n    c.b *= 0.10;\n    return c;\n}\n// Pointer class\nclass PointerPrototype {\n    constructor(){\n        this.id = -1;\n        this.texcoordX = 0;\n        this.texcoordY = 0;\n        this.prevTexcoordX = 0;\n        this.prevTexcoordY = 0;\n        this.deltaX = 0;\n        this.deltaY = 0;\n        this.down = false;\n        this.moved = false;\n        this.color = {\n            r: 30,\n            g: 0,\n            b: 300\n        };\n    }\n}\n// Basic WebGL setup\nfunction getWebGLContext(canvas) {\n    const params = {\n        alpha: true,\n        depth: false,\n        stencil: false,\n        antialias: false,\n        preserveDrawingBuffer: false\n    };\n    let gl = canvas.getContext(\"webgl2\", params);\n    const isWebGL2 = !!gl;\n    if (!isWebGL2) {\n        gl = canvas.getContext(\"webgl\", params) || canvas.getContext(\"experimental-webgl\", params);\n    }\n    if (!gl) {\n        console.error(\"WebGL not supported\");\n        return null;\n    }\n    gl.clearColor(0.0, 0.0, 0.0, 1.0);\n    return gl;\n}\n// Simplified render loop\nfunction render() {\n    if (!gl || !canvas) return;\n    gl.clear(gl.COLOR_BUFFER_BIT);\n    // Create a simple animated background effect\n    const time = (Date.now() - startTime) / 1000;\n    const r = Math.sin(time * 0.3) * 0.5 + 0.5;\n    const g = Math.sin(time * 0.5) * 0.5 + 0.5;\n    const b = Math.sin(time * 0.7) * 0.5 + 0.5;\n    gl.clearColor(r * 0.1, g * 0.02, b * 0.05, 1.0);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n    requestAnimationFrame(render);\n}\n// Resize canvas\nfunction resizeCanvas() {\n    if (!canvas) return false;\n    const width = scaleByPixelRatio(canvas.clientWidth);\n    const height = scaleByPixelRatio(canvas.clientHeight);\n    if (canvas.width !== width || canvas.height !== height) {\n        canvas.width = width;\n        canvas.height = height;\n        return true;\n    }\n    return false;\n}\n// Event handlers\nfunction updatePointerMoveData(pointer, posX, posY) {\n    if (!canvas) return;\n    pointer.prevTexcoordX = pointer.texcoordX;\n    pointer.prevTexcoordY = pointer.texcoordY;\n    pointer.texcoordX = posX / canvas.width;\n    pointer.texcoordY = 1.0 - posY / canvas.height;\n    pointer.deltaX = pointer.texcoordX - pointer.prevTexcoordX;\n    pointer.deltaY = pointer.texcoordY - pointer.prevTexcoordY;\n    pointer.moved = Math.abs(pointer.deltaX) > 0 || Math.abs(pointer.deltaY) > 0;\n}\nfunction correctDeltaX(delta) {\n    if (!canvas) return delta;\n    const aspectRatio = canvas.width / canvas.height;\n    if (aspectRatio < 1) delta *= aspectRatio;\n    return delta;\n}\nfunction correctDeltaY(delta) {\n    if (!canvas) return delta;\n    const aspectRatio = canvas.width / canvas.height;\n    if (aspectRatio > 1) delta /= aspectRatio;\n    return delta;\n}\nfunction splatPointer(pointer) {\n    const dx = correctDeltaX(pointer.deltaX) * config.SPLAT_FORCE;\n    const dy = correctDeltaY(pointer.deltaY) * config.SPLAT_FORCE;\n    splat(pointer.texcoordX, pointer.texcoordY, dx, dy, pointer.color);\n}\nfunction splat(x, y, dx, dy, color) {\n    // This is a simplified splat effect - in the full version this would update fluid textures\n    // For now, we'll just create a visual effect\n    if (!gl || !canvas) return;\n    // Create a simple colored circle effect\n    const centerX = x * canvas.width;\n    const centerY = (1 - y) * canvas.height;\n    const radius = 50;\n// This would normally update the fluid simulation textures\n// For now, just trigger a visual update\n}\n// Event listeners\nfunction attachEventListeners() {\n    if ( false || !canvas) return;\n    const body = document.querySelector(\"body\");\n    if (!body) return;\n    const mouseMoveHandler = (e)=>{\n        if (!pointers || !pointers[0]) return;\n        const pointer = pointers[0];\n        const posX = scaleByPixelRatio(e.clientX);\n        const posY = scaleByPixelRatio(e.clientY);\n        updatePointerMoveData(pointer, posX, posY);\n    };\n    const touchStartHandler = (e)=>{\n        e.preventDefault();\n        if (!pointers) return;\n        const touches = e.targetTouches;\n        while(touches.length >= pointers.length){\n            pointers.push(new PointerPrototype());\n        }\n        for(let i = 0; i < touches.length; i++){\n            const posX = scaleByPixelRatio(touches[i].clientX);\n            const posY = scaleByPixelRatio(touches[i].clientY);\n            const pointer = pointers[i + 1];\n            if (pointer) {\n                pointer.id = touches[i].identifier;\n                pointer.down = true;\n                pointer.moved = false;\n                pointer.texcoordX = posX / canvas.width;\n                pointer.texcoordY = 1.0 - posY / canvas.height;\n                pointer.prevTexcoordX = pointer.texcoordX;\n                pointer.prevTexcoordY = pointer.texcoordY;\n                pointer.deltaX = 0;\n                pointer.deltaY = 0;\n                pointer.color = generateColor();\n            }\n        }\n    };\n    const touchMoveHandler = (e)=>{\n        e.preventDefault();\n        if (!pointers) return;\n        const touches = e.targetTouches;\n        for(let i = 0; i < touches.length; i++){\n            const pointer = pointers[i + 1];\n            if (!pointer || !pointer.down) continue;\n            const posX = scaleByPixelRatio(touches[i].clientX);\n            const posY = scaleByPixelRatio(touches[i].clientY);\n            updatePointerMoveData(pointer, posX, posY);\n        }\n    };\n    const touchEndHandler = (e)=>{\n        if (!pointers) return;\n        const touches = e.changedTouches;\n        for(let i = 0; i < touches.length; i++){\n            const pointer = pointers.find((p)=>p.id === touches[i].identifier);\n            if (pointer) {\n                pointer.down = false;\n            }\n        }\n    };\n    body.addEventListener(\"mousemove\", mouseMoveHandler);\n    body.addEventListener(\"touchstart\", touchStartHandler);\n    body.addEventListener(\"touchmove\", touchMoveHandler, {\n        passive: false\n    });\n    window.addEventListener(\"touchend\", touchEndHandler);\n}\n// Main initialization function\nfunction initFluidSimulation() {\n    if (false) {}\n    if (fluidInitialized) {\n        console.log(\"Fluid already initialized, skipping WebGL setup...\");\n        attachEventListeners();\n        return;\n    }\n    console.log(\"Initializing fluid simulation...\");\n    canvas = document.getElementById(\"fluid\");\n    if (!canvas) {\n        console.error(\"Fluid canvas not found\");\n        return;\n    }\n    resizeCanvas();\n    gl = getWebGLContext(canvas);\n    if (!gl) {\n        console.error(\"Failed to get WebGL context\");\n        return;\n    }\n    // Initialize basic config\n    config = {\n        DENSITY_DISSIPATION: 2,\n        VELOCITY_DISSIPATION: 0.1,\n        PRESSURE: 0.01,\n        CURL: 100,\n        SPLAT_RADIUS: 0.13,\n        SPLAT_FORCE: 5000,\n        COLORFUL: true,\n        COLOR_UPDATE_SPEED: 3,\n        PAUSED: false\n    };\n    // Initialize pointers\n    pointers = [];\n    pointers.push(new PointerPrototype());\n    // Start render loop\n    lastUpdateTime = Date.now();\n    startTime = Date.now();\n    // Attach event listeners\n    attachEventListeners();\n    // Start rendering\n    render();\n    fluidInitialized = true;\n    console.log(\"Fluid simulation initialized successfully!\");\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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bUQsS0FBS0MsR0FBRztJQUN6Qm5ELFlBQVlrRCxLQUFLQyxHQUFHO0lBRXBCLHlCQUF5QjtJQUN6QjJCO0lBRUEsa0JBQWtCO0lBQ2xCaEM7SUFFQXRELG1CQUFtQjtJQUNuQm1ELFFBQVF5RCxHQUFHLENBQUM7QUFDZCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9hcHAvbGliL2ZsdWlkLnRzP2ZiM2QiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gU2ltcGxpZmllZCBmbHVpZCBzaW11bGF0aW9uIGZvciBOZXh0LmpzXG4vLyBUaGlzIGlzIGEgVHlwZVNjcmlwdCB2ZXJzaW9uIG9mIHRoZSBvcmlnaW5hbCBmbHVpZC5qcyB3aXRoIE5leHQuanMgY29tcGF0aWJpbGl0eVxuXG5sZXQgZmx1aWRJbml0aWFsaXplZCA9IGZhbHNlO1xubGV0IGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQgfCBudWxsID0gbnVsbDtcbmxldCBnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0IHwgbnVsbCA9IG51bGw7XG5cbi8vIEdsb2JhbCB2YXJpYWJsZXMgZm9yIHRoZSBzaW11bGF0aW9uXG5sZXQgY29uZmlnOiBhbnk7XG5sZXQgcG9pbnRlcnM6IGFueVtdID0gW107XG5sZXQgZHllOiBhbnksIHZlbG9jaXR5OiBhbnk7XG5sZXQgbGFzdFVwZGF0ZVRpbWUgPSAwO1xubGV0IHN0YXJ0VGltZSA9IDA7XG5cbi8vIFV0aWxpdHkgZnVuY3Rpb25zXG5mdW5jdGlvbiBzY2FsZUJ5UGl4ZWxSYXRpbyhpbnB1dDogbnVtYmVyKTogbnVtYmVyIHtcbiAgY29uc3QgcGl4ZWxSYXRpbyA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMSA6IDE7XG4gIHJldHVybiBNYXRoLmZsb29yKGlucHV0ICogcGl4ZWxSYXRpbyk7XG59XG5cbmZ1bmN0aW9uIEhTVnRvUkdCKGg6IG51bWJlciwgczogbnVtYmVyLCB2OiBudW1iZXIpOiB7IHI6IG51bWJlcjsgZzogbnVtYmVyOyBiOiBudW1iZXIgfSB7XG4gIGxldCByOiBudW1iZXIsIGc6IG51bWJlciwgYjogbnVtYmVyLCBpOiBudW1iZXIsIGY6IG51bWJlciwgcDogbnVtYmVyLCBxOiBudW1iZXIsIHQ6IG51bWJlcjtcbiAgaSA9IE1hdGguZmxvb3IoaCAqIDYpO1xuICBmID0gaCAqIDYgLSBpO1xuICBwID0gdiAqICgxIC0gcyk7XG4gIHEgPSB2ICogKDEgLSBmICogcyk7XG4gIHQgPSB2ICogKDEgLSAoMSAtIGYpICogcyk7XG5cbiAgc3dpdGNoIChpICUgNikge1xuICAgIGNhc2UgMDogciA9IHY7IGcgPSB0OyBiID0gcDsgYnJlYWs7XG4gICAgY2FzZSAxOiByID0gcTsgZyA9IHY7IGIgPSBwOyBicmVhaztcbiAgICBjYXNlIDI6IHIgPSBwOyBnID0gdjsgYiA9IHQ7IGJyZWFrO1xuICAgIGNhc2UgMzogciA9IHA7IGcgPSBxOyBiID0gdjsgYnJlYWs7XG4gICAgY2FzZSA0OiByID0gdDsgZyA9IHA7IGIgPSB2OyBicmVhaztcbiAgICBjYXNlIDU6IHIgPSB2OyBnID0gcDsgYiA9IHE7IGJyZWFrO1xuICAgIGRlZmF1bHQ6IHIgPSBnID0gYiA9IDA7XG4gIH1cblxuICByZXR1cm4geyByLCBnLCBiIH07XG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlQ29sb3IoKTogeyByOiBudW1iZXI7IGc6IG51bWJlcjsgYjogbnVtYmVyIH0ge1xuICBjb25zdCBjID0gSFNWdG9SR0IoTWF0aC5yYW5kb20oKSwgMS4wLCAxLjApO1xuICBjLnIgKj0gMC40MDtcbiAgYy5nICo9IDAuMDE7XG4gIGMuYiAqPSAwLjEwO1xuICByZXR1cm4gYztcbn1cblxuLy8gUG9pbnRlciBjbGFzc1xuY2xhc3MgUG9pbnRlclByb3RvdHlwZSB7XG4gIGlkID0gLTE7XG4gIHRleGNvb3JkWCA9IDA7XG4gIHRleGNvb3JkWSA9IDA7XG4gIHByZXZUZXhjb29yZFggPSAwO1xuICBwcmV2VGV4Y29vcmRZID0gMDtcbiAgZGVsdGFYID0gMDtcbiAgZGVsdGFZID0gMDtcbiAgZG93biA9IGZhbHNlO1xuICBtb3ZlZCA9IGZhbHNlO1xuICBjb2xvciA9IHsgcjogMzAsIGc6IDAsIGI6IDMwMCB9O1xufVxuXG4vLyBCYXNpYyBXZWJHTCBzZXR1cFxuZnVuY3Rpb24gZ2V0V2ViR0xDb250ZXh0KGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQpIHtcbiAgY29uc3QgcGFyYW1zID0ge1xuICAgIGFscGhhOiB0cnVlLFxuICAgIGRlcHRoOiBmYWxzZSxcbiAgICBzdGVuY2lsOiBmYWxzZSxcbiAgICBhbnRpYWxpYXM6IGZhbHNlLFxuICAgIHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogZmFsc2VcbiAgfTtcblxuICBsZXQgZ2wgPSBjYW52YXMuZ2V0Q29udGV4dChcIndlYmdsMlwiLCBwYXJhbXMpIGFzIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQ7XG4gIGNvbnN0IGlzV2ViR0wyID0gISFnbDtcbiAgXG4gIGlmICghaXNXZWJHTDIpIHtcbiAgICBnbCA9IGNhbnZhcy5nZXRDb250ZXh0KFwid2ViZ2xcIiwgcGFyYW1zKSBhcyBXZWJHTDJSZW5kZXJpbmdDb250ZXh0IHx8XG4gICAgICAgICBjYW52YXMuZ2V0Q29udGV4dChcImV4cGVyaW1lbnRhbC13ZWJnbFwiLCBwYXJhbXMpIGFzIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQ7XG4gIH1cblxuICBpZiAoIWdsKSB7XG4gICAgY29uc29sZS5lcnJvcignV2ViR0wgbm90IHN1cHBvcnRlZCcpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZ2wuY2xlYXJDb2xvcigwLjAsIDAuMCwgMC4wLCAxLjApO1xuICByZXR1cm4gZ2w7XG59XG5cbi8vIFNpbXBsaWZpZWQgcmVuZGVyIGxvb3BcbmZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgaWYgKCFnbCB8fCAhY2FudmFzKSByZXR1cm47XG4gIFxuICBnbC5jbGVhcihnbC5DT0xPUl9CVUZGRVJfQklUKTtcbiAgXG4gIC8vIENyZWF0ZSBhIHNpbXBsZSBhbmltYXRlZCBiYWNrZ3JvdW5kIGVmZmVjdFxuICBjb25zdCB0aW1lID0gKERhdGUubm93KCkgLSBzdGFydFRpbWUpIC8gMTAwMDtcbiAgY29uc3QgciA9IE1hdGguc2luKHRpbWUgKiAwLjMpICogMC41ICsgMC41O1xuICBjb25zdCBnID0gTWF0aC5zaW4odGltZSAqIDAuNSkgKiAwLjUgKyAwLjU7XG4gIGNvbnN0IGIgPSBNYXRoLnNpbih0aW1lICogMC43KSAqIDAuNSArIDAuNTtcbiAgXG4gIGdsLmNsZWFyQ29sb3IociAqIDAuMSwgZyAqIDAuMDIsIGIgKiAwLjA1LCAxLjApO1xuICBnbC5jbGVhcihnbC5DT0xPUl9CVUZGRVJfQklUKTtcbiAgXG4gIHJlcXVlc3RBbmltYXRpb25GcmFtZShyZW5kZXIpO1xufVxuXG4vLyBSZXNpemUgY2FudmFzXG5mdW5jdGlvbiByZXNpemVDYW52YXMoKSB7XG4gIGlmICghY2FudmFzKSByZXR1cm4gZmFsc2U7XG4gIFxuICBjb25zdCB3aWR0aCA9IHNjYWxlQnlQaXhlbFJhdGlvKGNhbnZhcy5jbGllbnRXaWR0aCk7XG4gIGNvbnN0IGhlaWdodCA9IHNjYWxlQnlQaXhlbFJhdGlvKGNhbnZhcy5jbGllbnRIZWlnaHQpO1xuICBcbiAgaWYgKGNhbnZhcy53aWR0aCAhPT0gd2lkdGggfHwgY2FudmFzLmhlaWdodCAhPT0gaGVpZ2h0KSB7XG4gICAgY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIEV2ZW50IGhhbmRsZXJzXG5mdW5jdGlvbiB1cGRhdGVQb2ludGVyTW92ZURhdGEocG9pbnRlcjogUG9pbnRlclByb3RvdHlwZSwgcG9zWDogbnVtYmVyLCBwb3NZOiBudW1iZXIpIHtcbiAgaWYgKCFjYW52YXMpIHJldHVybjtcbiAgXG4gIHBvaW50ZXIucHJldlRleGNvb3JkWCA9IHBvaW50ZXIudGV4Y29vcmRYO1xuICBwb2ludGVyLnByZXZUZXhjb29yZFkgPSBwb2ludGVyLnRleGNvb3JkWTtcbiAgcG9pbnRlci50ZXhjb29yZFggPSBwb3NYIC8gY2FudmFzLndpZHRoO1xuICBwb2ludGVyLnRleGNvb3JkWSA9IDEuMCAtIHBvc1kgLyBjYW52YXMuaGVpZ2h0O1xuICBwb2ludGVyLmRlbHRhWCA9IHBvaW50ZXIudGV4Y29vcmRYIC0gcG9pbnRlci5wcmV2VGV4Y29vcmRYO1xuICBwb2ludGVyLmRlbHRhWSA9IHBvaW50ZXIudGV4Y29vcmRZIC0gcG9pbnRlci5wcmV2VGV4Y29vcmRZO1xuICBwb2ludGVyLm1vdmVkID0gTWF0aC5hYnMocG9pbnRlci5kZWx0YVgpID4gMCB8fCBNYXRoLmFicyhwb2ludGVyLmRlbHRhWSkgPiAwO1xufVxuXG5mdW5jdGlvbiBjb3JyZWN0RGVsdGFYKGRlbHRhOiBudW1iZXIpOiBudW1iZXIge1xuICBpZiAoIWNhbnZhcykgcmV0dXJuIGRlbHRhO1xuICBjb25zdCBhc3BlY3RSYXRpbyA9IGNhbnZhcy53aWR0aCAvIGNhbnZhcy5oZWlnaHQ7XG4gIGlmIChhc3BlY3RSYXRpbyA8IDEpIGRlbHRhICo9IGFzcGVjdFJhdGlvO1xuICByZXR1cm4gZGVsdGE7XG59XG5cbmZ1bmN0aW9uIGNvcnJlY3REZWx0YVkoZGVsdGE6IG51bWJlcik6IG51bWJlciB7XG4gIGlmICghY2FudmFzKSByZXR1cm4gZGVsdGE7XG4gIGNvbnN0IGFzcGVjdFJhdGlvID0gY2FudmFzLndpZHRoIC8gY2FudmFzLmhlaWdodDtcbiAgaWYgKGFzcGVjdFJhdGlvID4gMSkgZGVsdGEgLz0gYXNwZWN0UmF0aW87XG4gIHJldHVybiBkZWx0YTtcbn1cblxuZnVuY3Rpb24gc3BsYXRQb2ludGVyKHBvaW50ZXI6IFBvaW50ZXJQcm90b3R5cGUpIHtcbiAgY29uc3QgZHggPSBjb3JyZWN0RGVsdGFYKHBvaW50ZXIuZGVsdGFYKSAqIGNvbmZpZy5TUExBVF9GT1JDRTtcbiAgY29uc3QgZHkgPSBjb3JyZWN0RGVsdGFZKHBvaW50ZXIuZGVsdGFZKSAqIGNvbmZpZy5TUExBVF9GT1JDRTtcbiAgc3BsYXQocG9pbnRlci50ZXhjb29yZFgsIHBvaW50ZXIudGV4Y29vcmRZLCBkeCwgZHksIHBvaW50ZXIuY29sb3IpO1xufVxuXG5mdW5jdGlvbiBzcGxhdCh4OiBudW1iZXIsIHk6IG51bWJlciwgZHg6IG51bWJlciwgZHk6IG51bWJlciwgY29sb3I6IHsgcjogbnVtYmVyOyBnOiBudW1iZXI7IGI6IG51bWJlciB9KSB7XG4gIC8vIFRoaXMgaXMgYSBzaW1wbGlmaWVkIHNwbGF0IGVmZmVjdCAtIGluIHRoZSBmdWxsIHZlcnNpb24gdGhpcyB3b3VsZCB1cGRhdGUgZmx1aWQgdGV4dHVyZXNcbiAgLy8gRm9yIG5vdywgd2UnbGwganVzdCBjcmVhdGUgYSB2aXN1YWwgZWZmZWN0XG4gIGlmICghZ2wgfHwgIWNhbnZhcykgcmV0dXJuO1xuICBcbiAgLy8gQ3JlYXRlIGEgc2ltcGxlIGNvbG9yZWQgY2lyY2xlIGVmZmVjdFxuICBjb25zdCBjZW50ZXJYID0geCAqIGNhbnZhcy53aWR0aDtcbiAgY29uc3QgY2VudGVyWSA9ICgxIC0geSkgKiBjYW52YXMuaGVpZ2h0O1xuICBjb25zdCByYWRpdXMgPSA1MDtcbiAgXG4gIC8vIFRoaXMgd291bGQgbm9ybWFsbHkgdXBkYXRlIHRoZSBmbHVpZCBzaW11bGF0aW9uIHRleHR1cmVzXG4gIC8vIEZvciBub3csIGp1c3QgdHJpZ2dlciBhIHZpc3VhbCB1cGRhdGVcbn1cblxuLy8gRXZlbnQgbGlzdGVuZXJzXG5mdW5jdGlvbiBhdHRhY2hFdmVudExpc3RlbmVycygpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8ICFjYW52YXMpIHJldHVybjtcblxuICBjb25zdCBib2R5ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignYm9keScpO1xuICBpZiAoIWJvZHkpIHJldHVybjtcblxuICBjb25zdCBtb3VzZU1vdmVIYW5kbGVyID0gKGU6IE1vdXNlRXZlbnQpID0+IHtcbiAgICBpZiAoIXBvaW50ZXJzIHx8ICFwb2ludGVyc1swXSkgcmV0dXJuO1xuICAgIGNvbnN0IHBvaW50ZXIgPSBwb2ludGVyc1swXTtcbiAgICBjb25zdCBwb3NYID0gc2NhbGVCeVBpeGVsUmF0aW8oZS5jbGllbnRYKTtcbiAgICBjb25zdCBwb3NZID0gc2NhbGVCeVBpeGVsUmF0aW8oZS5jbGllbnRZKTtcbiAgICB1cGRhdGVQb2ludGVyTW92ZURhdGEocG9pbnRlciwgcG9zWCwgcG9zWSk7XG4gIH07XG5cbiAgY29uc3QgdG91Y2hTdGFydEhhbmRsZXIgPSAoZTogVG91Y2hFdmVudCkgPT4ge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBpZiAoIXBvaW50ZXJzKSByZXR1cm47XG4gICAgY29uc3QgdG91Y2hlcyA9IGUudGFyZ2V0VG91Y2hlcztcbiAgICBcbiAgICB3aGlsZSAodG91Y2hlcy5sZW5ndGggPj0gcG9pbnRlcnMubGVuZ3RoKSB7XG4gICAgICBwb2ludGVycy5wdXNoKG5ldyBQb2ludGVyUHJvdG90eXBlKCkpO1xuICAgIH1cbiAgICBcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRvdWNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHBvc1ggPSBzY2FsZUJ5UGl4ZWxSYXRpbyh0b3VjaGVzW2ldLmNsaWVudFgpO1xuICAgICAgY29uc3QgcG9zWSA9IHNjYWxlQnlQaXhlbFJhdGlvKHRvdWNoZXNbaV0uY2xpZW50WSk7XG4gICAgICBjb25zdCBwb2ludGVyID0gcG9pbnRlcnNbaSArIDFdO1xuICAgICAgaWYgKHBvaW50ZXIpIHtcbiAgICAgICAgcG9pbnRlci5pZCA9IHRvdWNoZXNbaV0uaWRlbnRpZmllcjtcbiAgICAgICAgcG9pbnRlci5kb3duID0gdHJ1ZTtcbiAgICAgICAgcG9pbnRlci5tb3ZlZCA9IGZhbHNlO1xuICAgICAgICBwb2ludGVyLnRleGNvb3JkWCA9IHBvc1ggLyBjYW52YXMhLndpZHRoO1xuICAgICAgICBwb2ludGVyLnRleGNvb3JkWSA9IDEuMCAtIHBvc1kgLyBjYW52YXMhLmhlaWdodDtcbiAgICAgICAgcG9pbnRlci5wcmV2VGV4Y29vcmRYID0gcG9pbnRlci50ZXhjb29yZFg7XG4gICAgICAgIHBvaW50ZXIucHJldlRleGNvb3JkWSA9IHBvaW50ZXIudGV4Y29vcmRZO1xuICAgICAgICBwb2ludGVyLmRlbHRhWCA9IDA7XG4gICAgICAgIHBvaW50ZXIuZGVsdGFZID0gMDtcbiAgICAgICAgcG9pbnRlci5jb2xvciA9IGdlbmVyYXRlQ29sb3IoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgY29uc3QgdG91Y2hNb3ZlSGFuZGxlciA9IChlOiBUb3VjaEV2ZW50KSA9PiB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGlmICghcG9pbnRlcnMpIHJldHVybjtcbiAgICBjb25zdCB0b3VjaGVzID0gZS50YXJnZXRUb3VjaGVzO1xuICAgIFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG91Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcG9pbnRlciA9IHBvaW50ZXJzW2kgKyAxXTtcbiAgICAgIGlmICghcG9pbnRlciB8fCAhcG9pbnRlci5kb3duKSBjb250aW51ZTtcbiAgICAgIGNvbnN0IHBvc1ggPSBzY2FsZUJ5UGl4ZWxSYXRpbyh0b3VjaGVzW2ldLmNsaWVudFgpO1xuICAgICAgY29uc3QgcG9zWSA9IHNjYWxlQnlQaXhlbFJhdGlvKHRvdWNoZXNbaV0uY2xpZW50WSk7XG4gICAgICB1cGRhdGVQb2ludGVyTW92ZURhdGEocG9pbnRlciwgcG9zWCwgcG9zWSk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IHRvdWNoRW5kSGFuZGxlciA9IChlOiBUb3VjaEV2ZW50KSA9PiB7XG4gICAgaWYgKCFwb2ludGVycykgcmV0dXJuO1xuICAgIGNvbnN0IHRvdWNoZXMgPSBlLmNoYW5nZWRUb3VjaGVzO1xuICAgIFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG91Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcG9pbnRlciA9IHBvaW50ZXJzLmZpbmQoKHA6IFBvaW50ZXJQcm90b3R5cGUpID0+IHAuaWQgPT09IHRvdWNoZXNbaV0uaWRlbnRpZmllcik7XG4gICAgICBpZiAocG9pbnRlcikge1xuICAgICAgICBwb2ludGVyLmRvd24gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgYm9keS5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIG1vdXNlTW92ZUhhbmRsZXIpO1xuICBib2R5LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsIHRvdWNoU3RhcnRIYW5kbGVyKTtcbiAgYm9keS5hZGRFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIHRvdWNoTW92ZUhhbmRsZXIsIHsgcGFzc2l2ZTogZmFsc2UgfSk7XG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgdG91Y2hFbmRIYW5kbGVyKTtcbn1cblxuLy8gTWFpbiBpbml0aWFsaXphdGlvbiBmdW5jdGlvblxuZXhwb3J0IGZ1bmN0aW9uIGluaXRGbHVpZFNpbXVsYXRpb24oKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuO1xuICBcbiAgaWYgKGZsdWlkSW5pdGlhbGl6ZWQpIHtcbiAgICBjb25zb2xlLmxvZygnRmx1aWQgYWxyZWFkeSBpbml0aWFsaXplZCwgc2tpcHBpbmcgV2ViR0wgc2V0dXAuLi4nKTtcbiAgICBhdHRhY2hFdmVudExpc3RlbmVycygpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnNvbGUubG9nKCdJbml0aWFsaXppbmcgZmx1aWQgc2ltdWxhdGlvbi4uLicpO1xuXG4gIGNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZmx1aWRcIikgYXMgSFRNTENhbnZhc0VsZW1lbnQ7XG4gIFxuICBpZiAoIWNhbnZhcykge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0ZsdWlkIGNhbnZhcyBub3QgZm91bmQnKTtcbiAgICByZXR1cm47XG4gIH1cblxuICByZXNpemVDYW52YXMoKTtcbiAgXG4gIGdsID0gZ2V0V2ViR0xDb250ZXh0KGNhbnZhcyk7XG4gIGlmICghZ2wpIHtcbiAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gZ2V0IFdlYkdMIGNvbnRleHQnKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBJbml0aWFsaXplIGJhc2ljIGNvbmZpZ1xuICBjb25maWcgPSB7XG4gICAgREVOU0lUWV9ESVNTSVBBVElPTjogMixcbiAgICBWRUxPQ0lUWV9ESVNTSVBBVElPTjogMC4xLFxuICAgIFBSRVNTVVJFOiAwLjAxLFxuICAgIENVUkw6IDEwMCxcbiAgICBTUExBVF9SQURJVVM6IDAuMTMsXG4gICAgU1BMQVRfRk9SQ0U6IDUwMDAsXG4gICAgQ09MT1JGVUw6IHRydWUsXG4gICAgQ09MT1JfVVBEQVRFX1NQRUVEOiAzLFxuICAgIFBBVVNFRDogZmFsc2UsXG4gIH07XG5cbiAgLy8gSW5pdGlhbGl6ZSBwb2ludGVyc1xuICBwb2ludGVycyA9IFtdO1xuICBwb2ludGVycy5wdXNoKG5ldyBQb2ludGVyUHJvdG90eXBlKCkpO1xuXG4gIC8vIFN0YXJ0IHJlbmRlciBsb29wXG4gIGxhc3RVcGRhdGVUaW1lID0gRGF0ZS5ub3coKTtcbiAgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgXG4gIC8vIEF0dGFjaCBldmVudCBsaXN0ZW5lcnNcbiAgYXR0YWNoRXZlbnRMaXN0ZW5lcnMoKTtcbiAgXG4gIC8vIFN0YXJ0IHJlbmRlcmluZ1xuICByZW5kZXIoKTtcblxuICBmbHVpZEluaXRpYWxpemVkID0gdHJ1ZTtcbiAgY29uc29sZS5sb2coJ0ZsdWlkIHNpbXVsYXRpb24gaW5pdGlhbGl6ZWQgc3VjY2Vzc2Z1bGx5IScpO1xufVxuIl0sIm5hbWVzIjpbImZsdWlkSW5pdGlhbGl6ZWQiLCJjYW52YXMiLCJnbCIsImNvbmZpZyIsInBvaW50ZXJzIiwiZHllIiwidmVsb2NpdHkiLCJsYXN0VXBkYXRlVGltZSIsInN0YXJ0VGltZSIsInNjYWxlQnlQaXhlbFJhdGlvIiwiaW5wdXQiLCJwaXhlbFJhdGlvIiwid2luZG93IiwiZGV2aWNlUGl4ZWxSYXRpbyIsIk1hdGgiLCJmbG9vciIsIkhTVnRvUkdCIiwiaCIsInMiLCJ2IiwiciIsImciLCJiIiwiaSIsImYiLCJwIiwicSIsInQiLCJnZW5lcmF0ZUNvbG9yIiwiYyIsInJhbmRvbSIsIlBvaW50ZXJQcm90b3R5cGUiLCJpZCIsInRleGNvb3JkWCIsInRleGNvb3JkWSIsInByZXZUZXhjb29yZFgiLCJwcmV2VGV4Y29vcmRZIiwiZGVsdGFYIiwiZGVsdGFZIiwiZG93biIsIm1vdmVkIiwiY29sb3IiLCJnZXRXZWJHTENvbnRleHQiLCJwYXJhbXMiLCJhbHBoYSIsImRlcHRoIiwic3RlbmNpbCIsImFudGlhbGlhcyIsInByZXNlcnZlRHJhd2luZ0J1ZmZlciIsImdldENvbnRleHQiLCJpc1dlYkdMMiIsImNvbnNvbGUiLCJlcnJvciIsImNsZWFyQ29sb3IiLCJyZW5kZXIiLCJjbGVhciIsIkNPTE9SX0JVRkZFUl9CSVQiLCJ0aW1lIiwiRGF0ZSIsIm5vdyIsInNpbiIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsInJlc2l6ZUNhbnZhcyIsIndpZHRoIiwiY2xpZW50V2lkdGgiLCJoZWlnaHQiLCJjbGllbnRIZWlnaHQiLCJ1cGRhdGVQb2ludGVyTW92ZURhdGEiLCJwb2ludGVyIiwicG9zWCIsInBvc1kiLCJhYnMiLCJjb3JyZWN0RGVsdGFYIiwiZGVsdGEiLCJhc3BlY3RSYXRpbyIsImNvcnJlY3REZWx0YVkiLCJzcGxhdFBvaW50ZXIiLCJkeCIsIlNQTEFUX0ZPUkNFIiwiZHkiLCJzcGxhdCIsIngiLCJ5IiwiY2VudGVyWCIsImNlbnRlclkiLCJyYWRpdXMiLCJhdHRhY2hFdmVudExpc3RlbmVycyIsImJvZHkiLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3IiLCJtb3VzZU1vdmVIYW5kbGVyIiwiZSIsImNsaWVudFgiLCJjbGllbnRZIiwidG91Y2hTdGFydEhhbmRsZXIiLCJwcmV2ZW50RGVmYXVsdCIsInRvdWNoZXMiLCJ0YXJnZXRUb3VjaGVzIiwibGVuZ3RoIiwicHVzaCIsImlkZW50aWZpZXIiLCJ0b3VjaE1vdmVIYW5kbGVyIiwidG91Y2hFbmRIYW5kbGVyIiwiY2hhbmdlZFRvdWNoZXMiLCJmaW5kIiwiYWRkRXZlbnRMaXN0ZW5lciIsInBhc3NpdmUiLCJpbml0Rmx1aWRTaW11bGF0aW9uIiwibG9nIiwiZ2V0RWxlbWVudEJ5SWQiLCJERU5TSVRZX0RJU1NJUEFUSU9OIiwiVkVMT0NJVFlfRElTU0lQQVRJT04iLCJQUkVTU1VSRSIsIkNVUkwiLCJTUExBVF9SQURJVVMiLCJDT0xPUkZVTCIsIkNPTE9SX1VQREFURV9TUEVFRCIsIlBBVVNFRCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/lib/fluid.ts\n"));

/***/ })

});