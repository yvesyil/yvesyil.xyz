"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_app-pages-browser_app_lib_fluid_ts",{

/***/ "(app-pages-browser)/./app/lib/fluid.ts":
/*!**************************!*\
  !*** ./app/lib/fluid.ts ***!
  \**************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   initFluidSimulation: function() { return /* binding */ initFluidSimulation; }\n/* harmony export */ });\n// Simplified fluid simulation for Next.js\n// This is a TypeScript version of the original fluid.js with Next.js compatibility\nlet fluidInitialized = false;\nlet canvas = null;\nlet gl = null;\n// Global variables for the simulation\nlet config;\nlet pointers = [];\nlet dye, velocity;\nlet lastUpdateTime = 0;\nlet startTime = 0;\n// Utility functions\nfunction scaleByPixelRatio(input) {\n    const pixelRatio =  true ? window.devicePixelRatio || 1 : 0;\n    return Math.floor(input * pixelRatio);\n}\nfunction HSVtoRGB(h, s, v) {\n    let r, g, b, i, f, p, q, t;\n    i = Math.floor(h * 6);\n    f = h * 6 - i;\n    p = v * (1 - s);\n    q = v * (1 - f * s);\n    t = v * (1 - (1 - f) * s);\n    switch(i % 6){\n        case 0:\n            r = v;\n            g = t;\n            b = p;\n            break;\n        case 1:\n            r = q;\n            g = v;\n            b = p;\n            break;\n        case 2:\n            r = p;\n            g = v;\n            b = t;\n            break;\n        case 3:\n            r = p;\n            g = q;\n            b = v;\n            break;\n        case 4:\n            r = t;\n            g = p;\n            b = v;\n            break;\n        case 5:\n            r = v;\n            g = p;\n            b = q;\n            break;\n        default:\n            r = g = b = 0;\n    }\n    return {\n        r,\n        g,\n        b\n    };\n}\nfunction generateColor() {\n    const c = HSVtoRGB(Math.random(), 1.0, 1.0);\n    c.r *= 0.40;\n    c.g *= 0.01;\n    c.b *= 0.10;\n    return c;\n}\n// Pointer class\nclass PointerPrototype {\n    constructor(){\n        this.id = -1;\n        this.texcoordX = 0;\n        this.texcoordY = 0;\n        this.prevTexcoordX = 0;\n        this.prevTexcoordY = 0;\n        this.deltaX = 0;\n        this.deltaY = 0;\n        this.down = false;\n        this.moved = false;\n        this.color = {\n            r: 30,\n            g: 0,\n            b: 300\n        };\n    }\n}\n// Basic WebGL setup\nfunction getWebGLContext(canvas) {\n    const params = {\n        alpha: true,\n        depth: false,\n        stencil: false,\n        antialias: false,\n        preserveDrawingBuffer: false\n    };\n    let gl = canvas.getContext(\"webgl2\", params);\n    const isWebGL2 = !!gl;\n    if (!isWebGL2) {\n        gl = canvas.getContext(\"webgl\", params) || canvas.getContext(\"experimental-webgl\", params);\n    }\n    if (!gl) {\n        console.error(\"WebGL not supported\");\n        return null;\n    }\n    gl.clearColor(0.0, 0.0, 0.0, 1.0);\n    return gl;\n}\n// Enhanced render loop with mouse interaction effects\nfunction render() {\n    if (!gl || !canvas) return;\n    const time = (Date.now() - startTime) / 1000;\n    // Base animated background\n    let r = Math.sin(time * 0.3) * 0.3 + 0.1;\n    let g = Math.sin(time * 0.5) * 0.1 + 0.02;\n    let b = Math.sin(time * 0.7) * 0.2 + 0.05;\n    // Add mouse interaction effects\n    if (pointers && pointers[0] && pointers[0].moved) {\n        const pointer = pointers[0];\n        const intensity = Math.sqrt(pointer.deltaX * pointer.deltaX + pointer.deltaY * pointer.deltaY) * 10;\n        // Enhance colors based on mouse movement\n        r += intensity * pointer.color.r * 0.5;\n        g += intensity * pointer.color.g * 0.5;\n        b += intensity * pointer.color.b * 0.5;\n    }\n    // Apply enhanced background with interaction\n    gl.clearColor(Math.min(r, 1.0), Math.min(g, 1.0), Math.min(b, 1.0), 1.0);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n    // Process pointer movements\n    if (pointers) {\n        pointers.forEach((pointer)=>{\n            if (pointer.moved) {\n                pointer.moved = false;\n            // Visual feedback for pointer movement\n            }\n        });\n    }\n    requestAnimationFrame(render);\n}\n// Resize canvas\nfunction resizeCanvas() {\n    if (!canvas) return false;\n    const width = scaleByPixelRatio(canvas.clientWidth);\n    const height = scaleByPixelRatio(canvas.clientHeight);\n    if (canvas.width !== width || canvas.height !== height) {\n        canvas.width = width;\n        canvas.height = height;\n        return true;\n    }\n    return false;\n}\n// Event handlers\nfunction updatePointerMoveData(pointer, posX, posY) {\n    if (!canvas) return;\n    pointer.prevTexcoordX = pointer.texcoordX;\n    pointer.prevTexcoordY = pointer.texcoordY;\n    pointer.texcoordX = posX / canvas.width;\n    pointer.texcoordY = 1.0 - posY / canvas.height;\n    pointer.deltaX = pointer.texcoordX - pointer.prevTexcoordX;\n    pointer.deltaY = pointer.texcoordY - pointer.prevTexcoordY;\n    pointer.moved = Math.abs(pointer.deltaX) > 0 || Math.abs(pointer.deltaY) > 0;\n}\nfunction correctDeltaX(delta) {\n    if (!canvas) return delta;\n    const aspectRatio = canvas.width / canvas.height;\n    if (aspectRatio < 1) delta *= aspectRatio;\n    return delta;\n}\nfunction correctDeltaY(delta) {\n    if (!canvas) return delta;\n    const aspectRatio = canvas.width / canvas.height;\n    if (aspectRatio > 1) delta /= aspectRatio;\n    return delta;\n}\nfunction splatPointer(pointer) {\n    const dx = correctDeltaX(pointer.deltaX) * config.SPLAT_FORCE;\n    const dy = correctDeltaY(pointer.deltaY) * config.SPLAT_FORCE;\n    splat(pointer.texcoordX, pointer.texcoordY, dx, dy, pointer.color);\n}\nfunction splat(x, y, dx, dy, color) {\n    // This is a simplified splat effect - in the full version this would update fluid textures\n    // For now, we'll just create a visual effect\n    if (!gl || !canvas) return;\n    // Create a simple colored circle effect\n    const centerX = x * canvas.width;\n    const centerY = (1 - y) * canvas.height;\n    const radius = 50;\n// This would normally update the fluid simulation textures\n// For now, just trigger a visual update\n}\n// Event listeners\nfunction attachEventListeners() {\n    if ( false || !canvas) return;\n    const body = document.querySelector(\"body\");\n    if (!body) return;\n    const mouseMoveHandler = (e)=>{\n        if (!pointers || !pointers[0]) return;\n        const pointer = pointers[0];\n        const posX = scaleByPixelRatio(e.clientX);\n        const posY = scaleByPixelRatio(e.clientY);\n        updatePointerMoveData(pointer, posX, posY);\n        // Apply splat effect when mouse moves\n        if (pointer.moved) {\n            pointer.moved = false;\n            splatPointer(pointer);\n        }\n    };\n    const touchStartHandler = (e)=>{\n        e.preventDefault();\n        if (!pointers) return;\n        const touches = e.targetTouches;\n        while(touches.length >= pointers.length){\n            pointers.push(new PointerPrototype());\n        }\n        for(let i = 0; i < touches.length; i++){\n            const posX = scaleByPixelRatio(touches[i].clientX);\n            const posY = scaleByPixelRatio(touches[i].clientY);\n            const pointer = pointers[i + 1];\n            if (pointer) {\n                pointer.id = touches[i].identifier;\n                pointer.down = true;\n                pointer.moved = false;\n                pointer.texcoordX = posX / canvas.width;\n                pointer.texcoordY = 1.0 - posY / canvas.height;\n                pointer.prevTexcoordX = pointer.texcoordX;\n                pointer.prevTexcoordY = pointer.texcoordY;\n                pointer.deltaX = 0;\n                pointer.deltaY = 0;\n                pointer.color = generateColor();\n            }\n        }\n    };\n    const touchMoveHandler = (e)=>{\n        e.preventDefault();\n        if (!pointers) return;\n        const touches = e.targetTouches;\n        for(let i = 0; i < touches.length; i++){\n            const pointer = pointers[i + 1];\n            if (!pointer || !pointer.down) continue;\n            const posX = scaleByPixelRatio(touches[i].clientX);\n            const posY = scaleByPixelRatio(touches[i].clientY);\n            updatePointerMoveData(pointer, posX, posY);\n            // Apply splat effect when touch moves\n            if (pointer.moved) {\n                pointer.moved = false;\n                splatPointer(pointer);\n            }\n        }\n    };\n    const touchEndHandler = (e)=>{\n        if (!pointers) return;\n        const touches = e.changedTouches;\n        for(let i = 0; i < touches.length; i++){\n            const pointer = pointers.find((p)=>p.id === touches[i].identifier);\n            if (pointer) {\n                pointer.down = false;\n            }\n        }\n    };\n    body.addEventListener(\"mousemove\", mouseMoveHandler);\n    body.addEventListener(\"touchstart\", touchStartHandler);\n    body.addEventListener(\"touchmove\", touchMoveHandler, {\n        passive: false\n    });\n    window.addEventListener(\"touchend\", touchEndHandler);\n}\n// Main initialization function\nfunction initFluidSimulation() {\n    if (false) {}\n    if (fluidInitialized) {\n        console.log(\"Fluid already initialized, skipping WebGL setup...\");\n        attachEventListeners();\n        return;\n    }\n    console.log(\"Initializing fluid simulation...\");\n    canvas = document.getElementById(\"fluid\");\n    if (!canvas) {\n        console.error(\"Fluid canvas not found\");\n        return;\n    }\n    resizeCanvas();\n    gl = getWebGLContext(canvas);\n    if (!gl) {\n        console.error(\"Failed to get WebGL context\");\n        return;\n    }\n    // Initialize basic config\n    config = {\n        DENSITY_DISSIPATION: 2,\n        VELOCITY_DISSIPATION: 0.1,\n        PRESSURE: 0.01,\n        CURL: 100,\n        SPLAT_RADIUS: 0.13,\n        SPLAT_FORCE: 5000,\n        COLORFUL: true,\n        COLOR_UPDATE_SPEED: 3,\n        PAUSED: false\n    };\n    // Initialize pointers\n    pointers = [];\n    pointers.push(new PointerPrototype());\n    // Start render loop\n    lastUpdateTime = Date.now();\n    startTime = Date.now();\n    // Attach event listeners\n    attachEventListeners();\n    // Start rendering\n    render();\n    fluidInitialized = true;\n    console.log(\"Fluid simulation initialized successfully!\");\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Oi8vX05fRS8uL2FwcC9saWIvZmx1aWQudHM/ZmIzZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBTaW1wbGlmaWVkIGZsdWlkIHNpbXVsYXRpb24gZm9yIE5leHQuanNcbi8vIFRoaXMgaXMgYSBUeXBlU2NyaXB0IHZlcnNpb24gb2YgdGhlIG9yaWdpbmFsIGZsdWlkLmpzIHdpdGggTmV4dC5qcyBjb21wYXRpYmlsaXR5XG5cbmxldCBmbHVpZEluaXRpYWxpemVkID0gZmFsc2U7XG5sZXQgY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCB8IG51bGwgPSBudWxsO1xubGV0IGdsOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQgfCBudWxsID0gbnVsbDtcblxuLy8gR2xvYmFsIHZhcmlhYmxlcyBmb3IgdGhlIHNpbXVsYXRpb25cbmxldCBjb25maWc6IGFueTtcbmxldCBwb2ludGVyczogYW55W10gPSBbXTtcbmxldCBkeWU6IGFueSwgdmVsb2NpdHk6IGFueTtcbmxldCBsYXN0VXBkYXRlVGltZSA9IDA7XG5sZXQgc3RhcnRUaW1lID0gMDtcblxuLy8gVXRpbGl0eSBmdW5jdGlvbnNcbmZ1bmN0aW9uIHNjYWxlQnlQaXhlbFJhdGlvKGlucHV0OiBudW1iZXIpOiBudW1iZXIge1xuICBjb25zdCBwaXhlbFJhdGlvID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxIDogMTtcbiAgcmV0dXJuIE1hdGguZmxvb3IoaW5wdXQgKiBwaXhlbFJhdGlvKTtcbn1cblxuZnVuY3Rpb24gSFNWdG9SR0IoaDogbnVtYmVyLCBzOiBudW1iZXIsIHY6IG51bWJlcik6IHsgcjogbnVtYmVyOyBnOiBudW1iZXI7IGI6IG51bWJlciB9IHtcbiAgbGV0IHI6IG51bWJlciwgZzogbnVtYmVyLCBiOiBudW1iZXIsIGk6IG51bWJlciwgZjogbnVtYmVyLCBwOiBudW1iZXIsIHE6IG51bWJlciwgdDogbnVtYmVyO1xuICBpID0gTWF0aC5mbG9vcihoICogNik7XG4gIGYgPSBoICogNiAtIGk7XG4gIHAgPSB2ICogKDEgLSBzKTtcbiAgcSA9IHYgKiAoMSAtIGYgKiBzKTtcbiAgdCA9IHYgKiAoMSAtICgxIC0gZikgKiBzKTtcblxuICBzd2l0Y2ggKGkgJSA2KSB7XG4gICAgY2FzZSAwOiByID0gdjsgZyA9IHQ7IGIgPSBwOyBicmVhaztcbiAgICBjYXNlIDE6IHIgPSBxOyBnID0gdjsgYiA9IHA7IGJyZWFrO1xuICAgIGNhc2UgMjogciA9IHA7IGcgPSB2OyBiID0gdDsgYnJlYWs7XG4gICAgY2FzZSAzOiByID0gcDsgZyA9IHE7IGIgPSB2OyBicmVhaztcbiAgICBjYXNlIDQ6IHIgPSB0OyBnID0gcDsgYiA9IHY7IGJyZWFrO1xuICAgIGNhc2UgNTogciA9IHY7IGcgPSBwOyBiID0gcTsgYnJlYWs7XG4gICAgZGVmYXVsdDogciA9IGcgPSBiID0gMDtcbiAgfVxuXG4gIHJldHVybiB7IHIsIGcsIGIgfTtcbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVDb2xvcigpOiB7IHI6IG51bWJlcjsgZzogbnVtYmVyOyBiOiBudW1iZXIgfSB7XG4gIGNvbnN0IGMgPSBIU1Z0b1JHQihNYXRoLnJhbmRvbSgpLCAxLjAsIDEuMCk7XG4gIGMuciAqPSAwLjQwO1xuICBjLmcgKj0gMC4wMTtcbiAgYy5iICo9IDAuMTA7XG4gIHJldHVybiBjO1xufVxuXG4vLyBQb2ludGVyIGNsYXNzXG5jbGFzcyBQb2ludGVyUHJvdG90eXBlIHtcbiAgaWQgPSAtMTtcbiAgdGV4Y29vcmRYID0gMDtcbiAgdGV4Y29vcmRZID0gMDtcbiAgcHJldlRleGNvb3JkWCA9IDA7XG4gIHByZXZUZXhjb29yZFkgPSAwO1xuICBkZWx0YVggPSAwO1xuICBkZWx0YVkgPSAwO1xuICBkb3duID0gZmFsc2U7XG4gIG1vdmVkID0gZmFsc2U7XG4gIGNvbG9yID0geyByOiAzMCwgZzogMCwgYjogMzAwIH07XG59XG5cbi8vIEJhc2ljIFdlYkdMIHNldHVwXG5mdW5jdGlvbiBnZXRXZWJHTENvbnRleHQoY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCkge1xuICBjb25zdCBwYXJhbXMgPSB7XG4gICAgYWxwaGE6IHRydWUsXG4gICAgZGVwdGg6IGZhbHNlLFxuICAgIHN0ZW5jaWw6IGZhbHNlLFxuICAgIGFudGlhbGlhczogZmFsc2UsXG4gICAgcHJlc2VydmVEcmF3aW5nQnVmZmVyOiBmYWxzZVxuICB9O1xuXG4gIGxldCBnbCA9IGNhbnZhcy5nZXRDb250ZXh0KFwid2ViZ2wyXCIsIHBhcmFtcykgYXMgV2ViR0wyUmVuZGVyaW5nQ29udGV4dDtcbiAgY29uc3QgaXNXZWJHTDIgPSAhIWdsO1xuICBcbiAgaWYgKCFpc1dlYkdMMikge1xuICAgIGdsID0gY2FudmFzLmdldENvbnRleHQoXCJ3ZWJnbFwiLCBwYXJhbXMpIGFzIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQgfHxcbiAgICAgICAgIGNhbnZhcy5nZXRDb250ZXh0KFwiZXhwZXJpbWVudGFsLXdlYmdsXCIsIHBhcmFtcykgYXMgV2ViR0wyUmVuZGVyaW5nQ29udGV4dDtcbiAgfVxuXG4gIGlmICghZ2wpIHtcbiAgICBjb25zb2xlLmVycm9yKCdXZWJHTCBub3Qgc3VwcG9ydGVkJyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBnbC5jbGVhckNvbG9yKDAuMCwgMC4wLCAwLjAsIDEuMCk7XG4gIHJldHVybiBnbDtcbn1cblxuLy8gRW5oYW5jZWQgcmVuZGVyIGxvb3Agd2l0aCBtb3VzZSBpbnRlcmFjdGlvbiBlZmZlY3RzXG5mdW5jdGlvbiByZW5kZXIoKSB7XG4gIGlmICghZ2wgfHwgIWNhbnZhcykgcmV0dXJuO1xuICBcbiAgY29uc3QgdGltZSA9IChEYXRlLm5vdygpIC0gc3RhcnRUaW1lKSAvIDEwMDA7XG4gIFxuICAvLyBCYXNlIGFuaW1hdGVkIGJhY2tncm91bmRcbiAgbGV0IHIgPSBNYXRoLnNpbih0aW1lICogMC4zKSAqIDAuMyArIDAuMTtcbiAgbGV0IGcgPSBNYXRoLnNpbih0aW1lICogMC41KSAqIDAuMSArIDAuMDI7XG4gIGxldCBiID0gTWF0aC5zaW4odGltZSAqIDAuNykgKiAwLjIgKyAwLjA1O1xuICBcbiAgLy8gQWRkIG1vdXNlIGludGVyYWN0aW9uIGVmZmVjdHNcbiAgaWYgKHBvaW50ZXJzICYmIHBvaW50ZXJzWzBdICYmIHBvaW50ZXJzWzBdLm1vdmVkKSB7XG4gICAgY29uc3QgcG9pbnRlciA9IHBvaW50ZXJzWzBdO1xuICAgIGNvbnN0IGludGVuc2l0eSA9IE1hdGguc3FydChwb2ludGVyLmRlbHRhWCAqIHBvaW50ZXIuZGVsdGFYICsgcG9pbnRlci5kZWx0YVkgKiBwb2ludGVyLmRlbHRhWSkgKiAxMDtcbiAgICBcbiAgICAvLyBFbmhhbmNlIGNvbG9ycyBiYXNlZCBvbiBtb3VzZSBtb3ZlbWVudFxuICAgIHIgKz0gaW50ZW5zaXR5ICogcG9pbnRlci5jb2xvci5yICogMC41O1xuICAgIGcgKz0gaW50ZW5zaXR5ICogcG9pbnRlci5jb2xvci5nICogMC41O1xuICAgIGIgKz0gaW50ZW5zaXR5ICogcG9pbnRlci5jb2xvci5iICogMC41O1xuICB9XG4gIFxuICAvLyBBcHBseSBlbmhhbmNlZCBiYWNrZ3JvdW5kIHdpdGggaW50ZXJhY3Rpb25cbiAgZ2wuY2xlYXJDb2xvcihNYXRoLm1pbihyLCAxLjApLCBNYXRoLm1pbihnLCAxLjApLCBNYXRoLm1pbihiLCAxLjApLCAxLjApO1xuICBnbC5jbGVhcihnbC5DT0xPUl9CVUZGRVJfQklUKTtcbiAgXG4gIC8vIFByb2Nlc3MgcG9pbnRlciBtb3ZlbWVudHNcbiAgaWYgKHBvaW50ZXJzKSB7XG4gICAgcG9pbnRlcnMuZm9yRWFjaCgocG9pbnRlcikgPT4ge1xuICAgICAgaWYgKHBvaW50ZXIubW92ZWQpIHtcbiAgICAgICAgcG9pbnRlci5tb3ZlZCA9IGZhbHNlO1xuICAgICAgICAvLyBWaXN1YWwgZmVlZGJhY2sgZm9yIHBvaW50ZXIgbW92ZW1lbnRcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBcbiAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJlbmRlcik7XG59XG5cbi8vIFJlc2l6ZSBjYW52YXNcbmZ1bmN0aW9uIHJlc2l6ZUNhbnZhcygpIHtcbiAgaWYgKCFjYW52YXMpIHJldHVybiBmYWxzZTtcbiAgXG4gIGNvbnN0IHdpZHRoID0gc2NhbGVCeVBpeGVsUmF0aW8oY2FudmFzLmNsaWVudFdpZHRoKTtcbiAgY29uc3QgaGVpZ2h0ID0gc2NhbGVCeVBpeGVsUmF0aW8oY2FudmFzLmNsaWVudEhlaWdodCk7XG4gIFxuICBpZiAoY2FudmFzLndpZHRoICE9PSB3aWR0aCB8fCBjYW52YXMuaGVpZ2h0ICE9PSBoZWlnaHQpIHtcbiAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLy8gRXZlbnQgaGFuZGxlcnNcbmZ1bmN0aW9uIHVwZGF0ZVBvaW50ZXJNb3ZlRGF0YShwb2ludGVyOiBQb2ludGVyUHJvdG90eXBlLCBwb3NYOiBudW1iZXIsIHBvc1k6IG51bWJlcikge1xuICBpZiAoIWNhbnZhcykgcmV0dXJuO1xuICBcbiAgcG9pbnRlci5wcmV2VGV4Y29vcmRYID0gcG9pbnRlci50ZXhjb29yZFg7XG4gIHBvaW50ZXIucHJldlRleGNvb3JkWSA9IHBvaW50ZXIudGV4Y29vcmRZO1xuICBwb2ludGVyLnRleGNvb3JkWCA9IHBvc1ggLyBjYW52YXMud2lkdGg7XG4gIHBvaW50ZXIudGV4Y29vcmRZID0gMS4wIC0gcG9zWSAvIGNhbnZhcy5oZWlnaHQ7XG4gIHBvaW50ZXIuZGVsdGFYID0gcG9pbnRlci50ZXhjb29yZFggLSBwb2ludGVyLnByZXZUZXhjb29yZFg7XG4gIHBvaW50ZXIuZGVsdGFZID0gcG9pbnRlci50ZXhjb29yZFkgLSBwb2ludGVyLnByZXZUZXhjb29yZFk7XG4gIHBvaW50ZXIubW92ZWQgPSBNYXRoLmFicyhwb2ludGVyLmRlbHRhWCkgPiAwIHx8IE1hdGguYWJzKHBvaW50ZXIuZGVsdGFZKSA+IDA7XG59XG5cbmZ1bmN0aW9uIGNvcnJlY3REZWx0YVgoZGVsdGE6IG51bWJlcik6IG51bWJlciB7XG4gIGlmICghY2FudmFzKSByZXR1cm4gZGVsdGE7XG4gIGNvbnN0IGFzcGVjdFJhdGlvID0gY2FudmFzLndpZHRoIC8gY2FudmFzLmhlaWdodDtcbiAgaWYgKGFzcGVjdFJhdGlvIDwgMSkgZGVsdGEgKj0gYXNwZWN0UmF0aW87XG4gIHJldHVybiBkZWx0YTtcbn1cblxuZnVuY3Rpb24gY29ycmVjdERlbHRhWShkZWx0YTogbnVtYmVyKTogbnVtYmVyIHtcbiAgaWYgKCFjYW52YXMpIHJldHVybiBkZWx0YTtcbiAgY29uc3QgYXNwZWN0UmF0aW8gPSBjYW52YXMud2lkdGggLyBjYW52YXMuaGVpZ2h0O1xuICBpZiAoYXNwZWN0UmF0aW8gPiAxKSBkZWx0YSAvPSBhc3BlY3RSYXRpbztcbiAgcmV0dXJuIGRlbHRhO1xufVxuXG5mdW5jdGlvbiBzcGxhdFBvaW50ZXIocG9pbnRlcjogUG9pbnRlclByb3RvdHlwZSkge1xuICBjb25zdCBkeCA9IGNvcnJlY3REZWx0YVgocG9pbnRlci5kZWx0YVgpICogY29uZmlnLlNQTEFUX0ZPUkNFO1xuICBjb25zdCBkeSA9IGNvcnJlY3REZWx0YVkocG9pbnRlci5kZWx0YVkpICogY29uZmlnLlNQTEFUX0ZPUkNFO1xuICBzcGxhdChwb2ludGVyLnRleGNvb3JkWCwgcG9pbnRlci50ZXhjb29yZFksIGR4LCBkeSwgcG9pbnRlci5jb2xvcik7XG59XG5cbmZ1bmN0aW9uIHNwbGF0KHg6IG51bWJlciwgeTogbnVtYmVyLCBkeDogbnVtYmVyLCBkeTogbnVtYmVyLCBjb2xvcjogeyByOiBudW1iZXI7IGc6IG51bWJlcjsgYjogbnVtYmVyIH0pIHtcbiAgLy8gVGhpcyBpcyBhIHNpbXBsaWZpZWQgc3BsYXQgZWZmZWN0IC0gaW4gdGhlIGZ1bGwgdmVyc2lvbiB0aGlzIHdvdWxkIHVwZGF0ZSBmbHVpZCB0ZXh0dXJlc1xuICAvLyBGb3Igbm93LCB3ZSdsbCBqdXN0IGNyZWF0ZSBhIHZpc3VhbCBlZmZlY3RcbiAgaWYgKCFnbCB8fCAhY2FudmFzKSByZXR1cm47XG4gIFxuICAvLyBDcmVhdGUgYSBzaW1wbGUgY29sb3JlZCBjaXJjbGUgZWZmZWN0XG4gIGNvbnN0IGNlbnRlclggPSB4ICogY2FudmFzLndpZHRoO1xuICBjb25zdCBjZW50ZXJZID0gKDEgLSB5KSAqIGNhbnZhcy5oZWlnaHQ7XG4gIGNvbnN0IHJhZGl1cyA9IDUwO1xuICBcbiAgLy8gVGhpcyB3b3VsZCBub3JtYWxseSB1cGRhdGUgdGhlIGZsdWlkIHNpbXVsYXRpb24gdGV4dHVyZXNcbiAgLy8gRm9yIG5vdywganVzdCB0cmlnZ2VyIGEgdmlzdWFsIHVwZGF0ZVxufVxuXG4vLyBFdmVudCBsaXN0ZW5lcnNcbmZ1bmN0aW9uIGF0dGFjaEV2ZW50TGlzdGVuZXJzKCkge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHwgIWNhbnZhcykgcmV0dXJuO1xuXG4gIGNvbnN0IGJvZHkgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdib2R5Jyk7XG4gIGlmICghYm9keSkgcmV0dXJuO1xuXG4gIGNvbnN0IG1vdXNlTW92ZUhhbmRsZXIgPSAoZTogTW91c2VFdmVudCkgPT4ge1xuICAgIGlmICghcG9pbnRlcnMgfHwgIXBvaW50ZXJzWzBdKSByZXR1cm47XG4gICAgY29uc3QgcG9pbnRlciA9IHBvaW50ZXJzWzBdO1xuICAgIGNvbnN0IHBvc1ggPSBzY2FsZUJ5UGl4ZWxSYXRpbyhlLmNsaWVudFgpO1xuICAgIGNvbnN0IHBvc1kgPSBzY2FsZUJ5UGl4ZWxSYXRpbyhlLmNsaWVudFkpO1xuICAgIHVwZGF0ZVBvaW50ZXJNb3ZlRGF0YShwb2ludGVyLCBwb3NYLCBwb3NZKTtcbiAgICBcbiAgICAvLyBBcHBseSBzcGxhdCBlZmZlY3Qgd2hlbiBtb3VzZSBtb3Zlc1xuICAgIGlmIChwb2ludGVyLm1vdmVkKSB7XG4gICAgICBwb2ludGVyLm1vdmVkID0gZmFsc2U7XG4gICAgICBzcGxhdFBvaW50ZXIocG9pbnRlcik7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IHRvdWNoU3RhcnRIYW5kbGVyID0gKGU6IFRvdWNoRXZlbnQpID0+IHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgaWYgKCFwb2ludGVycykgcmV0dXJuO1xuICAgIGNvbnN0IHRvdWNoZXMgPSBlLnRhcmdldFRvdWNoZXM7XG4gICAgXG4gICAgd2hpbGUgKHRvdWNoZXMubGVuZ3RoID49IHBvaW50ZXJzLmxlbmd0aCkge1xuICAgICAgcG9pbnRlcnMucHVzaChuZXcgUG9pbnRlclByb3RvdHlwZSgpKTtcbiAgICB9XG4gICAgXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b3VjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBwb3NYID0gc2NhbGVCeVBpeGVsUmF0aW8odG91Y2hlc1tpXS5jbGllbnRYKTtcbiAgICAgIGNvbnN0IHBvc1kgPSBzY2FsZUJ5UGl4ZWxSYXRpbyh0b3VjaGVzW2ldLmNsaWVudFkpO1xuICAgICAgY29uc3QgcG9pbnRlciA9IHBvaW50ZXJzW2kgKyAxXTtcbiAgICAgIGlmIChwb2ludGVyKSB7XG4gICAgICAgIHBvaW50ZXIuaWQgPSB0b3VjaGVzW2ldLmlkZW50aWZpZXI7XG4gICAgICAgIHBvaW50ZXIuZG93biA9IHRydWU7XG4gICAgICAgIHBvaW50ZXIubW92ZWQgPSBmYWxzZTtcbiAgICAgICAgcG9pbnRlci50ZXhjb29yZFggPSBwb3NYIC8gY2FudmFzIS53aWR0aDtcbiAgICAgICAgcG9pbnRlci50ZXhjb29yZFkgPSAxLjAgLSBwb3NZIC8gY2FudmFzIS5oZWlnaHQ7XG4gICAgICAgIHBvaW50ZXIucHJldlRleGNvb3JkWCA9IHBvaW50ZXIudGV4Y29vcmRYO1xuICAgICAgICBwb2ludGVyLnByZXZUZXhjb29yZFkgPSBwb2ludGVyLnRleGNvb3JkWTtcbiAgICAgICAgcG9pbnRlci5kZWx0YVggPSAwO1xuICAgICAgICBwb2ludGVyLmRlbHRhWSA9IDA7XG4gICAgICAgIHBvaW50ZXIuY29sb3IgPSBnZW5lcmF0ZUNvbG9yKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IHRvdWNoTW92ZUhhbmRsZXIgPSAoZTogVG91Y2hFdmVudCkgPT4ge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBpZiAoIXBvaW50ZXJzKSByZXR1cm47XG4gICAgY29uc3QgdG91Y2hlcyA9IGUudGFyZ2V0VG91Y2hlcztcbiAgICBcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRvdWNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHBvaW50ZXIgPSBwb2ludGVyc1tpICsgMV07XG4gICAgICBpZiAoIXBvaW50ZXIgfHwgIXBvaW50ZXIuZG93bikgY29udGludWU7XG4gICAgICBjb25zdCBwb3NYID0gc2NhbGVCeVBpeGVsUmF0aW8odG91Y2hlc1tpXS5jbGllbnRYKTtcbiAgICAgIGNvbnN0IHBvc1kgPSBzY2FsZUJ5UGl4ZWxSYXRpbyh0b3VjaGVzW2ldLmNsaWVudFkpO1xuICAgICAgdXBkYXRlUG9pbnRlck1vdmVEYXRhKHBvaW50ZXIsIHBvc1gsIHBvc1kpO1xuICAgICAgXG4gICAgICAvLyBBcHBseSBzcGxhdCBlZmZlY3Qgd2hlbiB0b3VjaCBtb3Zlc1xuICAgICAgaWYgKHBvaW50ZXIubW92ZWQpIHtcbiAgICAgICAgcG9pbnRlci5tb3ZlZCA9IGZhbHNlO1xuICAgICAgICBzcGxhdFBvaW50ZXIocG9pbnRlcik7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IHRvdWNoRW5kSGFuZGxlciA9IChlOiBUb3VjaEV2ZW50KSA9PiB7XG4gICAgaWYgKCFwb2ludGVycykgcmV0dXJuO1xuICAgIGNvbnN0IHRvdWNoZXMgPSBlLmNoYW5nZWRUb3VjaGVzO1xuICAgIFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG91Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcG9pbnRlciA9IHBvaW50ZXJzLmZpbmQoKHA6IFBvaW50ZXJQcm90b3R5cGUpID0+IHAuaWQgPT09IHRvdWNoZXNbaV0uaWRlbnRpZmllcik7XG4gICAgICBpZiAocG9pbnRlcikge1xuICAgICAgICBwb2ludGVyLmRvd24gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgYm9keS5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIG1vdXNlTW92ZUhhbmRsZXIpO1xuICBib2R5LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsIHRvdWNoU3RhcnRIYW5kbGVyKTtcbiAgYm9keS5hZGRFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIHRvdWNoTW92ZUhhbmRsZXIsIHsgcGFzc2l2ZTogZmFsc2UgfSk7XG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgdG91Y2hFbmRIYW5kbGVyKTtcbn1cblxuLy8gTWFpbiBpbml0aWFsaXphdGlvbiBmdW5jdGlvblxuZXhwb3J0IGZ1bmN0aW9uIGluaXRGbHVpZFNpbXVsYXRpb24oKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuO1xuICBcbiAgaWYgKGZsdWlkSW5pdGlhbGl6ZWQpIHtcbiAgICBjb25zb2xlLmxvZygnRmx1aWQgYWxyZWFkeSBpbml0aWFsaXplZCwgc2tpcHBpbmcgV2ViR0wgc2V0dXAuLi4nKTtcbiAgICBhdHRhY2hFdmVudExpc3RlbmVycygpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnNvbGUubG9nKCdJbml0aWFsaXppbmcgZmx1aWQgc2ltdWxhdGlvbi4uLicpO1xuXG4gIGNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZmx1aWRcIikgYXMgSFRNTENhbnZhc0VsZW1lbnQ7XG4gIFxuICBpZiAoIWNhbnZhcykge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0ZsdWlkIGNhbnZhcyBub3QgZm91bmQnKTtcbiAgICByZXR1cm47XG4gIH1cblxuICByZXNpemVDYW52YXMoKTtcbiAgXG4gIGdsID0gZ2V0V2ViR0xDb250ZXh0KGNhbnZhcyk7XG4gIGlmICghZ2wpIHtcbiAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gZ2V0IFdlYkdMIGNvbnRleHQnKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBJbml0aWFsaXplIGJhc2ljIGNvbmZpZ1xuICBjb25maWcgPSB7XG4gICAgREVOU0lUWV9ESVNTSVBBVElPTjogMixcbiAgICBWRUxPQ0lUWV9ESVNTSVBBVElPTjogMC4xLFxuICAgIFBSRVNTVVJFOiAwLjAxLFxuICAgIENVUkw6IDEwMCxcbiAgICBTUExBVF9SQURJVVM6IDAuMTMsXG4gICAgU1BMQVRfRk9SQ0U6IDUwMDAsXG4gICAgQ09MT1JGVUw6IHRydWUsXG4gICAgQ09MT1JfVVBEQVRFX1NQRUVEOiAzLFxuICAgIFBBVVNFRDogZmFsc2UsXG4gIH07XG5cbiAgLy8gSW5pdGlhbGl6ZSBwb2ludGVyc1xuICBwb2ludGVycyA9IFtdO1xuICBwb2ludGVycy5wdXNoKG5ldyBQb2ludGVyUHJvdG90eXBlKCkpO1xuXG4gIC8vIFN0YXJ0IHJlbmRlciBsb29wXG4gIGxhc3RVcGRhdGVUaW1lID0gRGF0ZS5ub3coKTtcbiAgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgXG4gIC8vIEF0dGFjaCBldmVudCBsaXN0ZW5lcnNcbiAgYXR0YWNoRXZlbnRMaXN0ZW5lcnMoKTtcbiAgXG4gIC8vIFN0YXJ0IHJlbmRlcmluZ1xuICByZW5kZXIoKTtcblxuICBmbHVpZEluaXRpYWxpemVkID0gdHJ1ZTtcbiAgY29uc29sZS5sb2coJ0ZsdWlkIHNpbXVsYXRpb24gaW5pdGlhbGl6ZWQgc3VjY2Vzc2Z1bGx5IScpO1xufVxuIl0sIm5hbWVzIjpbImZsdWlkSW5pdGlhbGl6ZWQiLCJjYW52YXMiLCJnbCIsImNvbmZpZyIsInBvaW50ZXJzIiwiZHllIiwidmVsb2NpdHkiLCJsYXN0VXBkYXRlVGltZSIsInN0YXJ0VGltZSIsInNjYWxlQnlQaXhlbFJhdGlvIiwiaW5wdXQiLCJwaXhlbFJhdGlvIiwid2luZG93IiwiZGV2aWNlUGl4ZWxSYXRpbyIsIk1hdGgiLCJmbG9vciIsIkhTVnRvUkdCIiwiaCIsInMiLCJ2IiwiciIsImciLCJiIiwiaSIsImYiLCJwIiwicSIsInQiLCJnZW5lcmF0ZUNvbG9yIiwiYyIsInJhbmRvbSIsIlBvaW50ZXJQcm90b3R5cGUiLCJpZCIsInRleGNvb3JkWCIsInRleGNvb3JkWSIsInByZXZUZXhjb29yZFgiLCJwcmV2VGV4Y29vcmRZIiwiZGVsdGFYIiwiZGVsdGFZIiwiZG93biIsIm1vdmVkIiwiY29sb3IiLCJnZXRXZWJHTENvbnRleHQiLCJwYXJhbXMiLCJhbHBoYSIsImRlcHRoIiwic3RlbmNpbCIsImFudGlhbGlhcyIsInByZXNlcnZlRHJhd2luZ0J1ZmZlciIsImdldENvbnRleHQiLCJpc1dlYkdMMiIsImNvbnNvbGUiLCJlcnJvciIsImNsZWFyQ29sb3IiLCJyZW5kZXIiLCJ0aW1lIiwiRGF0ZSIsIm5vdyIsInNpbiIsInBvaW50ZXIiLCJpbnRlbnNpdHkiLCJzcXJ0IiwibWluIiwiY2xlYXIiLCJDT0xPUl9CVUZGRVJfQklUIiwiZm9yRWFjaCIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsInJlc2l6ZUNhbnZhcyIsIndpZHRoIiwiY2xpZW50V2lkdGgiLCJoZWlnaHQiLCJjbGllbnRIZWlnaHQiLCJ1cGRhdGVQb2ludGVyTW92ZURhdGEiLCJwb3NYIiwicG9zWSIsImFicyIsImNvcnJlY3REZWx0YVgiLCJkZWx0YSIsImFzcGVjdFJhdGlvIiwiY29ycmVjdERlbHRhWSIsInNwbGF0UG9pbnRlciIsImR4IiwiU1BMQVRfRk9SQ0UiLCJkeSIsInNwbGF0IiwieCIsInkiLCJjZW50ZXJYIiwiY2VudGVyWSIsInJhZGl1cyIsImF0dGFjaEV2ZW50TGlzdGVuZXJzIiwiYm9keSIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvciIsIm1vdXNlTW92ZUhhbmRsZXIiLCJlIiwiY2xpZW50WCIsImNsaWVudFkiLCJ0b3VjaFN0YXJ0SGFuZGxlciIsInByZXZlbnREZWZhdWx0IiwidG91Y2hlcyIsInRhcmdldFRvdWNoZXMiLCJsZW5ndGgiLCJwdXNoIiwiaWRlbnRpZmllciIsInRvdWNoTW92ZUhhbmRsZXIiLCJ0b3VjaEVuZEhhbmRsZXIiLCJjaGFuZ2VkVG91Y2hlcyIsImZpbmQiLCJhZGRFdmVudExpc3RlbmVyIiwicGFzc2l2ZSIsImluaXRGbHVpZFNpbXVsYXRpb24iLCJsb2ciLCJnZXRFbGVtZW50QnlJZCIsIkRFTlNJVFlfRElTU0lQQVRJT04iLCJWRUxPQ0lUWV9ESVNTSVBBVElPTiIsIlBSRVNTVVJFIiwiQ1VSTCIsIlNQTEFUX1JBRElVUyIsIkNPTE9SRlVMIiwiQ09MT1JfVVBEQVRFX1NQRUVEIiwiUEFVU0VEIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/lib/fluid.ts\n"));

/***/ })

});