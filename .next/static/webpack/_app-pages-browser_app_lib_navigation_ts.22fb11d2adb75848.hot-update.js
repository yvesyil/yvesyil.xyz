"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_app-pages-browser_app_lib_navigation_ts",{

/***/ "(app-pages-browser)/./app/lib/navigation.ts":
/*!*******************************!*\
  !*** ./app/lib/navigation.ts ***!
  \*******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cleanupNavigation: function() { return /* binding */ cleanupNavigation; },\n/* harmony export */   initializeNavigation: function() { return /* binding */ initializeNavigation; }\n/* harmony export */ });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ \"(app-pages-browser)/./app/lib/utils.ts\");\n\n// Page navigation order\nconst pageOrder = [\n    \"/\",\n    \"/whoami\",\n    \"/projects\",\n    \"/writings\",\n    \"/contact\"\n];\nlet currentIndex = 0;\nlet isNavigating = false;\nlet listenersAttached = false;\nlet lastNavigationTime = 0;\nconst NAVIGATION_COOLDOWN = 250;\n// Function to check if current page should have scroll navigation\nfunction shouldEnableNavigation() {\n    if (false) {}\n    const contentElement = document.querySelector(\".content-navigation-enabled\");\n    return contentElement !== null;\n}\n// Function to update current index based on current path\nfunction updateCurrentIndex() {\n    if (false) {}\n    const currentPath = window.location.pathname;\n    const index = pageOrder.indexOf(currentPath);\n    currentIndex = index !== -1 ? index : 0;\n}\n// Navigation function using Next.js router\nfunction navigateToPage(targetPage) {\n    if (false) {}\n    // Use Next.js client-side navigation\n    window.location.href = targetPage;\n}\n// Handle wheel events for scroll navigation\nconst handleWheel = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.debounce)(async (event)=>{\n    if (isNavigating || !shouldEnableNavigation()) return;\n    const now = Date.now();\n    if (now - lastNavigationTime < NAVIGATION_COOLDOWN) return;\n    event.preventDefault();\n    let targetIndex;\n    if (event.deltaY > 0) {\n        targetIndex = (currentIndex + 1) % pageOrder.length;\n    } else {\n        targetIndex = (currentIndex - 1 + pageOrder.length) % pageOrder.length;\n    }\n    const targetPage = pageOrder[targetIndex];\n    isNavigating = true;\n    lastNavigationTime = now;\n    try {\n        navigateToPage(targetPage);\n    } catch (error) {\n        console.error(\"Navigation error:\", error);\n    }\n    setTimeout(()=>{\n        isNavigating = false;\n    }, 150);\n}, 30);\n// Handle touch events for mobile\nlet touchStartY = 0;\nlet touchEndY = 0;\nlet touchStartX = 0;\nlet touchEndX = 0;\nlet touchStartTime = 0;\nconst handleTouchStart = (event)=>{\n    if (!shouldEnableNavigation()) return;\n    const touch = event.changedTouches[0];\n    touchStartY = touch.screenY;\n    touchStartX = touch.screenX;\n    touchStartTime = Date.now();\n};\nconst handleTouchEnd = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.debounce)(async (event)=>{\n    if (isNavigating || !shouldEnableNavigation()) return;\n    const now = Date.now();\n    if (now - lastNavigationTime < NAVIGATION_COOLDOWN) return;\n    const touch = event.changedTouches[0];\n    touchEndY = touch.screenY;\n    touchEndX = touch.screenX;\n    const deltaY = touchStartY - touchEndY;\n    const deltaX = Math.abs(touchStartX - touchEndX);\n    const touchDuration = Date.now() - touchStartTime;\n    if (Math.abs(deltaY) < 30 || deltaX > Math.abs(deltaY) || touchDuration > 500 || touchDuration < 30) {\n        return;\n    }\n    event.preventDefault();\n    let targetIndex;\n    if (deltaY > 0) {\n        targetIndex = (currentIndex + 1) % pageOrder.length;\n    } else {\n        targetIndex = (currentIndex - 1 + pageOrder.length) % pageOrder.length;\n    }\n    const targetPage = pageOrder[targetIndex];\n    isNavigating = true;\n    lastNavigationTime = now;\n    try {\n        navigateToPage(targetPage);\n    } catch (error) {\n        console.error(\"Navigation error:\", error);\n    }\n    setTimeout(()=>{\n        isNavigating = false;\n    }, 150);\n}, 25);\n// Handle keyboard navigation\nconst handleKeyDown = async (event)=>{\n    if (isNavigating || !shouldEnableNavigation()) return;\n    const now = Date.now();\n    if (now - lastNavigationTime < NAVIGATION_COOLDOWN) return;\n    let targetIndex;\n    switch(event.key){\n        case \"ArrowDown\":\n        case \" \":\n            event.preventDefault();\n            targetIndex = (currentIndex + 1) % pageOrder.length;\n            break;\n        case \"ArrowUp\":\n            event.preventDefault();\n            targetIndex = (currentIndex - 1 + pageOrder.length) % pageOrder.length;\n            break;\n        default:\n            return;\n    }\n    const targetPage = pageOrder[targetIndex];\n    isNavigating = true;\n    lastNavigationTime = now;\n    try {\n        navigateToPage(targetPage);\n    } catch (error) {\n        console.error(\"Navigation error:\", error);\n    }\n    setTimeout(()=>{\n        isNavigating = false;\n    }, 150);\n};\n// Function to attach event listeners\nfunction attachListeners() {\n    if (typeof document === \"undefined\" || listenersAttached) return;\n    document.addEventListener(\"wheel\", handleWheel, {\n        passive: false\n    });\n    document.addEventListener(\"touchstart\", handleTouchStart, {\n        passive: true\n    });\n    document.addEventListener(\"touchend\", handleTouchEnd, {\n        passive: false\n    });\n    document.addEventListener(\"keydown\", handleKeyDown);\n    listenersAttached = true;\n}\n// Function to remove event listeners\nfunction removeListeners() {\n    if (typeof document === \"undefined\" || !listenersAttached) return;\n    document.removeEventListener(\"wheel\", handleWheel);\n    document.removeEventListener(\"touchstart\", handleTouchStart);\n    document.removeEventListener(\"touchend\", handleTouchEnd);\n    document.removeEventListener(\"keydown\", handleKeyDown);\n    listenersAttached = false;\n}\n// Function to initialize navigation\nfunction initializeNavigation() {\n    if (false) {}\n    updateCurrentIndex();\n    if (shouldEnableNavigation()) {\n        attachListeners();\n    } else {\n        removeListeners();\n    }\n}\n// Clean up function\nfunction cleanupNavigation() {\n    removeListeners();\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9saWIvbmF2aWdhdGlvbi50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBbUM7QUFFbkMsd0JBQXdCO0FBQ3hCLE1BQU1DLFlBQVk7SUFBQztJQUFLO0lBQVc7SUFBYTtJQUFhO0NBQVc7QUFFeEUsSUFBSUMsZUFBZTtBQUNuQixJQUFJQyxlQUFlO0FBQ25CLElBQUlDLG9CQUFvQjtBQUN4QixJQUFJQyxxQkFBcUI7QUFDekIsTUFBTUMsc0JBQXNCO0FBRTVCLGtFQUFrRTtBQUNsRSxTQUFTQztJQUNQLElBQUksS0FBa0IsRUFBYSxFQUFhO0lBQ2hELE1BQU1DLGlCQUFpQkMsU0FBU0MsYUFBYSxDQUFDO0lBQzlDLE9BQU9GLG1CQUFtQjtBQUM1QjtBQUVBLHlEQUF5RDtBQUN6RCxTQUFTRztJQUNQLElBQUksS0FBa0IsRUFBYSxFQUFPO0lBQzFDLE1BQU1DLGNBQWNDLE9BQU9DLFFBQVEsQ0FBQ0MsUUFBUTtJQUM1QyxNQUFNQyxRQUFRZixVQUFVZ0IsT0FBTyxDQUFDTDtJQUNoQ1YsZUFBZWMsVUFBVSxDQUFDLElBQUlBLFFBQVE7QUFDeEM7QUFFQSwyQ0FBMkM7QUFDM0MsU0FBU0UsZUFBZUMsVUFBa0I7SUFDeEMsSUFBSSxLQUFrQixFQUFhLEVBQU87SUFFMUMscUNBQXFDO0lBQ3JDTixPQUFPQyxRQUFRLENBQUNNLElBQUksR0FBR0Q7QUFDekI7QUFFQSw0Q0FBNEM7QUFDNUMsTUFBTUUsY0FBY3JCLGdEQUFRQSxDQUFDLE9BQU9zQjtJQUNsQyxJQUFJbkIsZ0JBQWdCLENBQUNJLDBCQUEwQjtJQUUvQyxNQUFNZ0IsTUFBTUMsS0FBS0QsR0FBRztJQUNwQixJQUFJQSxNQUFNbEIscUJBQXFCQyxxQkFBcUI7SUFFcERnQixNQUFNRyxjQUFjO0lBRXBCLElBQUlDO0lBQ0osSUFBSUosTUFBTUssTUFBTSxHQUFHLEdBQUc7UUFDcEJELGNBQWMsQ0FBQ3hCLGVBQWUsS0FBS0QsVUFBVTJCLE1BQU07SUFDckQsT0FBTztR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Q2RDLFFBQVFELEtBQUssQ0FBQyxxQkFBcUJBO0lBQ3JDO0lBRUFFLFdBQVc7UUFDVDVCLGVBQWU7SUFDakIsR0FBRztBQUNMO0FBRUEscUNBQXFDO0FBQ3JDLFNBQVM4QztJQUNQLElBQUksT0FBT3hDLGFBQWEsZUFBZUwsbUJBQW1CO0lBRTFESyxTQUFTeUMsZ0JBQWdCLENBQUMsU0FBUzdCLGFBQWE7UUFBRThCLFNBQVM7SUFBTTtJQUNqRTFDLFNBQVN5QyxnQkFBZ0IsQ0FBQyxjQUFjYixrQkFBa0I7UUFBRWMsU0FBUztJQUFLO0lBQzFFMUMsU0FBU3lDLGdCQUFnQixDQUFDLFlBQVlSLGdCQUFnQjtRQUFFUyxTQUFTO0lBQU07SUFDdkUxQyxTQUFTeUMsZ0JBQWdCLENBQUMsV0FBV0g7SUFFckMzQyxvQkFBb0I7QUFDdEI7QUFFQSxxQ0FBcUM7QUFDckMsU0FBU2dEO0lBQ1AsSUFBSSxPQUFPM0MsYUFBYSxlQUFlLENBQUNMLG1CQUFtQjtJQUUzREssU0FBUzRDLG1CQUFtQixDQUFDLFNBQVNoQztJQUN0Q1osU0FBUzRDLG1CQUFtQixDQUFDLGNBQWNoQjtJQUMzQzVCLFNBQVM0QyxtQkFBbUIsQ0FBQyxZQUFZWDtJQUN6Q2pDLFNBQVM0QyxtQkFBbUIsQ0FBQyxXQUFXTjtJQUV4QzNDLG9CQUFvQjtBQUN0QjtBQUVBLG9DQUFvQztBQUM3QixTQUFTa0Q7SUFDZCxJQUFJLEtBQWtCLEVBQWEsRUFBTztJQUUxQzNDO0lBRUEsSUFBSUosMEJBQTBCO1FBQzVCMEM7SUFDRixPQUFPO1FBQ0xHO0lBQ0Y7QUFDRjtBQUVBLG9CQUFvQjtBQUNiLFNBQVNHO0lBQ2RIO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vYXBwL2xpYi9uYXZpZ2F0aW9uLnRzP2Q5ZTgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZGVib3VuY2UgfSBmcm9tICcuL3V0aWxzJztcblxuLy8gUGFnZSBuYXZpZ2F0aW9uIG9yZGVyXG5jb25zdCBwYWdlT3JkZXIgPSBbJy8nLCAnL3dob2FtaScsICcvcHJvamVjdHMnLCAnL3dyaXRpbmdzJywgJy9jb250YWN0J107XG5cbmxldCBjdXJyZW50SW5kZXggPSAwO1xubGV0IGlzTmF2aWdhdGluZyA9IGZhbHNlO1xubGV0IGxpc3RlbmVyc0F0dGFjaGVkID0gZmFsc2U7XG5sZXQgbGFzdE5hdmlnYXRpb25UaW1lID0gMDtcbmNvbnN0IE5BVklHQVRJT05fQ09PTERPV04gPSAyNTA7XG5cbi8vIEZ1bmN0aW9uIHRvIGNoZWNrIGlmIGN1cnJlbnQgcGFnZSBzaG91bGQgaGF2ZSBzY3JvbGwgbmF2aWdhdGlvblxuZnVuY3Rpb24gc2hvdWxkRW5hYmxlTmF2aWdhdGlvbigpOiBib29sZWFuIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IGNvbnRlbnRFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmNvbnRlbnQtbmF2aWdhdGlvbi1lbmFibGVkJyk7XG4gIHJldHVybiBjb250ZW50RWxlbWVudCAhPT0gbnVsbDtcbn1cblxuLy8gRnVuY3Rpb24gdG8gdXBkYXRlIGN1cnJlbnQgaW5kZXggYmFzZWQgb24gY3VycmVudCBwYXRoXG5mdW5jdGlvbiB1cGRhdGVDdXJyZW50SW5kZXgoKTogdm9pZCB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuO1xuICBjb25zdCBjdXJyZW50UGF0aCA9IHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZTtcbiAgY29uc3QgaW5kZXggPSBwYWdlT3JkZXIuaW5kZXhPZihjdXJyZW50UGF0aCk7XG4gIGN1cnJlbnRJbmRleCA9IGluZGV4ICE9PSAtMSA/IGluZGV4IDogMDtcbn1cblxuLy8gTmF2aWdhdGlvbiBmdW5jdGlvbiB1c2luZyBOZXh0LmpzIHJvdXRlclxuZnVuY3Rpb24gbmF2aWdhdGVUb1BhZ2UodGFyZ2V0UGFnZTogc3RyaW5nKTogdm9pZCB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuO1xuICBcbiAgLy8gVXNlIE5leHQuanMgY2xpZW50LXNpZGUgbmF2aWdhdGlvblxuICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IHRhcmdldFBhZ2U7XG59XG5cbi8vIEhhbmRsZSB3aGVlbCBldmVudHMgZm9yIHNjcm9sbCBuYXZpZ2F0aW9uXG5jb25zdCBoYW5kbGVXaGVlbCA9IGRlYm91bmNlKGFzeW5jIChldmVudDogV2hlZWxFdmVudCkgPT4ge1xuICBpZiAoaXNOYXZpZ2F0aW5nIHx8ICFzaG91bGRFbmFibGVOYXZpZ2F0aW9uKCkpIHJldHVybjtcbiAgXG4gIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gIGlmIChub3cgLSBsYXN0TmF2aWdhdGlvblRpbWUgPCBOQVZJR0FUSU9OX0NPT0xET1dOKSByZXR1cm47XG4gIFxuICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICBcbiAgbGV0IHRhcmdldEluZGV4OiBudW1iZXI7XG4gIGlmIChldmVudC5kZWx0YVkgPiAwKSB7XG4gICAgdGFyZ2V0SW5kZXggPSAoY3VycmVudEluZGV4ICsgMSkgJSBwYWdlT3JkZXIubGVuZ3RoO1xuICB9IGVsc2Uge1xuICAgIHRhcmdldEluZGV4ID0gKGN1cnJlbnRJbmRleCAtIDEgKyBwYWdlT3JkZXIubGVuZ3RoKSAlIHBhZ2VPcmRlci5sZW5ndGg7XG4gIH1cbiAgXG4gIGNvbnN0IHRhcmdldFBhZ2UgPSBwYWdlT3JkZXJbdGFyZ2V0SW5kZXhdO1xuICBcbiAgaXNOYXZpZ2F0aW5nID0gdHJ1ZTtcbiAgbGFzdE5hdmlnYXRpb25UaW1lID0gbm93O1xuICBcbiAgdHJ5IHtcbiAgICBuYXZpZ2F0ZVRvUGFnZSh0YXJnZXRQYWdlKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdOYXZpZ2F0aW9uIGVycm9yOicsIGVycm9yKTtcbiAgfVxuICBcbiAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgaXNOYXZpZ2F0aW5nID0gZmFsc2U7XG4gIH0sIDE1MCk7XG59LCAzMCk7XG5cbi8vIEhhbmRsZSB0b3VjaCBldmVudHMgZm9yIG1vYmlsZVxubGV0IHRvdWNoU3RhcnRZID0gMDtcbmxldCB0b3VjaEVuZFkgPSAwO1xubGV0IHRvdWNoU3RhcnRYID0gMDtcbmxldCB0b3VjaEVuZFggPSAwO1xubGV0IHRvdWNoU3RhcnRUaW1lID0gMDtcblxuY29uc3QgaGFuZGxlVG91Y2hTdGFydCA9IChldmVudDogVG91Y2hFdmVudCk6IHZvaWQgPT4ge1xuICBpZiAoIXNob3VsZEVuYWJsZU5hdmlnYXRpb24oKSkgcmV0dXJuO1xuICBcbiAgY29uc3QgdG91Y2ggPSBldmVudC5jaGFuZ2VkVG91Y2hlc1swXTtcbiAgdG91Y2hTdGFydFkgPSB0b3VjaC5zY3JlZW5ZO1xuICB0b3VjaFN0YXJ0WCA9IHRvdWNoLnNjcmVlblg7XG4gIHRvdWNoU3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbn07XG5cbmNvbnN0IGhhbmRsZVRvdWNoRW5kID0gZGVib3VuY2UoYXN5bmMgKGV2ZW50OiBUb3VjaEV2ZW50KSA9PiB7XG4gIGlmIChpc05hdmlnYXRpbmcgfHwgIXNob3VsZEVuYWJsZU5hdmlnYXRpb24oKSkgcmV0dXJuO1xuICBcbiAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgaWYgKG5vdyAtIGxhc3ROYXZpZ2F0aW9uVGltZSA8IE5BVklHQVRJT05fQ09PTERPV04pIHJldHVybjtcbiAgXG4gIGNvbnN0IHRvdWNoID0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF07XG4gIHRvdWNoRW5kWSA9IHRvdWNoLnNjcmVlblk7XG4gIHRvdWNoRW5kWCA9IHRvdWNoLnNjcmVlblg7XG4gIFxuICBjb25zdCBkZWx0YVkgPSB0b3VjaFN0YXJ0WSAtIHRvdWNoRW5kWTtcbiAgY29uc3QgZGVsdGFYID0gTWF0aC5hYnModG91Y2hTdGFydFggLSB0b3VjaEVuZFgpO1xuICBjb25zdCB0b3VjaER1cmF0aW9uID0gRGF0ZS5ub3coKSAtIHRvdWNoU3RhcnRUaW1lO1xuICBcbiAgaWYgKE1hdGguYWJzKGRlbHRhWSkgPCAzMCB8fCBcbiAgICAgIGRlbHRhWCA+IE1hdGguYWJzKGRlbHRhWSkgfHwgXG4gICAgICB0b3VjaER1cmF0aW9uID4gNTAwIHx8IFxuICAgICAgdG91Y2hEdXJhdGlvbiA8IDMwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIFxuICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICBcbiAgbGV0IHRhcmdldEluZGV4OiBudW1iZXI7XG4gIGlmIChkZWx0YVkgPiAwKSB7XG4gICAgdGFyZ2V0SW5kZXggPSAoY3VycmVudEluZGV4ICsgMSkgJSBwYWdlT3JkZXIubGVuZ3RoO1xuICB9IGVsc2Uge1xuICAgIHRhcmdldEluZGV4ID0gKGN1cnJlbnRJbmRleCAtIDEgKyBwYWdlT3JkZXIubGVuZ3RoKSAlIHBhZ2VPcmRlci5sZW5ndGg7XG4gIH1cbiAgXG4gIGNvbnN0IHRhcmdldFBhZ2UgPSBwYWdlT3JkZXJbdGFyZ2V0SW5kZXhdO1xuICBcbiAgaXNOYXZpZ2F0aW5nID0gdHJ1ZTtcbiAgbGFzdE5hdmlnYXRpb25UaW1lID0gbm93O1xuICBcbiAgdHJ5IHtcbiAgICBuYXZpZ2F0ZVRvUGFnZSh0YXJnZXRQYWdlKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdOYXZpZ2F0aW9uIGVycm9yOicsIGVycm9yKTtcbiAgfVxuICBcbiAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgaXNOYXZpZ2F0aW5nID0gZmFsc2U7XG4gIH0sIDE1MCk7XG59LCAyNSk7XG5cbi8vIEhhbmRsZSBrZXlib2FyZCBuYXZpZ2F0aW9uXG5jb25zdCBoYW5kbGVLZXlEb3duID0gYXN5bmMgKGV2ZW50OiBLZXlib2FyZEV2ZW50KTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gIGlmIChpc05hdmlnYXRpbmcgfHwgIXNob3VsZEVuYWJsZU5hdmlnYXRpb24oKSkgcmV0dXJuO1xuICBcbiAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgaWYgKG5vdyAtIGxhc3ROYXZpZ2F0aW9uVGltZSA8IE5BVklHQVRJT05fQ09PTERPV04pIHJldHVybjtcbiAgXG4gIGxldCB0YXJnZXRJbmRleDogbnVtYmVyO1xuICBzd2l0Y2goZXZlbnQua2V5KSB7XG4gICAgY2FzZSAnQXJyb3dEb3duJzpcbiAgICBjYXNlICcgJzpcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB0YXJnZXRJbmRleCA9IChjdXJyZW50SW5kZXggKyAxKSAlIHBhZ2VPcmRlci5sZW5ndGg7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdBcnJvd1VwJzpcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB0YXJnZXRJbmRleCA9IChjdXJyZW50SW5kZXggLSAxICsgcGFnZU9yZGVyLmxlbmd0aCkgJSBwYWdlT3JkZXIubGVuZ3RoO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybjtcbiAgfVxuICBcbiAgY29uc3QgdGFyZ2V0UGFnZSA9IHBhZ2VPcmRlclt0YXJnZXRJbmRleF07XG4gIFxuICBpc05hdmlnYXRpbmcgPSB0cnVlO1xuICBsYXN0TmF2aWdhdGlvblRpbWUgPSBub3c7XG4gIFxuICB0cnkge1xuICAgIG5hdmlnYXRlVG9QYWdlKHRhcmdldFBhZ2UpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ05hdmlnYXRpb24gZXJyb3I6JywgZXJyb3IpO1xuICB9XG4gIFxuICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICBpc05hdmlnYXRpbmcgPSBmYWxzZTtcbiAgfSwgMTUwKTtcbn07XG5cbi8vIEZ1bmN0aW9uIHRvIGF0dGFjaCBldmVudCBsaXN0ZW5lcnNcbmZ1bmN0aW9uIGF0dGFjaExpc3RlbmVycygpOiB2b2lkIHtcbiAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcgfHwgbGlzdGVuZXJzQXR0YWNoZWQpIHJldHVybjtcbiAgXG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3doZWVsJywgaGFuZGxlV2hlZWwsIHsgcGFzc2l2ZTogZmFsc2UgfSk7XG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBoYW5kbGVUb3VjaFN0YXJ0LCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgaGFuZGxlVG91Y2hFbmQsIHsgcGFzc2l2ZTogZmFsc2UgfSk7XG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBoYW5kbGVLZXlEb3duKTtcbiAgXG4gIGxpc3RlbmVyc0F0dGFjaGVkID0gdHJ1ZTtcbn1cblxuLy8gRnVuY3Rpb24gdG8gcmVtb3ZlIGV2ZW50IGxpc3RlbmVyc1xuZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXJzKCk6IHZvaWQge1xuICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJyB8fCAhbGlzdGVuZXJzQXR0YWNoZWQpIHJldHVybjtcbiAgXG4gIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3doZWVsJywgaGFuZGxlV2hlZWwpO1xuICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgaGFuZGxlVG91Y2hTdGFydCk7XG4gIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgaGFuZGxlVG91Y2hFbmQpO1xuICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgaGFuZGxlS2V5RG93bik7XG4gIFxuICBsaXN0ZW5lcnNBdHRhY2hlZCA9IGZhbHNlO1xufVxuXG4vLyBGdW5jdGlvbiB0byBpbml0aWFsaXplIG5hdmlnYXRpb25cbmV4cG9ydCBmdW5jdGlvbiBpbml0aWFsaXplTmF2aWdhdGlvbigpOiB2b2lkIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm47XG4gIFxuICB1cGRhdGVDdXJyZW50SW5kZXgoKTtcbiAgXG4gIGlmIChzaG91bGRFbmFibGVOYXZpZ2F0aW9uKCkpIHtcbiAgICBhdHRhY2hMaXN0ZW5lcnMoKTtcbiAgfSBlbHNlIHtcbiAgICByZW1vdmVMaXN0ZW5lcnMoKTtcbiAgfVxufVxuXG4vLyBDbGVhbiB1cCBmdW5jdGlvblxuZXhwb3J0IGZ1bmN0aW9uIGNsZWFudXBOYXZpZ2F0aW9uKCk6IHZvaWQge1xuICByZW1vdmVMaXN0ZW5lcnMoKTtcbn1cbiJdLCJuYW1lcyI6WyJkZWJvdW5jZSIsInBhZ2VPcmRlciIsImN1cnJlbnRJbmRleCIsImlzTmF2aWdhdGluZyIsImxpc3RlbmVyc0F0dGFjaGVkIiwibGFzdE5hdmlnYXRpb25UaW1lIiwiTkFWSUdBVElPTl9DT09MRE9XTiIsInNob3VsZEVuYWJsZU5hdmlnYXRpb24iLCJjb250ZW50RWxlbWVudCIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvciIsInVwZGF0ZUN1cnJlbnRJbmRleCIsImN1cnJlbnRQYXRoIiwid2luZG93IiwibG9jYXRpb24iLCJwYXRobmFtZSIsImluZGV4IiwiaW5kZXhPZiIsIm5hdmlnYXRlVG9QYWdlIiwidGFyZ2V0UGFnZSIsImhyZWYiLCJoYW5kbGVXaGVlbCIsImV2ZW50Iiwibm93IiwiRGF0ZSIsInByZXZlbnREZWZhdWx0IiwidGFyZ2V0SW5kZXgiLCJkZWx0YVkiLCJsZW5ndGgiLCJlcnJvciIsImNvbnNvbGUiLCJzZXRUaW1lb3V0IiwidG91Y2hTdGFydFkiLCJ0b3VjaEVuZFkiLCJ0b3VjaFN0YXJ0WCIsInRvdWNoRW5kWCIsInRvdWNoU3RhcnRUaW1lIiwiaGFuZGxlVG91Y2hTdGFydCIsInRvdWNoIiwiY2hhbmdlZFRvdWNoZXMiLCJzY3JlZW5ZIiwic2NyZWVuWCIsImhhbmRsZVRvdWNoRW5kIiwiZGVsdGFYIiwiTWF0aCIsImFicyIsInRvdWNoRHVyYXRpb24iLCJoYW5kbGVLZXlEb3duIiwia2V5IiwiYXR0YWNoTGlzdGVuZXJzIiwiYWRkRXZlbnRMaXN0ZW5lciIsInBhc3NpdmUiLCJyZW1vdmVMaXN0ZW5lcnMiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiaW5pdGlhbGl6ZU5hdmlnYXRpb24iLCJjbGVhbnVwTmF2aWdhdGlvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/lib/navigation.ts\n"));

/***/ })

});