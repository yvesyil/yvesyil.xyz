"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_app_lib_polaroid-cursor_ts"],{

/***/ "(app-pages-browser)/./app/lib/polaroid-cursor.ts":
/*!************************************!*\
  !*** ./app/lib/polaroid-cursor.ts ***!
  \************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cleanupPolaroidCursor: () => (/* binding */ cleanupPolaroidCursor),\n/* harmony export */   initPolaroidCursor: () => (/* binding */ initPolaroidCursor)\n/* harmony export */ });\n// Polaroid Cursor Effect\n// Creates polaroid photos that follow mouse movement\nlet polaroidInitialized = false;\nlet container = null;\nlet polaroids = [];\nlet mouseX = 0;\nlet mouseY = 0;\nlet lastMouseX = 0;\nlet lastMouseY = 0;\nlet spawnTimer = 0; // Timer for consistent spawning\nlet wasMouseMoving = false;\nlet resumeDelay = 0; // frames to delay after movement resumes\nconst RESUME_DELAY_FRAMES = 5; // ~0.1s at 60fps\nlet resumeUntilMs = 0; // timestamp until which we delay spawning after resume\nlet idleFrames = 0; // frames not moving\nconst IDLE_ARM_FRAMES = 20; // require ~0.33s idle before arming resume delay\n// Tiny images for better performance\nconst photoList = [\n    '/photos/tiny/AngelHoldingChalice.jpg',\n    '/photos/tiny/AStreetInHaarlem.jpg',\n    '/photos/tiny/Autopark.jpg',\n    '/photos/tiny/CafeHetWapenVanBlo.jpg',\n    '/photos/tiny/Caritasbronden.jpg',\n    '/photos/tiny/CatLaying.jpg',\n    '/photos/tiny/CatWithLargeCollar.jpg',\n    '/photos/tiny/ChurchInTheDistance.jpg',\n    '/photos/tiny/Cows.jpg',\n    '/photos/tiny/CowsCurious.jpg',\n    '/photos/tiny/DeBurcht.jpg',\n    '/photos/tiny/FrederiksbergSlot.jpg',\n    '/photos/tiny/GrassPlane.jpg',\n    '/photos/tiny/Lake.jpg',\n    '/photos/tiny/Maan.jpg',\n    '/photos/tiny/Mermaid.jpg',\n    '/photos/tiny/Office.jpg',\n    '/photos/tiny/SAIL.jpg',\n    '/photos/tiny/SintBonifatiuskerk.jpg',\n    '/photos/tiny/Stairs.jpg',\n    '/photos/tiny/ZaanRiver.jpg'\n];\nconst config = {\n    maxPolaroids: 20,\n    polaroidLife: 60,\n    spawnInterval: 8,\n    fadeOutDuration: 30,\n    minMovementThreshold: 1,\n    polaroidSize: 140\n};\nlet photoIndex = 0;\nfunction getNextPhoto() {\n    const src = photoList[photoIndex];\n    photoIndex = (photoIndex + 1) % photoList.length;\n    return src;\n}\nfunction createPolaroidElement(x, y) {\n    const element = document.createElement('div');\n    const image = getNextPhoto();\n    element.className = 'polaroid-photo';\n    element.innerHTML = '\\n    <div class=\"polaroid-inner\">\\n      <img src=\"'.concat(image, '\" alt=\"Random photo\" />\\n      <div class=\"polaroid-caption\"></div>\\n    </div>\\n  ');\n    // Random rotation and slight scale variation\n    const rotation = (Math.random() - 0.5) * 30; // -15 to 15 degrees\n    const scale = 0.8 + Math.random() * 0.4; // 0.8 to 1.2\n    element.style.cssText = \"\\n    position: fixed;\\n    pointer-events: none;\\n    z-index: 1000;\\n    transform: translate(-50%, -50%) rotate(\".concat(rotation, \"deg) scale(\").concat(scale, \");\\n    transition: none;\\n  \");\n    // Set initial position immediately so it doesn't flash at (0,0)\n    element.style.left = \"\".concat(x, \"px\");\n    element.style.top = \"\".concat(y, \"px\");\n    const polaroidElement = {\n        element,\n        x,\n        y,\n        rotation,\n        scale,\n        opacity: 1,\n        life: config.polaroidLife,\n        maxLife: config.polaroidLife,\n        vx: (Math.random() - 0.5) * 2,\n        vy: (Math.random() - 0.5) * 2,\n        image\n    };\n    if (container) {\n        container.appendChild(element);\n    }\n    return polaroidElement;\n}\nfunction updatePolaroids() {\n    // Update existing polaroids\n    for(let i = polaroids.length - 1; i >= 0; i--){\n        const polaroid = polaroids[i];\n        // Update position with slight drift\n        polaroid.x += polaroid.vx;\n        polaroid.y += polaroid.vy;\n        // Apply slight drag\n        polaroid.vx *= 0.98;\n        polaroid.vy *= 0.98;\n        // Update life\n        polaroid.life--;\n        // Calculate opacity based on remaining life\n        if (polaroid.life < config.fadeOutDuration) {\n            polaroid.opacity = polaroid.life / config.fadeOutDuration;\n        }\n        // Update element position and opacity\n        polaroid.element.style.left = \"\".concat(polaroid.x, \"px\");\n        polaroid.element.style.top = \"\".concat(polaroid.y, \"px\");\n        polaroid.element.style.opacity = polaroid.opacity.toString();\n        // Remove dead polaroids\n        if (polaroid.life <= 0) {\n            if (container && polaroid.element.parentNode) {\n                container.removeChild(polaroid.element);\n            }\n            polaroids.splice(i, 1);\n        }\n    }\n    // Movement metrics and gating\n    const dx = mouseX - lastMouseX;\n    const dy = mouseY - lastMouseY;\n    const movement = Math.sqrt(dx * dx + dy * dy);\n    const isMoving = movement > config.minMovementThreshold;\n    // Track idle vs moving frames to avoid re-arming delay on micro pauses\n    if (isMoving) {\n        // Only arm a delay if we were truly idle for a bit\n        if (!wasMouseMoving && idleFrames >= IDLE_ARM_FRAMES) {\n            resumeDelay = RESUME_DELAY_FRAMES;\n            spawnTimer = 0; // reset cadence\n            resumeUntilMs = typeof performance !== 'undefined' ? performance.now() + 120 : 0; // ~120ms\n        }\n        idleFrames = 0;\n    } else {\n        idleFrames++;\n    }\n    // Time-based guard (more robust across frame rates)\n    if (resumeUntilMs && typeof performance !== 'undefined' && performance.now() < resumeUntilMs) {\n        wasMouseMoving = isMoving;\n        // DO NOT update lastMouse here; keep delta non-zero after delay\n        spawnTimer++; // advance cadence during delay so first spawn can happen right after\n        return;\n    } else {\n        resumeUntilMs = 0;\n    }\n    // Fallback frame-based guard\n    if (resumeDelay > 0) {\n        resumeDelay--;\n        wasMouseMoving = isMoving;\n        // DO NOT update lastMouse here; keep delta non-zero after delay\n        spawnTimer++; // advance cadence during frame-based delay\n        return;\n    }\n    // Advance cadence\n    spawnTimer++;\n    // Continuous spawning while moving\n    if (isMoving) {\n        if (spawnTimer >= config.spawnInterval) {\n            // Spawn away from the cursor to avoid covering it\n            const spawnDistance = 70 + Math.random() * 30; // 70-100px\n            const spawnAngle = Math.random() * Math.PI * 2;\n            const ringX = mouseX + Math.cos(spawnAngle) * spawnDistance;\n            const ringY = mouseY + Math.sin(spawnAngle) * spawnDistance;\n            // Spawn; replace oldest if at capacity\n            if (polaroids.length < config.maxPolaroids) {\n                polaroids.push(createPolaroidElement(ringX, ringY));\n            } else {\n                // Remove oldest polaroid and add new one for continuous flow\n                const oldest = polaroids.shift();\n                if (oldest && container && oldest.element.parentNode) {\n                    container.removeChild(oldest.element);\n                }\n                polaroids.push(createPolaroidElement(ringX, ringY));\n            }\n            spawnTimer = 0;\n        }\n    }\n    lastMouseX = mouseX;\n    lastMouseY = mouseY;\n    wasMouseMoving = isMoving;\n}\nfunction animate() {\n    updatePolaroids();\n    requestAnimationFrame(animate);\n}\n// Event handlers\nfunction attachEventListeners() {\n    if (false) {}\n    const mouseMoveHandler = (e)=>{\n        mouseX = e.clientX;\n        mouseY = e.clientY;\n    };\n    const mouseEnterHandler = (e)=>{\n        // Initialize mouse position when entering the page\n        mouseX = e.clientX;\n        mouseY = e.clientY;\n        lastMouseX = mouseX;\n        lastMouseY = mouseY;\n    };\n    const touchMoveHandler = (e)=>{\n        e.preventDefault();\n        if (e.touches.length > 0) {\n            const touch = e.touches[0];\n            mouseX = touch.clientX;\n            mouseY = touch.clientY;\n        }\n    };\n    const touchStartHandler = (e)=>{\n        if (e.touches.length > 0) {\n            const touch = e.touches[0];\n            mouseX = touch.clientX;\n            mouseY = touch.clientY;\n            lastMouseX = mouseX;\n            lastMouseY = mouseY;\n        }\n    };\n    document.addEventListener(\"mousemove\", mouseMoveHandler);\n    document.addEventListener(\"mouseenter\", mouseEnterHandler);\n    document.addEventListener(\"touchmove\", touchMoveHandler, {\n        passive: false\n    });\n    document.addEventListener(\"touchstart\", touchStartHandler, {\n        passive: true\n    });\n}\n// Main initialization function\nfunction initPolaroidCursor() {\n    if (false) {}\n    if (polaroidInitialized) {\n        console.log('Polaroid cursor already initialized');\n        return;\n    }\n    console.log('Initializing polaroid cursor effect...');\n    // Create container for polaroids\n    container = document.createElement('div');\n    container.id = 'polaroid-container';\n    container.style.cssText = \"\\n    position: fixed;\\n    top: 0;\\n    left: 0;\\n    width: 100vw;\\n    height: 100vh;\\n    pointer-events: none;\\n    z-index: 1000;\\n  \";\n    document.body.appendChild(container);\n    // Initialize mouse position to center, but will be updated on first mouse move\n    mouseX = window.innerWidth / 2;\n    mouseY = window.innerHeight / 2;\n    lastMouseX = mouseX;\n    lastMouseY = mouseY;\n    // Get actual mouse position if available\n    document.addEventListener('mousemove', (e)=>{\n        if (mouseX === window.innerWidth / 2 && mouseY === window.innerHeight / 2) {\n            // First mouse move - initialize properly\n            mouseX = e.clientX;\n            mouseY = e.clientY;\n            lastMouseX = mouseX;\n            lastMouseY = mouseY;\n        }\n    }, {\n        once: true\n    });\n    // Attach event listeners\n    attachEventListeners();\n    // Start animation loop\n    animate();\n    polaroidInitialized = true;\n    console.log('Polaroid cursor effect initialized successfully!');\n}\n// Cleanup function\nfunction cleanupPolaroidCursor() {\n    if (container && container.parentNode) {\n        document.body.removeChild(container);\n    }\n    polaroids.forEach((polaroid)=>{\n        if (polaroid.element.parentNode) {\n            polaroid.element.parentNode.removeChild(polaroid.element);\n        }\n    });\n    polaroids = [];\n    container = null;\n    polaroidInitialized = false;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9saWIvcG9sYXJvaWQtY3Vyc29yLnRzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUEseUJBQXlCO0FBQ3pCLHFEQUFxRDtBQUVyRCxJQUFJQSxzQkFBc0I7QUFDMUIsSUFBSUMsWUFBbUM7QUFDdkMsSUFBSUMsWUFBK0IsRUFBRTtBQUNyQyxJQUFJQyxTQUFTO0FBQ2IsSUFBSUMsU0FBUztBQUNiLElBQUlDLGFBQWE7QUFDakIsSUFBSUMsYUFBYTtBQUNqQixJQUFJQyxhQUFhLEdBQUcsZ0NBQWdDO0FBQ3BELElBQUlDLGlCQUFpQjtBQUNyQixJQUFJQyxjQUFjLEdBQUcseUNBQXlDO0FBQzlELE1BQU1DLHNCQUFzQixHQUFHLGlCQUFpQjtBQUNoRCxJQUFJQyxnQkFBZ0IsR0FBRyx1REFBdUQ7QUFDOUUsSUFBSUMsYUFBYSxHQUFHLG9CQUFvQjtBQUN4QyxNQUFNQyxrQkFBa0IsSUFBSSxpREFBaUQ7QUFnQjdFLHFDQUFxQztBQUNyQyxNQUFNQyxZQUFZO0lBQ2hCO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtDQUNEO0FBRUQsTUFBTUMsU0FBUztJQUNiQyxjQUFjO0lBQ2RDLGNBQWM7SUFDZEMsZUFBZTtJQUNmQyxpQkFBaUI7SUFDakJDLHNCQUFzQjtJQUN0QkMsY0FBYztBQUNoQjtBQUVBLElBQUlDLGFBQWE7QUFDakIsU0FBU0M7SUFDUCxNQUFNQyxNQUFNVixTQUFTLENBQUNRLFdBQVc7SUFDakNBLGFBQWEsQ0FBQ0EsYUFBYSxLQUFLUixVQUFVVyxNQUFNO0lBQ2hELE9BQU9EO0FBQ1Q7QUFFQSxTQUFTRSxzQkFBc0JDLENBQVMsRUFBRUMsQ0FBUztJQUNqRCxNQUFNQyxVQUFVQyxTQUFTQyxhQUFhLENBQUM7SUFDdkMsTUFBTUMsUUFBUVQ7SUFFZE0sUUFBUUksU0FBUyxHQUFH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Qy9CRixTQUFTdkIsT0FBTyxDQUFDeUIsVUFBVSxDQUFDQyxXQUFXLENBQUNILFNBQVN2QixPQUFPO1FBQzFEO0lBQ0Y7SUFFQTNCLFlBQVksRUFBRTtJQUNkRCxZQUFZO0lBQ1pELHNCQUFzQjtBQUN4QiIsInNvdXJjZXMiOlsiL1VzZXJzL3l2ZXMvUmVwb3NpdG9yaWVzL3l2ZXN5aWwueHl6L2FwcC9saWIvcG9sYXJvaWQtY3Vyc29yLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFBvbGFyb2lkIEN1cnNvciBFZmZlY3Rcbi8vIENyZWF0ZXMgcG9sYXJvaWQgcGhvdG9zIHRoYXQgZm9sbG93IG1vdXNlIG1vdmVtZW50XG5cbmxldCBwb2xhcm9pZEluaXRpYWxpemVkID0gZmFsc2U7XG5sZXQgY29udGFpbmVyOiBIVE1MRGl2RWxlbWVudCB8IG51bGwgPSBudWxsO1xubGV0IHBvbGFyb2lkczogUG9sYXJvaWRFbGVtZW50W10gPSBbXTtcbmxldCBtb3VzZVggPSAwO1xubGV0IG1vdXNlWSA9IDA7XG5sZXQgbGFzdE1vdXNlWCA9IDA7XG5sZXQgbGFzdE1vdXNlWSA9IDA7XG5sZXQgc3Bhd25UaW1lciA9IDA7IC8vIFRpbWVyIGZvciBjb25zaXN0ZW50IHNwYXduaW5nXG5sZXQgd2FzTW91c2VNb3ZpbmcgPSBmYWxzZTtcbmxldCByZXN1bWVEZWxheSA9IDA7IC8vIGZyYW1lcyB0byBkZWxheSBhZnRlciBtb3ZlbWVudCByZXN1bWVzXG5jb25zdCBSRVNVTUVfREVMQVlfRlJBTUVTID0gNTsgLy8gfjAuMXMgYXQgNjBmcHNcbmxldCByZXN1bWVVbnRpbE1zID0gMDsgLy8gdGltZXN0YW1wIHVudGlsIHdoaWNoIHdlIGRlbGF5IHNwYXduaW5nIGFmdGVyIHJlc3VtZVxubGV0IGlkbGVGcmFtZXMgPSAwOyAvLyBmcmFtZXMgbm90IG1vdmluZ1xuY29uc3QgSURMRV9BUk1fRlJBTUVTID0gMjA7IC8vIHJlcXVpcmUgfjAuMzNzIGlkbGUgYmVmb3JlIGFybWluZyByZXN1bWUgZGVsYXlcblxuaW50ZXJmYWNlIFBvbGFyb2lkRWxlbWVudCB7XG4gIGVsZW1lbnQ6IEhUTUxEaXZFbGVtZW50O1xuICB4OiBudW1iZXI7XG4gIHk6IG51bWJlcjtcbiAgcm90YXRpb246IG51bWJlcjtcbiAgc2NhbGU6IG51bWJlcjtcbiAgb3BhY2l0eTogbnVtYmVyO1xuICBsaWZlOiBudW1iZXI7XG4gIG1heExpZmU6IG51bWJlcjtcbiAgdng6IG51bWJlcjtcbiAgdnk6IG51bWJlcjtcbiAgaW1hZ2U6IHN0cmluZztcbn1cblxuLy8gVGlueSBpbWFnZXMgZm9yIGJldHRlciBwZXJmb3JtYW5jZVxuY29uc3QgcGhvdG9MaXN0ID0gW1xuICAnL3Bob3Rvcy90aW55L0FuZ2VsSG9sZGluZ0NoYWxpY2UuanBnJyxcbiAgJy9waG90b3MvdGlueS9BU3RyZWV0SW5IYWFybGVtLmpwZycsXG4gICcvcGhvdG9zL3RpbnkvQXV0b3BhcmsuanBnJyxcbiAgJy9waG90b3MvdGlueS9DYWZlSGV0V2FwZW5WYW5CbG8uanBnJyxcbiAgJy9waG90b3MvdGlueS9DYXJpdGFzYnJvbmRlbi5qcGcnLFxuICAnL3Bob3Rvcy90aW55L0NhdExheWluZy5qcGcnLFxuICAnL3Bob3Rvcy90aW55L0NhdFdpdGhMYXJnZUNvbGxhci5qcGcnLFxuICAnL3Bob3Rvcy90aW55L0NodXJjaEluVGhlRGlzdGFuY2UuanBnJyxcbiAgJy9waG90b3MvdGlueS9Db3dzLmpwZycsXG4gICcvcGhvdG9zL3RpbnkvQ293c0N1cmlvdXMuanBnJyxcbiAgJy9waG90b3MvdGlueS9EZUJ1cmNodC5qcGcnLFxuICAnL3Bob3Rvcy90aW55L0ZyZWRlcmlrc2JlcmdTbG90LmpwZycsXG4gICcvcGhvdG9zL3RpbnkvR3Jhc3NQbGFuZS5qcGcnLFxuICAnL3Bob3Rvcy90aW55L0xha2UuanBnJyxcbiAgJy9waG90b3MvdGlueS9NYWFuLmpwZycsXG4gICcvcGhvdG9zL3RpbnkvTWVybWFpZC5qcGcnLFxuICAnL3Bob3Rvcy90aW55L09mZmljZS5qcGcnLFxuICAnL3Bob3Rvcy90aW55L1NBSUwuanBnJyxcbiAgJy9waG90b3MvdGlueS9TaW50Qm9uaWZhdGl1c2tlcmsuanBnJyxcbiAgJy9waG90b3MvdGlueS9TdGFpcnMuanBnJyxcbiAgJy9waG90b3MvdGlueS9aYWFuUml2ZXIuanBnJyxcbl07XG5cbmNvbnN0IGNvbmZpZyA9IHtcbiAgbWF4UG9sYXJvaWRzOiAyMCwgLy8gSGlnaGVyIGxpbWl0IHRvIHByZXZlbnQgcGF1c2VzXG4gIHBvbGFyb2lkTGlmZTogNjAsIC8vIFNob3J0ZXIgbGlmZSBzbyBwaG90b3MgY3ljbGUgZmFzdGVyXG4gIHNwYXduSW50ZXJ2YWw6IDgsIC8vIFNwYXduIGV2ZXJ5IDQgZnJhbWVzICgxNSB0aW1lcyBwZXIgc2Vjb25kKVxuICBmYWRlT3V0RHVyYXRpb246IDMwLCAvLyBGYXN0ZXIgZmFkZSBmb3IgcXVpY2tlciB0dXJub3ZlclxuICBtaW5Nb3ZlbWVudFRocmVzaG9sZDogMSwgLy8gTG93ZXIgdGhyZXNob2xkXG4gIHBvbGFyb2lkU2l6ZTogMTQwLCAvLyBCaWdnZXIgcGhvdG9zXG59O1xuXG5sZXQgcGhvdG9JbmRleCA9IDA7XG5mdW5jdGlvbiBnZXROZXh0UGhvdG8oKTogc3RyaW5nIHtcbiAgY29uc3Qgc3JjID0gcGhvdG9MaXN0W3Bob3RvSW5kZXhdO1xuICBwaG90b0luZGV4ID0gKHBob3RvSW5kZXggKyAxKSAlIHBob3RvTGlzdC5sZW5ndGg7XG4gIHJldHVybiBzcmM7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVBvbGFyb2lkRWxlbWVudCh4OiBudW1iZXIsIHk6IG51bWJlcik6IFBvbGFyb2lkRWxlbWVudCB7XG4gIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgY29uc3QgaW1hZ2UgPSBnZXROZXh0UGhvdG8oKTtcbiAgXG4gIGVsZW1lbnQuY2xhc3NOYW1lID0gJ3BvbGFyb2lkLXBob3RvJztcbiAgZWxlbWVudC5pbm5lckhUTUwgPSBgXG4gICAgPGRpdiBjbGFzcz1cInBvbGFyb2lkLWlubmVyXCI+XG4gICAgICA8aW1nIHNyYz1cIiR7aW1hZ2V9XCIgYWx0PVwiUmFuZG9tIHBob3RvXCIgLz5cbiAgICAgIDxkaXYgY2xhc3M9XCJwb2xhcm9pZC1jYXB0aW9uXCI+PC9kaXY+XG4gICAgPC9kaXY+XG4gIGA7XG4gIFxuICAvLyBSYW5kb20gcm90YXRpb24gYW5kIHNsaWdodCBzY2FsZSB2YXJpYXRpb25cbiAgY29uc3Qgcm90YXRpb24gPSAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAzMDsgLy8gLTE1IHRvIDE1IGRlZ3JlZXNcbiAgY29uc3Qgc2NhbGUgPSAwLjggKyBNYXRoLnJhbmRvbSgpICogMC40OyAvLyAwLjggdG8gMS4yXG4gIFxuICBlbGVtZW50LnN0eWxlLmNzc1RleHQgPSBgXG4gICAgcG9zaXRpb246IGZpeGVkO1xuICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICAgIHotaW5kZXg6IDEwMDA7XG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTUwJSwgLTUwJSkgcm90YXRlKCR7cm90YXRpb259ZGVnKSBzY2FsZSgke3NjYWxlfSk7XG4gICAgdHJhbnNpdGlvbjogbm9uZTtcbiAgYDtcbiAgLy8gU2V0IGluaXRpYWwgcG9zaXRpb24gaW1tZWRpYXRlbHkgc28gaXQgZG9lc24ndCBmbGFzaCBhdCAoMCwwKVxuICBlbGVtZW50LnN0eWxlLmxlZnQgPSBgJHt4fXB4YDtcbiAgZWxlbWVudC5zdHlsZS50b3AgPSBgJHt5fXB4YDtcbiAgXG4gIGNvbnN0IHBvbGFyb2lkRWxlbWVudDogUG9sYXJvaWRFbGVtZW50ID0ge1xuICAgIGVsZW1lbnQsXG4gICAgeCxcbiAgICB5LFxuICAgIHJvdGF0aW9uLFxuICAgIHNjYWxlLFxuICAgIG9wYWNpdHk6IDEsXG4gICAgbGlmZTogY29uZmlnLnBvbGFyb2lkTGlmZSxcbiAgICBtYXhMaWZlOiBjb25maWcucG9sYXJvaWRMaWZlLFxuICAgIHZ4OiAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAyLFxuICAgIHZ5OiAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAyLFxuICAgIGltYWdlXG4gIH07XG4gIFxuICBpZiAoY29udGFpbmVyKSB7XG4gICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICB9XG4gIFxuICByZXR1cm4gcG9sYXJvaWRFbGVtZW50O1xufVxuXG5mdW5jdGlvbiB1cGRhdGVQb2xhcm9pZHMoKSB7XG4gIC8vIFVwZGF0ZSBleGlzdGluZyBwb2xhcm9pZHNcbiAgZm9yIChsZXQgaSA9IHBvbGFyb2lkcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGNvbnN0IHBvbGFyb2lkID0gcG9sYXJvaWRzW2ldO1xuICAgIFxuICAgIC8vIFVwZGF0ZSBwb3NpdGlvbiB3aXRoIHNsaWdodCBkcmlmdFxuICAgIHBvbGFyb2lkLnggKz0gcG9sYXJvaWQudng7XG4gICAgcG9sYXJvaWQueSArPSBwb2xhcm9pZC52eTtcbiAgICBcbiAgICAvLyBBcHBseSBzbGlnaHQgZHJhZ1xuICAgIHBvbGFyb2lkLnZ4ICo9IDAuOTg7XG4gICAgcG9sYXJvaWQudnkgKj0gMC45ODtcbiAgICBcbiAgICAvLyBVcGRhdGUgbGlmZVxuICAgIHBvbGFyb2lkLmxpZmUtLTtcbiAgICBcbiAgICAvLyBDYWxjdWxhdGUgb3BhY2l0eSBiYXNlZCBvbiByZW1haW5pbmcgbGlmZVxuICAgIGlmIChwb2xhcm9pZC5saWZlIDwgY29uZmlnLmZhZGVPdXREdXJhdGlvbikge1xuICAgICAgcG9sYXJvaWQub3BhY2l0eSA9IHBvbGFyb2lkLmxpZmUgLyBjb25maWcuZmFkZU91dER1cmF0aW9uO1xuICAgIH1cbiAgICBcbiAgICAvLyBVcGRhdGUgZWxlbWVudCBwb3NpdGlvbiBhbmQgb3BhY2l0eVxuICAgIHBvbGFyb2lkLmVsZW1lbnQuc3R5bGUubGVmdCA9IGAke3BvbGFyb2lkLnh9cHhgO1xuICAgIHBvbGFyb2lkLmVsZW1lbnQuc3R5bGUudG9wID0gYCR7cG9sYXJvaWQueX1weGA7XG4gICAgcG9sYXJvaWQuZWxlbWVudC5zdHlsZS5vcGFjaXR5ID0gcG9sYXJvaWQub3BhY2l0eS50b1N0cmluZygpO1xuICAgIFxuICAgIC8vIFJlbW92ZSBkZWFkIHBvbGFyb2lkc1xuICAgIGlmIChwb2xhcm9pZC5saWZlIDw9IDApIHtcbiAgICAgIGlmIChjb250YWluZXIgJiYgcG9sYXJvaWQuZWxlbWVudC5wYXJlbnROb2RlKSB7XG4gICAgICAgIGNvbnRhaW5lci5yZW1vdmVDaGlsZChwb2xhcm9pZC5lbGVtZW50KTtcbiAgICAgIH1cbiAgICAgIHBvbGFyb2lkcy5zcGxpY2UoaSwgMSk7XG4gICAgfVxuICB9XG4gIFxuICAvLyBNb3ZlbWVudCBtZXRyaWNzIGFuZCBnYXRpbmdcbiAgY29uc3QgZHggPSBtb3VzZVggLSBsYXN0TW91c2VYO1xuICBjb25zdCBkeSA9IG1vdXNlWSAtIGxhc3RNb3VzZVk7XG4gIGNvbnN0IG1vdmVtZW50ID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgY29uc3QgaXNNb3ZpbmcgPSBtb3ZlbWVudCA+IGNvbmZpZy5taW5Nb3ZlbWVudFRocmVzaG9sZDtcblxuICAvLyBUcmFjayBpZGxlIHZzIG1vdmluZyBmcmFtZXMgdG8gYXZvaWQgcmUtYXJtaW5nIGRlbGF5IG9uIG1pY3JvIHBhdXNlc1xuICBpZiAoaXNNb3ZpbmcpIHtcbiAgICAvLyBPbmx5IGFybSBhIGRlbGF5IGlmIHdlIHdlcmUgdHJ1bHkgaWRsZSBmb3IgYSBiaXRcbiAgICBpZiAoIXdhc01vdXNlTW92aW5nICYmIGlkbGVGcmFtZXMgPj0gSURMRV9BUk1fRlJBTUVTKSB7XG4gICAgICByZXN1bWVEZWxheSA9IFJFU1VNRV9ERUxBWV9GUkFNRVM7XG4gICAgICBzcGF3blRpbWVyID0gMDsgLy8gcmVzZXQgY2FkZW5jZVxuICAgICAgcmVzdW1lVW50aWxNcyA9IHR5cGVvZiBwZXJmb3JtYW5jZSAhPT0gJ3VuZGVmaW5lZCcgPyBwZXJmb3JtYW5jZS5ub3coKSArIDEyMCA6IDA7IC8vIH4xMjBtc1xuICAgIH1cbiAgICBpZGxlRnJhbWVzID0gMDtcbiAgfSBlbHNlIHtcbiAgICBpZGxlRnJhbWVzKys7XG4gIH1cblxuICAvLyBUaW1lLWJhc2VkIGd1YXJkIChtb3JlIHJvYnVzdCBhY3Jvc3MgZnJhbWUgcmF0ZXMpXG4gIGlmIChyZXN1bWVVbnRpbE1zICYmIHR5cGVvZiBwZXJmb3JtYW5jZSAhPT0gJ3VuZGVmaW5lZCcgJiYgcGVyZm9ybWFuY2Uubm93KCkgPCByZXN1bWVVbnRpbE1zKSB7XG4gICAgd2FzTW91c2VNb3ZpbmcgPSBpc01vdmluZztcbiAgICAvLyBETyBOT1QgdXBkYXRlIGxhc3RNb3VzZSBoZXJlOyBrZWVwIGRlbHRhIG5vbi16ZXJvIGFmdGVyIGRlbGF5XG4gICAgc3Bhd25UaW1lcisrOyAvLyBhZHZhbmNlIGNhZGVuY2UgZHVyaW5nIGRlbGF5IHNvIGZpcnN0IHNwYXduIGNhbiBoYXBwZW4gcmlnaHQgYWZ0ZXJcbiAgICByZXR1cm47XG4gIH0gZWxzZSB7XG4gICAgcmVzdW1lVW50aWxNcyA9IDA7XG4gIH1cblxuICAvLyBGYWxsYmFjayBmcmFtZS1iYXNlZCBndWFyZFxuICBpZiAocmVzdW1lRGVsYXkgPiAwKSB7XG4gICAgcmVzdW1lRGVsYXktLTtcbiAgICB3YXNNb3VzZU1vdmluZyA9IGlzTW92aW5nO1xuICAgIC8vIERPIE5PVCB1cGRhdGUgbGFzdE1vdXNlIGhlcmU7IGtlZXAgZGVsdGEgbm9uLXplcm8gYWZ0ZXIgZGVsYXlcbiAgICBzcGF3blRpbWVyKys7IC8vIGFkdmFuY2UgY2FkZW5jZSBkdXJpbmcgZnJhbWUtYmFzZWQgZGVsYXlcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBBZHZhbmNlIGNhZGVuY2VcbiAgc3Bhd25UaW1lcisrO1xuICBcbiAgLy8gQ29udGludW91cyBzcGF3bmluZyB3aGlsZSBtb3ZpbmdcbiAgaWYgKGlzTW92aW5nKSB7XG4gICAgaWYgKHNwYXduVGltZXIgPj0gY29uZmlnLnNwYXduSW50ZXJ2YWwpIHtcbiAgICAgIC8vIFNwYXduIGF3YXkgZnJvbSB0aGUgY3Vyc29yIHRvIGF2b2lkIGNvdmVyaW5nIGl0XG4gICAgICBjb25zdCBzcGF3bkRpc3RhbmNlID0gNzAgKyBNYXRoLnJhbmRvbSgpICogMzA7IC8vIDcwLTEwMHB4XG4gICAgICBjb25zdCBzcGF3bkFuZ2xlID0gTWF0aC5yYW5kb20oKSAqIE1hdGguUEkgKiAyO1xuICAgICAgY29uc3QgcmluZ1ggPSBtb3VzZVggKyBNYXRoLmNvcyhzcGF3bkFuZ2xlKSAqIHNwYXduRGlzdGFuY2U7XG4gICAgICBjb25zdCByaW5nWSA9IG1vdXNlWSArIE1hdGguc2luKHNwYXduQW5nbGUpICogc3Bhd25EaXN0YW5jZTtcblxuICAgICAgLy8gU3Bhd247IHJlcGxhY2Ugb2xkZXN0IGlmIGF0IGNhcGFjaXR5XG4gICAgICBpZiAocG9sYXJvaWRzLmxlbmd0aCA8IGNvbmZpZy5tYXhQb2xhcm9pZHMpIHtcbiAgICAgICAgcG9sYXJvaWRzLnB1c2goY3JlYXRlUG9sYXJvaWRFbGVtZW50KHJpbmdYLCByaW5nWSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUmVtb3ZlIG9sZGVzdCBwb2xhcm9pZCBhbmQgYWRkIG5ldyBvbmUgZm9yIGNvbnRpbnVvdXMgZmxvd1xuICAgICAgICBjb25zdCBvbGRlc3QgPSBwb2xhcm9pZHMuc2hpZnQoKTtcbiAgICAgICAgaWYgKG9sZGVzdCAmJiBjb250YWluZXIgJiYgb2xkZXN0LmVsZW1lbnQucGFyZW50Tm9kZSkge1xuICAgICAgICAgIGNvbnRhaW5lci5yZW1vdmVDaGlsZChvbGRlc3QuZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcG9sYXJvaWRzLnB1c2goY3JlYXRlUG9sYXJvaWRFbGVtZW50KHJpbmdYLCByaW5nWSkpO1xuICAgICAgfVxuICAgICAgc3Bhd25UaW1lciA9IDA7XG4gICAgfVxuICB9XG4gIFxuICBsYXN0TW91c2VYID0gbW91c2VYO1xuICBsYXN0TW91c2VZID0gbW91c2VZO1xuICB3YXNNb3VzZU1vdmluZyA9IGlzTW92aW5nO1xufVxuXG5mdW5jdGlvbiBhbmltYXRlKCkge1xuICB1cGRhdGVQb2xhcm9pZHMoKTtcbiAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpO1xufVxuXG4vLyBFdmVudCBoYW5kbGVyc1xuZnVuY3Rpb24gYXR0YWNoRXZlbnRMaXN0ZW5lcnMoKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuO1xuXG4gIGNvbnN0IG1vdXNlTW92ZUhhbmRsZXIgPSAoZTogTW91c2VFdmVudCkgPT4ge1xuICAgIG1vdXNlWCA9IGUuY2xpZW50WDtcbiAgICBtb3VzZVkgPSBlLmNsaWVudFk7XG4gIH07XG5cbiAgY29uc3QgbW91c2VFbnRlckhhbmRsZXIgPSAoZTogTW91c2VFdmVudCkgPT4ge1xuICAgIC8vIEluaXRpYWxpemUgbW91c2UgcG9zaXRpb24gd2hlbiBlbnRlcmluZyB0aGUgcGFnZVxuICAgIG1vdXNlWCA9IGUuY2xpZW50WDtcbiAgICBtb3VzZVkgPSBlLmNsaWVudFk7XG4gICAgbGFzdE1vdXNlWCA9IG1vdXNlWDtcbiAgICBsYXN0TW91c2VZID0gbW91c2VZO1xuICB9O1xuXG4gIGNvbnN0IHRvdWNoTW92ZUhhbmRsZXIgPSAoZTogVG91Y2hFdmVudCkgPT4ge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBpZiAoZS50b3VjaGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IHRvdWNoID0gZS50b3VjaGVzWzBdO1xuICAgICAgbW91c2VYID0gdG91Y2guY2xpZW50WDtcbiAgICAgIG1vdXNlWSA9IHRvdWNoLmNsaWVudFk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IHRvdWNoU3RhcnRIYW5kbGVyID0gKGU6IFRvdWNoRXZlbnQpID0+IHtcbiAgICBpZiAoZS50b3VjaGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IHRvdWNoID0gZS50b3VjaGVzWzBdO1xuICAgICAgbW91c2VYID0gdG91Y2guY2xpZW50WDtcbiAgICAgIG1vdXNlWSA9IHRvdWNoLmNsaWVudFk7XG4gICAgICBsYXN0TW91c2VYID0gbW91c2VYO1xuICAgICAgbGFzdE1vdXNlWSA9IG1vdXNlWTtcbiAgICB9XG4gIH07XG5cbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBtb3VzZU1vdmVIYW5kbGVyKTtcbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZW50ZXJcIiwgbW91c2VFbnRlckhhbmRsZXIpO1xuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIHRvdWNoTW92ZUhhbmRsZXIsIHsgcGFzc2l2ZTogZmFsc2UgfSk7XG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsIHRvdWNoU3RhcnRIYW5kbGVyLCB7IHBhc3NpdmU6IHRydWUgfSk7XG59XG5cbi8vIE1haW4gaW5pdGlhbGl6YXRpb24gZnVuY3Rpb25cbmV4cG9ydCBmdW5jdGlvbiBpbml0UG9sYXJvaWRDdXJzb3IoKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuO1xuICBcbiAgaWYgKHBvbGFyb2lkSW5pdGlhbGl6ZWQpIHtcbiAgICBjb25zb2xlLmxvZygnUG9sYXJvaWQgY3Vyc29yIGFscmVhZHkgaW5pdGlhbGl6ZWQnKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zb2xlLmxvZygnSW5pdGlhbGl6aW5nIHBvbGFyb2lkIGN1cnNvciBlZmZlY3QuLi4nKTtcblxuICAvLyBDcmVhdGUgY29udGFpbmVyIGZvciBwb2xhcm9pZHNcbiAgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGNvbnRhaW5lci5pZCA9ICdwb2xhcm9pZC1jb250YWluZXInO1xuICBjb250YWluZXIuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgdG9wOiAwO1xuICAgIGxlZnQ6IDA7XG4gICAgd2lkdGg6IDEwMHZ3O1xuICAgIGhlaWdodDogMTAwdmg7XG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gICAgei1pbmRleDogMTAwMDtcbiAgYDtcbiAgXG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcblxuICAvLyBJbml0aWFsaXplIG1vdXNlIHBvc2l0aW9uIHRvIGNlbnRlciwgYnV0IHdpbGwgYmUgdXBkYXRlZCBvbiBmaXJzdCBtb3VzZSBtb3ZlXG4gIG1vdXNlWCA9IHdpbmRvdy5pbm5lcldpZHRoIC8gMjtcbiAgbW91c2VZID0gd2luZG93LmlubmVySGVpZ2h0IC8gMjtcbiAgbGFzdE1vdXNlWCA9IG1vdXNlWDtcbiAgbGFzdE1vdXNlWSA9IG1vdXNlWTtcblxuICAvLyBHZXQgYWN0dWFsIG1vdXNlIHBvc2l0aW9uIGlmIGF2YWlsYWJsZVxuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCAoZSkgPT4ge1xuICAgIGlmIChtb3VzZVggPT09IHdpbmRvdy5pbm5lcldpZHRoIC8gMiAmJiBtb3VzZVkgPT09IHdpbmRvdy5pbm5lckhlaWdodCAvIDIpIHtcbiAgICAgIC8vIEZpcnN0IG1vdXNlIG1vdmUgLSBpbml0aWFsaXplIHByb3Blcmx5XG4gICAgICBtb3VzZVggPSBlLmNsaWVudFg7XG4gICAgICBtb3VzZVkgPSBlLmNsaWVudFk7XG4gICAgICBsYXN0TW91c2VYID0gbW91c2VYO1xuICAgICAgbGFzdE1vdXNlWSA9IG1vdXNlWTtcbiAgICB9XG4gIH0sIHsgb25jZTogdHJ1ZSB9KTtcblxuICAvLyBBdHRhY2ggZXZlbnQgbGlzdGVuZXJzXG4gIGF0dGFjaEV2ZW50TGlzdGVuZXJzKCk7XG4gIFxuICAvLyBTdGFydCBhbmltYXRpb24gbG9vcFxuICBhbmltYXRlKCk7XG5cbiAgcG9sYXJvaWRJbml0aWFsaXplZCA9IHRydWU7XG4gIGNvbnNvbGUubG9nKCdQb2xhcm9pZCBjdXJzb3IgZWZmZWN0IGluaXRpYWxpemVkIHN1Y2Nlc3NmdWxseSEnKTtcbn1cblxuLy8gQ2xlYW51cCBmdW5jdGlvblxuZXhwb3J0IGZ1bmN0aW9uIGNsZWFudXBQb2xhcm9pZEN1cnNvcigpIHtcbiAgaWYgKGNvbnRhaW5lciAmJiBjb250YWluZXIucGFyZW50Tm9kZSkge1xuICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoY29udGFpbmVyKTtcbiAgfVxuICBcbiAgcG9sYXJvaWRzLmZvckVhY2gocG9sYXJvaWQgPT4ge1xuICAgIGlmIChwb2xhcm9pZC5lbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgIHBvbGFyb2lkLmVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChwb2xhcm9pZC5lbGVtZW50KTtcbiAgICB9XG4gIH0pO1xuICBcbiAgcG9sYXJvaWRzID0gW107XG4gIGNvbnRhaW5lciA9IG51bGw7XG4gIHBvbGFyb2lkSW5pdGlhbGl6ZWQgPSBmYWxzZTtcbn1cbiJdLCJuYW1lcyI6WyJwb2xhcm9pZEluaXRpYWxpemVkIiwiY29udGFpbmVyIiwicG9sYXJvaWRzIiwibW91c2VYIiwibW91c2VZIiwibGFzdE1vdXNlWCIsImxhc3RNb3VzZVkiLCJzcGF3blRpbWVyIiwid2FzTW91c2VNb3ZpbmciLCJyZXN1bWVEZWxheSIsIlJFU1VNRV9ERUxBWV9GUkFNRVMiLCJyZXN1bWVVbnRpbE1zIiwiaWRsZUZyYW1lcyIsIklETEVfQVJNX0ZSQU1FUyIsInBob3RvTGlzdCIsImNvbmZpZyIsIm1heFBvbGFyb2lkcyIsInBvbGFyb2lkTGlmZSIsInNwYXduSW50ZXJ2YWwiLCJmYWRlT3V0RHVyYXRpb24iLCJtaW5Nb3ZlbWVudFRocmVzaG9sZCIsInBvbGFyb2lkU2l6ZSIsInBob3RvSW5kZXgiLCJnZXROZXh0UGhvdG8iLCJzcmMiLCJsZW5ndGgiLCJjcmVhdGVQb2xhcm9pZEVsZW1lbnQiLCJ4IiwieSIsImVsZW1lbnQiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJpbWFnZSIsImNsYXNzTmFtZSIsImlubmVySFRNTCIsInJvdGF0aW9uIiwiTWF0aCIsInJhbmRvbSIsInNjYWxlIiwic3R5bGUiLCJjc3NUZXh0IiwibGVmdCIsInRvcCIsInBvbGFyb2lkRWxlbWVudCIsIm9wYWNpdHkiLCJsaWZlIiwibWF4TGlmZSIsInZ4IiwidnkiLCJhcHBlbmRDaGlsZCIsInVwZGF0ZVBvbGFyb2lkcyIsImkiLCJwb2xhcm9pZCIsInRvU3RyaW5nIiwicGFyZW50Tm9kZSIsInJlbW92ZUNoaWxkIiwic3BsaWNlIiwiZHgiLCJkeSIsIm1vdmVtZW50Iiwic3FydCIsImlzTW92aW5nIiwicGVyZm9ybWFuY2UiLCJub3ciLCJzcGF3bkRpc3RhbmNlIiwic3Bhd25BbmdsZSIsIlBJIiwicmluZ1giLCJjb3MiLCJyaW5nWSIsInNpbiIsInB1c2giLCJvbGRlc3QiLCJzaGlmdCIsImFuaW1hdGUiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJhdHRhY2hFdmVudExpc3RlbmVycyIsIm1vdXNlTW92ZUhhbmRsZXIiLCJlIiwiY2xpZW50WCIsImNsaWVudFkiLCJtb3VzZUVudGVySGFuZGxlciIsInRvdWNoTW92ZUhhbmRsZXIiLCJwcmV2ZW50RGVmYXVsdCIsInRvdWNoZXMiLCJ0b3VjaCIsInRvdWNoU3RhcnRIYW5kbGVyIiwiYWRkRXZlbnRMaXN0ZW5lciIsInBhc3NpdmUiLCJpbml0UG9sYXJvaWRDdXJzb3IiLCJjb25zb2xlIiwibG9nIiwiaWQiLCJib2R5Iiwid2luZG93IiwiaW5uZXJXaWR0aCIsImlubmVySGVpZ2h0Iiwib25jZSIsImNsZWFudXBQb2xhcm9pZEN1cnNvciIsImZvckVhY2giXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/lib/polaroid-cursor.ts\n"));

/***/ })

}]);