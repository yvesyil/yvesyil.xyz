"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_app_lib_polaroid-cursor_ts"],{

/***/ "(app-pages-browser)/./app/lib/polaroid-cursor.ts":
/*!************************************!*\
  !*** ./app/lib/polaroid-cursor.ts ***!
  \************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cleanupPolaroidCursor: () => (/* binding */ cleanupPolaroidCursor),\n/* harmony export */   initPolaroidCursor: () => (/* binding */ initPolaroidCursor)\n/* harmony export */ });\n// Polaroid Cursor Effect\n// Creates polaroid photos that follow mouse movement\nlet polaroidInitialized = false;\nlet photosLoaded = false;\nlet container = null;\nlet polaroids = [];\nlet mouseX = 0;\nlet mouseY = 0;\nlet lastMouseX = 0;\nlet lastMouseY = 0;\nlet spawnTimer = 0; // Timer for consistent spawning\nlet wasMouseMoving = false;\nlet resumeDelay = 0; // frames to delay after movement resumes\nconst RESUME_DELAY_FRAMES = 5; // ~0.1s at 60fps\nlet resumeUntilMs = 0; // timestamp until which we delay spawning after resume\nlet idleFrames = 0; // frames not moving\nconst IDLE_ARM_FRAMES = 20; // require ~0.33s idle before arming resume delay\n// Tiny images for better performance\nconst photoList = [\n    '/photos/tiny/AngelHoldingChalice.jpg',\n    '/photos/tiny/AStreetInHaarlem.jpg',\n    '/photos/tiny/Autopark.jpg',\n    '/photos/tiny/CafeHetWapenVanBlo.jpg',\n    '/photos/tiny/Caritasbronden.jpg',\n    '/photos/tiny/CatLaying.jpg',\n    '/photos/tiny/CatWithLargeCollar.jpg',\n    '/photos/tiny/ChurchInTheDistance.jpg',\n    '/photos/tiny/Cows.jpg',\n    '/photos/tiny/CowsCurious.jpg',\n    '/photos/tiny/DeBurcht.jpg',\n    '/photos/tiny/FrederiksbergSlot.jpg',\n    '/photos/tiny/GrassPlane.jpg',\n    '/photos/tiny/Lake.jpg',\n    '/photos/tiny/Maan.jpg',\n    '/photos/tiny/Mermaid.jpg',\n    '/photos/tiny/Office.jpg',\n    '/photos/tiny/SAIL.jpg',\n    '/photos/tiny/SintBonifatiuskerk.jpg',\n    '/photos/tiny/Stairs.jpg',\n    '/photos/tiny/ZaanRiver.jpg'\n];\nasync function preloadPhotos(urls) {\n    const loaders = urls.map((src)=>new Promise((resolve)=>{\n            const img = new Image();\n            img.onload = ()=>resolve();\n            img.onerror = ()=>resolve(); // treat errors as resolved to avoid blocking\n            img.src = src;\n        }));\n    await Promise.all(loaders);\n}\nconst config = {\n    maxPolaroids: 20,\n    polaroidLife: 60,\n    spawnInterval: 8,\n    fadeOutDuration: 30,\n    minMovementThreshold: 1,\n    polaroidSize: 140\n};\nlet photoIndex = 0;\nfunction getNextPhoto() {\n    const src = photoList[photoIndex];\n    photoIndex = (photoIndex + 1) % photoList.length;\n    return src;\n}\nfunction createPolaroidElement(x, y) {\n    const element = document.createElement('div');\n    const image = getNextPhoto();\n    element.className = 'polaroid-photo';\n    element.innerHTML = '\\n    <div class=\"polaroid-inner\">\\n      <img src=\"'.concat(image, '\" alt=\"Random photo\" />\\n      <div class=\"polaroid-caption\"></div>\\n    </div>\\n  ');\n    // Random rotation and slight scale variation\n    const rotation = (Math.random() - 0.5) * 30; // -15 to 15 degrees\n    const scale = 0.8 + Math.random() * 0.4; // 0.8 to 1.2\n    element.style.cssText = \"\\n    position: fixed;\\n    pointer-events: none;\\n    z-index: 1000;\\n    transform: translate(-50%, -50%) rotate(\".concat(rotation, \"deg) scale(\").concat(scale, \");\\n    transition: none;\\n  \");\n    // Set initial position immediately so it doesn't flash at (0,0)\n    element.style.left = \"\".concat(x, \"px\");\n    element.style.top = \"\".concat(y, \"px\");\n    const polaroidElement = {\n        element,\n        x,\n        y,\n        rotation,\n        scale,\n        opacity: 1,\n        life: config.polaroidLife,\n        maxLife: config.polaroidLife,\n        vx: (Math.random() - 0.5) * 2,\n        vy: (Math.random() - 0.5) * 2,\n        image\n    };\n    if (container) {\n        container.appendChild(element);\n    }\n    return polaroidElement;\n}\nfunction updatePolaroids() {\n    // If images aren't ready, skip updates (prevents blank placeholders)\n    if (!photosLoaded) return;\n    // Update existing polaroids\n    for(let i = polaroids.length - 1; i >= 0; i--){\n        const polaroid = polaroids[i];\n        // Update position with slight drift\n        polaroid.x += polaroid.vx;\n        polaroid.y += polaroid.vy;\n        // Apply slight drag\n        polaroid.vx *= 0.98;\n        polaroid.vy *= 0.98;\n        // Update life\n        polaroid.life--;\n        // Calculate opacity based on remaining life\n        if (polaroid.life < config.fadeOutDuration) {\n            polaroid.opacity = polaroid.life / config.fadeOutDuration;\n        }\n        // Update element position and opacity\n        polaroid.element.style.left = \"\".concat(polaroid.x, \"px\");\n        polaroid.element.style.top = \"\".concat(polaroid.y, \"px\");\n        polaroid.element.style.opacity = polaroid.opacity.toString();\n        // Remove dead polaroids\n        if (polaroid.life <= 0) {\n            if (container && polaroid.element.parentNode) {\n                container.removeChild(polaroid.element);\n            }\n            polaroids.splice(i, 1);\n        }\n    }\n    // Movement metrics and gating\n    const dx = mouseX - lastMouseX;\n    const dy = mouseY - lastMouseY;\n    const movement = Math.sqrt(dx * dx + dy * dy);\n    const isMoving = movement > config.minMovementThreshold;\n    // Track idle vs moving frames to avoid re-arming delay on micro pauses\n    if (isMoving) {\n        // Only arm a delay if we were truly idle for a bit\n        if (!wasMouseMoving && idleFrames >= IDLE_ARM_FRAMES) {\n            resumeDelay = RESUME_DELAY_FRAMES;\n            spawnTimer = 0; // reset cadence\n            resumeUntilMs = typeof performance !== 'undefined' ? performance.now() + 120 : 0; // ~120ms\n        }\n        idleFrames = 0;\n    } else {\n        idleFrames++;\n    }\n    // Time-based guard (more robust across frame rates)\n    if (resumeUntilMs && typeof performance !== 'undefined' && performance.now() < resumeUntilMs) {\n        wasMouseMoving = isMoving;\n        // DO NOT update lastMouse here; keep delta non-zero after delay\n        spawnTimer++; // advance cadence during delay so first spawn can happen right after\n        return;\n    } else {\n        resumeUntilMs = 0;\n    }\n    // Fallback frame-based guard\n    if (resumeDelay > 0) {\n        resumeDelay--;\n        wasMouseMoving = isMoving;\n        // DO NOT update lastMouse here; keep delta non-zero after delay\n        spawnTimer++; // advance cadence during frame-based delay\n        return;\n    }\n    // Advance cadence\n    spawnTimer++;\n    // Continuous spawning while moving\n    if (isMoving) {\n        if (spawnTimer >= config.spawnInterval) {\n            // Spawn away from the cursor to avoid covering it\n            const spawnDistance = 70 + Math.random() * 30; // 70-100px\n            const spawnAngle = Math.random() * Math.PI * 2;\n            const ringX = mouseX + Math.cos(spawnAngle) * spawnDistance;\n            const ringY = mouseY + Math.sin(spawnAngle) * spawnDistance;\n            // Spawn; replace oldest if at capacity\n            if (polaroids.length < config.maxPolaroids) {\n                polaroids.push(createPolaroidElement(ringX, ringY));\n            } else {\n                // Remove oldest polaroid and add new one for continuous flow\n                const oldest = polaroids.shift();\n                if (oldest && container && oldest.element.parentNode) {\n                    container.removeChild(oldest.element);\n                }\n                polaroids.push(createPolaroidElement(ringX, ringY));\n            }\n            spawnTimer = 0;\n        }\n    }\n    lastMouseX = mouseX;\n    lastMouseY = mouseY;\n    wasMouseMoving = isMoving;\n}\nfunction animate() {\n    updatePolaroids();\n    requestAnimationFrame(animate);\n}\n// Event handlers\nfunction attachEventListeners() {\n    if (false) {}\n    const mouseMoveHandler = (e)=>{\n        mouseX = e.clientX;\n        mouseY = e.clientY;\n    };\n    const mouseEnterHandler = (e)=>{\n        // Initialize mouse position when entering the page\n        mouseX = e.clientX;\n        mouseY = e.clientY;\n        lastMouseX = mouseX;\n        lastMouseY = mouseY;\n    };\n    const touchMoveHandler = (e)=>{\n        e.preventDefault();\n        if (e.touches.length > 0) {\n            const touch = e.touches[0];\n            mouseX = touch.clientX;\n            mouseY = touch.clientY;\n        }\n    };\n    const touchStartHandler = (e)=>{\n        if (e.touches.length > 0) {\n            const touch = e.touches[0];\n            mouseX = touch.clientX;\n            mouseY = touch.clientY;\n            lastMouseX = mouseX;\n            lastMouseY = mouseY;\n        }\n    };\n    document.addEventListener(\"mousemove\", mouseMoveHandler);\n    document.addEventListener(\"mouseenter\", mouseEnterHandler);\n    document.addEventListener(\"touchmove\", touchMoveHandler, {\n        passive: false\n    });\n    document.addEventListener(\"touchstart\", touchStartHandler, {\n        passive: true\n    });\n}\n// Main initialization function\nasync function initPolaroidCursor() {\n    if (false) {}\n    if (polaroidInitialized) {\n        console.log('Polaroid cursor already initialized');\n        return;\n    }\n    console.log('Initializing polaroid cursor effect...');\n    // Create container for polaroids\n    container = document.createElement('div');\n    container.id = 'polaroid-container';\n    container.style.cssText = \"\\n    position: fixed;\\n    top: 0;\\n    left: 0;\\n    width: 100vw;\\n    height: 100vh;\\n    pointer-events: none;\\n    z-index: 1000;\\n  \";\n    document.body.appendChild(container);\n    // Initialize mouse position to center, but will be updated on first mouse move\n    mouseX = window.innerWidth / 2;\n    mouseY = window.innerHeight / 2;\n    lastMouseX = mouseX;\n    lastMouseY = mouseY;\n    // Get actual mouse position if available\n    document.addEventListener('mousemove', (e)=>{\n        if (mouseX === window.innerWidth / 2 && mouseY === window.innerHeight / 2) {\n            // First mouse move - initialize properly\n            mouseX = e.clientX;\n            mouseY = e.clientY;\n            lastMouseX = mouseX;\n            lastMouseY = mouseY;\n        }\n    }, {\n        once: true\n    });\n    // Attach event listeners immediately\n    attachEventListeners();\n    // Preload photos before starting the effect\n    try {\n        await preloadPhotos(photoList);\n        photosLoaded = true;\n    } catch (_) {\n        photosLoaded = true; // don't block in case of unexpected errors\n    }\n    // Start animation loop only after photos are loaded\n    animate();\n    polaroidInitialized = true;\n    console.log('Polaroid cursor effect initialized successfully!');\n}\n// Cleanup function\nfunction cleanupPolaroidCursor() {\n    if (container && container.parentNode) {\n        document.body.removeChild(container);\n    }\n    polaroids.forEach((polaroid)=>{\n        if (polaroid.element.parentNode) {\n            polaroid.element.parentNode.removeChild(polaroid.element);\n        }\n    });\n    polaroids = [];\n    container = null;\n    polaroidInitialized = false;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9saWIvcG9sYXJvaWQtY3Vyc29yLnRzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUEseUJBQXlCO0FBQ3pCLHFEQUFxRDtBQUVyRCxJQUFJQSxzQkFBc0I7QUFDMUIsSUFBSUMsZUFBZTtBQUNuQixJQUFJQyxZQUFtQztBQUN2QyxJQUFJQyxZQUErQixFQUFFO0FBQ3JDLElBQUlDLFNBQVM7QUFDYixJQUFJQyxTQUFTO0FBQ2IsSUFBSUMsYUFBYTtBQUNqQixJQUFJQyxhQUFhO0FBQ2pCLElBQUlDLGFBQWEsR0FBRyxnQ0FBZ0M7QUFDcEQsSUFBSUMsaUJBQWlCO0FBQ3JCLElBQUlDLGNBQWMsR0FBRyx5Q0FBeUM7QUFDOUQsTUFBTUMsc0JBQXNCLEdBQUcsaUJBQWlCO0FBQ2hELElBQUlDLGdCQUFnQixHQUFHLHVEQUF1RDtBQUM5RSxJQUFJQyxhQUFhLEdBQUcsb0JBQW9CO0FBQ3hDLE1BQU1DLGtCQUFrQixJQUFJLGlEQUFpRDtBQWdCN0UscUNBQXFDO0FBQ3JDLE1BQU1DLFlBQVk7SUFDaEI7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0NBQ0Q7QUFFRCxlQUFlQyxjQUFjQyxJQUFjO0lBQ3pDLE1BQU1DLFVBQVVELEtBQUtFLEdBQUcsQ0FBQyxDQUFDQyxNQUN4QixJQUFJQyxRQUFjLENBQUNDO1lBQ2pCLE1BQU1DLE1BQU0sSUFBSUM7WUFDaEJELElBQUlFLE1BQU0sR0FBRyxJQUFNSDtZQUNuQkMsSUFBSUcsT0FBTyxHQUFHLElBQU1KLFdBQVcsNkNBQTZDO1lBQzVFQyxJQUFJSCxHQUFHLEdBQUdBO1FBQ1o7SUFFRixNQUFNQyxRQUFRTSxHQUFHLENBQUNUO0FBQ3BCO0FBRUEsTUFBTVUsU0FBUztJQUNiQyxjQUFjO0lBQ2RDLGNBQWM7SUFDZEMsZUFBZTtJQUNmQyxpQkFBaUI7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WUFDYkcsYUFBYUY7UUFDZjtJQUNGLEdBQUc7UUFBRXdHLE1BQU07SUFBSztJQUVoQixxQ0FBcUM7SUFDckNyQjtJQUVBLDRDQUE0QztJQUM1QyxJQUFJO1FBQ0YsTUFBTXhFLGNBQWNEO1FBQ3BCZCxlQUFlO0lBQ2pCLEVBQUUsT0FBTzZHLEdBQUc7UUFDVjdHLGVBQWUsTUFBTSwyQ0FBMkM7SUFDbEU7SUFFQSxvREFBb0Q7SUFDcERxRjtJQUVBdEYsc0JBQXNCO0lBQ3RCc0csUUFBUUMsR0FBRyxDQUFDO0FBQ2Q7QUFFQSxtQkFBbUI7QUFDWixTQUFTUTtJQUNkLElBQUk3RyxhQUFhQSxVQUFVZ0UsVUFBVSxFQUFFO1FBQ3JDeEIsU0FBUytELElBQUksQ0FBQ3RDLFdBQVcsQ0FBQ2pFO0lBQzVCO0lBRUFDLFVBQVU2RyxPQUFPLENBQUNoRCxDQUFBQTtRQUNoQixJQUFJQSxTQUFTdkIsT0FBTyxDQUFDeUIsVUFBVSxFQUFFO1lBQy9CRixTQUFTdkIsT0FBTyxDQUFDeUIsVUFBVSxDQUFDQyxXQUFXLENBQUNILFNBQVN2QixPQUFPO1FBQzFEO0lBQ0Y7SUFFQXRDLFlBQVksRUFBRTtJQUNkRCxZQUFZO0lBQ1pGLHNCQUFzQjtBQUN4QiIsInNvdXJjZXMiOlsiL1VzZXJzL3l2ZXMvUmVwb3NpdG9yaWVzL3l2ZXN5aWwueHl6L2FwcC9saWIvcG9sYXJvaWQtY3Vyc29yLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFBvbGFyb2lkIEN1cnNvciBFZmZlY3Rcbi8vIENyZWF0ZXMgcG9sYXJvaWQgcGhvdG9zIHRoYXQgZm9sbG93IG1vdXNlIG1vdmVtZW50XG5cbmxldCBwb2xhcm9pZEluaXRpYWxpemVkID0gZmFsc2U7XG5sZXQgcGhvdG9zTG9hZGVkID0gZmFsc2U7XG5sZXQgY29udGFpbmVyOiBIVE1MRGl2RWxlbWVudCB8IG51bGwgPSBudWxsO1xubGV0IHBvbGFyb2lkczogUG9sYXJvaWRFbGVtZW50W10gPSBbXTtcbmxldCBtb3VzZVggPSAwO1xubGV0IG1vdXNlWSA9IDA7XG5sZXQgbGFzdE1vdXNlWCA9IDA7XG5sZXQgbGFzdE1vdXNlWSA9IDA7XG5sZXQgc3Bhd25UaW1lciA9IDA7IC8vIFRpbWVyIGZvciBjb25zaXN0ZW50IHNwYXduaW5nXG5sZXQgd2FzTW91c2VNb3ZpbmcgPSBmYWxzZTtcbmxldCByZXN1bWVEZWxheSA9IDA7IC8vIGZyYW1lcyB0byBkZWxheSBhZnRlciBtb3ZlbWVudCByZXN1bWVzXG5jb25zdCBSRVNVTUVfREVMQVlfRlJBTUVTID0gNTsgLy8gfjAuMXMgYXQgNjBmcHNcbmxldCByZXN1bWVVbnRpbE1zID0gMDsgLy8gdGltZXN0YW1wIHVudGlsIHdoaWNoIHdlIGRlbGF5IHNwYXduaW5nIGFmdGVyIHJlc3VtZVxubGV0IGlkbGVGcmFtZXMgPSAwOyAvLyBmcmFtZXMgbm90IG1vdmluZ1xuY29uc3QgSURMRV9BUk1fRlJBTUVTID0gMjA7IC8vIHJlcXVpcmUgfjAuMzNzIGlkbGUgYmVmb3JlIGFybWluZyByZXN1bWUgZGVsYXlcblxuaW50ZXJmYWNlIFBvbGFyb2lkRWxlbWVudCB7XG4gIGVsZW1lbnQ6IEhUTUxEaXZFbGVtZW50O1xuICB4OiBudW1iZXI7XG4gIHk6IG51bWJlcjtcbiAgcm90YXRpb246IG51bWJlcjtcbiAgc2NhbGU6IG51bWJlcjtcbiAgb3BhY2l0eTogbnVtYmVyO1xuICBsaWZlOiBudW1iZXI7XG4gIG1heExpZmU6IG51bWJlcjtcbiAgdng6IG51bWJlcjtcbiAgdnk6IG51bWJlcjtcbiAgaW1hZ2U6IHN0cmluZztcbn1cblxuLy8gVGlueSBpbWFnZXMgZm9yIGJldHRlciBwZXJmb3JtYW5jZVxuY29uc3QgcGhvdG9MaXN0ID0gW1xuICAnL3Bob3Rvcy90aW55L0FuZ2VsSG9sZGluZ0NoYWxpY2UuanBnJyxcbiAgJy9waG90b3MvdGlueS9BU3RyZWV0SW5IYWFybGVtLmpwZycsXG4gICcvcGhvdG9zL3RpbnkvQXV0b3BhcmsuanBnJyxcbiAgJy9waG90b3MvdGlueS9DYWZlSGV0V2FwZW5WYW5CbG8uanBnJyxcbiAgJy9waG90b3MvdGlueS9DYXJpdGFzYnJvbmRlbi5qcGcnLFxuICAnL3Bob3Rvcy90aW55L0NhdExheWluZy5qcGcnLFxuICAnL3Bob3Rvcy90aW55L0NhdFdpdGhMYXJnZUNvbGxhci5qcGcnLFxuICAnL3Bob3Rvcy90aW55L0NodXJjaEluVGhlRGlzdGFuY2UuanBnJyxcbiAgJy9waG90b3MvdGlueS9Db3dzLmpwZycsXG4gICcvcGhvdG9zL3RpbnkvQ293c0N1cmlvdXMuanBnJyxcbiAgJy9waG90b3MvdGlueS9EZUJ1cmNodC5qcGcnLFxuICAnL3Bob3Rvcy90aW55L0ZyZWRlcmlrc2JlcmdTbG90LmpwZycsXG4gICcvcGhvdG9zL3RpbnkvR3Jhc3NQbGFuZS5qcGcnLFxuICAnL3Bob3Rvcy90aW55L0xha2UuanBnJyxcbiAgJy9waG90b3MvdGlueS9NYWFuLmpwZycsXG4gICcvcGhvdG9zL3RpbnkvTWVybWFpZC5qcGcnLFxuICAnL3Bob3Rvcy90aW55L09mZmljZS5qcGcnLFxuICAnL3Bob3Rvcy90aW55L1NBSUwuanBnJyxcbiAgJy9waG90b3MvdGlueS9TaW50Qm9uaWZhdGl1c2tlcmsuanBnJyxcbiAgJy9waG90b3MvdGlueS9TdGFpcnMuanBnJyxcbiAgJy9waG90b3MvdGlueS9aYWFuUml2ZXIuanBnJyxcbl07XG5cbmFzeW5jIGZ1bmN0aW9uIHByZWxvYWRQaG90b3ModXJsczogc3RyaW5nW10pOiBQcm9taXNlPHZvaWQ+IHtcbiAgY29uc3QgbG9hZGVycyA9IHVybHMubWFwKChzcmMpID0+XG4gICAgbmV3IFByb21pc2U8dm9pZD4oKHJlc29sdmUpID0+IHtcbiAgICAgIGNvbnN0IGltZyA9IG5ldyBJbWFnZSgpO1xuICAgICAgaW1nLm9ubG9hZCA9ICgpID0+IHJlc29sdmUoKTtcbiAgICAgIGltZy5vbmVycm9yID0gKCkgPT4gcmVzb2x2ZSgpOyAvLyB0cmVhdCBlcnJvcnMgYXMgcmVzb2x2ZWQgdG8gYXZvaWQgYmxvY2tpbmdcbiAgICAgIGltZy5zcmMgPSBzcmM7XG4gICAgfSlcbiAgKTtcbiAgYXdhaXQgUHJvbWlzZS5hbGwobG9hZGVycyk7XG59XG5cbmNvbnN0IGNvbmZpZyA9IHtcbiAgbWF4UG9sYXJvaWRzOiAyMCwgLy8gSGlnaGVyIGxpbWl0IHRvIHByZXZlbnQgcGF1c2VzXG4gIHBvbGFyb2lkTGlmZTogNjAsIC8vIFNob3J0ZXIgbGlmZSBzbyBwaG90b3MgY3ljbGUgZmFzdGVyXG4gIHNwYXduSW50ZXJ2YWw6IDgsIC8vIFNwYXduIGV2ZXJ5IDQgZnJhbWVzICgxNSB0aW1lcyBwZXIgc2Vjb25kKVxuICBmYWRlT3V0RHVyYXRpb246IDMwLCAvLyBGYXN0ZXIgZmFkZSBmb3IgcXVpY2tlciB0dXJub3ZlclxuICBtaW5Nb3ZlbWVudFRocmVzaG9sZDogMSwgLy8gTG93ZXIgdGhyZXNob2xkXG4gIHBvbGFyb2lkU2l6ZTogMTQwLCAvLyBCaWdnZXIgcGhvdG9zXG59O1xuXG5sZXQgcGhvdG9JbmRleCA9IDA7XG5mdW5jdGlvbiBnZXROZXh0UGhvdG8oKTogc3RyaW5nIHtcbiAgY29uc3Qgc3JjID0gcGhvdG9MaXN0W3Bob3RvSW5kZXhdO1xuICBwaG90b0luZGV4ID0gKHBob3RvSW5kZXggKyAxKSAlIHBob3RvTGlzdC5sZW5ndGg7XG4gIHJldHVybiBzcmM7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVBvbGFyb2lkRWxlbWVudCh4OiBudW1iZXIsIHk6IG51bWJlcik6IFBvbGFyb2lkRWxlbWVudCB7XG4gIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgY29uc3QgaW1hZ2UgPSBnZXROZXh0UGhvdG8oKTtcbiAgXG4gIGVsZW1lbnQuY2xhc3NOYW1lID0gJ3BvbGFyb2lkLXBob3RvJztcbiAgZWxlbWVudC5pbm5lckhUTUwgPSBgXG4gICAgPGRpdiBjbGFzcz1cInBvbGFyb2lkLWlubmVyXCI+XG4gICAgICA8aW1nIHNyYz1cIiR7aW1hZ2V9XCIgYWx0PVwiUmFuZG9tIHBob3RvXCIgLz5cbiAgICAgIDxkaXYgY2xhc3M9XCJwb2xhcm9pZC1jYXB0aW9uXCI+PC9kaXY+XG4gICAgPC9kaXY+XG4gIGA7XG4gIFxuICAvLyBSYW5kb20gcm90YXRpb24gYW5kIHNsaWdodCBzY2FsZSB2YXJpYXRpb25cbiAgY29uc3Qgcm90YXRpb24gPSAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAzMDsgLy8gLTE1IHRvIDE1IGRlZ3JlZXNcbiAgY29uc3Qgc2NhbGUgPSAwLjggKyBNYXRoLnJhbmRvbSgpICogMC40OyAvLyAwLjggdG8gMS4yXG4gIFxuICBlbGVtZW50LnN0eWxlLmNzc1RleHQgPSBgXG4gICAgcG9zaXRpb246IGZpeGVkO1xuICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICAgIHotaW5kZXg6IDEwMDA7XG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTUwJSwgLTUwJSkgcm90YXRlKCR7cm90YXRpb259ZGVnKSBzY2FsZSgke3NjYWxlfSk7XG4gICAgdHJhbnNpdGlvbjogbm9uZTtcbiAgYDtcbiAgLy8gU2V0IGluaXRpYWwgcG9zaXRpb24gaW1tZWRpYXRlbHkgc28gaXQgZG9lc24ndCBmbGFzaCBhdCAoMCwwKVxuICBlbGVtZW50LnN0eWxlLmxlZnQgPSBgJHt4fXB4YDtcbiAgZWxlbWVudC5zdHlsZS50b3AgPSBgJHt5fXB4YDtcbiAgXG4gIGNvbnN0IHBvbGFyb2lkRWxlbWVudDogUG9sYXJvaWRFbGVtZW50ID0ge1xuICAgIGVsZW1lbnQsXG4gICAgeCxcbiAgICB5LFxuICAgIHJvdGF0aW9uLFxuICAgIHNjYWxlLFxuICAgIG9wYWNpdHk6IDEsXG4gICAgbGlmZTogY29uZmlnLnBvbGFyb2lkTGlmZSxcbiAgICBtYXhMaWZlOiBjb25maWcucG9sYXJvaWRMaWZlLFxuICAgIHZ4OiAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAyLFxuICAgIHZ5OiAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAyLFxuICAgIGltYWdlXG4gIH07XG4gIFxuICBpZiAoY29udGFpbmVyKSB7XG4gICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICB9XG4gIFxuICByZXR1cm4gcG9sYXJvaWRFbGVtZW50O1xufVxuXG5mdW5jdGlvbiB1cGRhdGVQb2xhcm9pZHMoKSB7XG4gIC8vIElmIGltYWdlcyBhcmVuJ3QgcmVhZHksIHNraXAgdXBkYXRlcyAocHJldmVudHMgYmxhbmsgcGxhY2Vob2xkZXJzKVxuICBpZiAoIXBob3Rvc0xvYWRlZCkgcmV0dXJuO1xuICAvLyBVcGRhdGUgZXhpc3RpbmcgcG9sYXJvaWRzXG4gIGZvciAobGV0IGkgPSBwb2xhcm9pZHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBjb25zdCBwb2xhcm9pZCA9IHBvbGFyb2lkc1tpXTtcbiAgICBcbiAgICAvLyBVcGRhdGUgcG9zaXRpb24gd2l0aCBzbGlnaHQgZHJpZnRcbiAgICBwb2xhcm9pZC54ICs9IHBvbGFyb2lkLnZ4O1xuICAgIHBvbGFyb2lkLnkgKz0gcG9sYXJvaWQudnk7XG4gICAgXG4gICAgLy8gQXBwbHkgc2xpZ2h0IGRyYWdcbiAgICBwb2xhcm9pZC52eCAqPSAwLjk4O1xuICAgIHBvbGFyb2lkLnZ5ICo9IDAuOTg7XG4gICAgXG4gICAgLy8gVXBkYXRlIGxpZmVcbiAgICBwb2xhcm9pZC5saWZlLS07XG4gICAgXG4gICAgLy8gQ2FsY3VsYXRlIG9wYWNpdHkgYmFzZWQgb24gcmVtYWluaW5nIGxpZmVcbiAgICBpZiAocG9sYXJvaWQubGlmZSA8IGNvbmZpZy5mYWRlT3V0RHVyYXRpb24pIHtcbiAgICAgIHBvbGFyb2lkLm9wYWNpdHkgPSBwb2xhcm9pZC5saWZlIC8gY29uZmlnLmZhZGVPdXREdXJhdGlvbjtcbiAgICB9XG4gICAgXG4gICAgLy8gVXBkYXRlIGVsZW1lbnQgcG9zaXRpb24gYW5kIG9wYWNpdHlcbiAgICBwb2xhcm9pZC5lbGVtZW50LnN0eWxlLmxlZnQgPSBgJHtwb2xhcm9pZC54fXB4YDtcbiAgICBwb2xhcm9pZC5lbGVtZW50LnN0eWxlLnRvcCA9IGAke3BvbGFyb2lkLnl9cHhgO1xuICAgIHBvbGFyb2lkLmVsZW1lbnQuc3R5bGUub3BhY2l0eSA9IHBvbGFyb2lkLm9wYWNpdHkudG9TdHJpbmcoKTtcbiAgICBcbiAgICAvLyBSZW1vdmUgZGVhZCBwb2xhcm9pZHNcbiAgICBpZiAocG9sYXJvaWQubGlmZSA8PSAwKSB7XG4gICAgICBpZiAoY29udGFpbmVyICYmIHBvbGFyb2lkLmVsZW1lbnQucGFyZW50Tm9kZSkge1xuICAgICAgICBjb250YWluZXIucmVtb3ZlQ2hpbGQocG9sYXJvaWQuZWxlbWVudCk7XG4gICAgICB9XG4gICAgICBwb2xhcm9pZHMuc3BsaWNlKGksIDEpO1xuICAgIH1cbiAgfVxuICBcbiAgLy8gTW92ZW1lbnQgbWV0cmljcyBhbmQgZ2F0aW5nXG4gIGNvbnN0IGR4ID0gbW91c2VYIC0gbGFzdE1vdXNlWDtcbiAgY29uc3QgZHkgPSBtb3VzZVkgLSBsYXN0TW91c2VZO1xuICBjb25zdCBtb3ZlbWVudCA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gIGNvbnN0IGlzTW92aW5nID0gbW92ZW1lbnQgPiBjb25maWcubWluTW92ZW1lbnRUaHJlc2hvbGQ7XG5cbiAgLy8gVHJhY2sgaWRsZSB2cyBtb3ZpbmcgZnJhbWVzIHRvIGF2b2lkIHJlLWFybWluZyBkZWxheSBvbiBtaWNybyBwYXVzZXNcbiAgaWYgKGlzTW92aW5nKSB7XG4gICAgLy8gT25seSBhcm0gYSBkZWxheSBpZiB3ZSB3ZXJlIHRydWx5IGlkbGUgZm9yIGEgYml0XG4gICAgaWYgKCF3YXNNb3VzZU1vdmluZyAmJiBpZGxlRnJhbWVzID49IElETEVfQVJNX0ZSQU1FUykge1xuICAgICAgcmVzdW1lRGVsYXkgPSBSRVNVTUVfREVMQVlfRlJBTUVTO1xuICAgICAgc3Bhd25UaW1lciA9IDA7IC8vIHJlc2V0IGNhZGVuY2VcbiAgICAgIHJlc3VtZVVudGlsTXMgPSB0eXBlb2YgcGVyZm9ybWFuY2UgIT09ICd1bmRlZmluZWQnID8gcGVyZm9ybWFuY2Uubm93KCkgKyAxMjAgOiAwOyAvLyB+MTIwbXNcbiAgICB9XG4gICAgaWRsZUZyYW1lcyA9IDA7XG4gIH0gZWxzZSB7XG4gICAgaWRsZUZyYW1lcysrO1xuICB9XG5cbiAgLy8gVGltZS1iYXNlZCBndWFyZCAobW9yZSByb2J1c3QgYWNyb3NzIGZyYW1lIHJhdGVzKVxuICBpZiAocmVzdW1lVW50aWxNcyAmJiB0eXBlb2YgcGVyZm9ybWFuY2UgIT09ICd1bmRlZmluZWQnICYmIHBlcmZvcm1hbmNlLm5vdygpIDwgcmVzdW1lVW50aWxNcykge1xuICAgIHdhc01vdXNlTW92aW5nID0gaXNNb3Zpbmc7XG4gICAgLy8gRE8gTk9UIHVwZGF0ZSBsYXN0TW91c2UgaGVyZTsga2VlcCBkZWx0YSBub24temVybyBhZnRlciBkZWxheVxuICAgIHNwYXduVGltZXIrKzsgLy8gYWR2YW5jZSBjYWRlbmNlIGR1cmluZyBkZWxheSBzbyBmaXJzdCBzcGF3biBjYW4gaGFwcGVuIHJpZ2h0IGFmdGVyXG4gICAgcmV0dXJuO1xuICB9IGVsc2Uge1xuICAgIHJlc3VtZVVudGlsTXMgPSAwO1xuICB9XG5cbiAgLy8gRmFsbGJhY2sgZnJhbWUtYmFzZWQgZ3VhcmRcbiAgaWYgKHJlc3VtZURlbGF5ID4gMCkge1xuICAgIHJlc3VtZURlbGF5LS07XG4gICAgd2FzTW91c2VNb3ZpbmcgPSBpc01vdmluZztcbiAgICAvLyBETyBOT1QgdXBkYXRlIGxhc3RNb3VzZSBoZXJlOyBrZWVwIGRlbHRhIG5vbi16ZXJvIGFmdGVyIGRlbGF5XG4gICAgc3Bhd25UaW1lcisrOyAvLyBhZHZhbmNlIGNhZGVuY2UgZHVyaW5nIGZyYW1lLWJhc2VkIGRlbGF5XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gQWR2YW5jZSBjYWRlbmNlXG4gIHNwYXduVGltZXIrKztcbiAgXG4gIC8vIENvbnRpbnVvdXMgc3Bhd25pbmcgd2hpbGUgbW92aW5nXG4gIGlmIChpc01vdmluZykge1xuICAgIGlmIChzcGF3blRpbWVyID49IGNvbmZpZy5zcGF3bkludGVydmFsKSB7XG4gICAgICAvLyBTcGF3biBhd2F5IGZyb20gdGhlIGN1cnNvciB0byBhdm9pZCBjb3ZlcmluZyBpdFxuICAgICAgY29uc3Qgc3Bhd25EaXN0YW5jZSA9IDcwICsgTWF0aC5yYW5kb20oKSAqIDMwOyAvLyA3MC0xMDBweFxuICAgICAgY29uc3Qgc3Bhd25BbmdsZSA9IE1hdGgucmFuZG9tKCkgKiBNYXRoLlBJICogMjtcbiAgICAgIGNvbnN0IHJpbmdYID0gbW91c2VYICsgTWF0aC5jb3Moc3Bhd25BbmdsZSkgKiBzcGF3bkRpc3RhbmNlO1xuICAgICAgY29uc3QgcmluZ1kgPSBtb3VzZVkgKyBNYXRoLnNpbihzcGF3bkFuZ2xlKSAqIHNwYXduRGlzdGFuY2U7XG5cbiAgICAgIC8vIFNwYXduOyByZXBsYWNlIG9sZGVzdCBpZiBhdCBjYXBhY2l0eVxuICAgICAgaWYgKHBvbGFyb2lkcy5sZW5ndGggPCBjb25maWcubWF4UG9sYXJvaWRzKSB7XG4gICAgICAgIHBvbGFyb2lkcy5wdXNoKGNyZWF0ZVBvbGFyb2lkRWxlbWVudChyaW5nWCwgcmluZ1kpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFJlbW92ZSBvbGRlc3QgcG9sYXJvaWQgYW5kIGFkZCBuZXcgb25lIGZvciBjb250aW51b3VzIGZsb3dcbiAgICAgICAgY29uc3Qgb2xkZXN0ID0gcG9sYXJvaWRzLnNoaWZ0KCk7XG4gICAgICAgIGlmIChvbGRlc3QgJiYgY29udGFpbmVyICYmIG9sZGVzdC5lbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICBjb250YWluZXIucmVtb3ZlQ2hpbGQob2xkZXN0LmVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHBvbGFyb2lkcy5wdXNoKGNyZWF0ZVBvbGFyb2lkRWxlbWVudChyaW5nWCwgcmluZ1kpKTtcbiAgICAgIH1cbiAgICAgIHNwYXduVGltZXIgPSAwO1xuICAgIH1cbiAgfVxuICBcbiAgbGFzdE1vdXNlWCA9IG1vdXNlWDtcbiAgbGFzdE1vdXNlWSA9IG1vdXNlWTtcbiAgd2FzTW91c2VNb3ZpbmcgPSBpc01vdmluZztcbn1cblxuZnVuY3Rpb24gYW5pbWF0ZSgpIHtcbiAgdXBkYXRlUG9sYXJvaWRzKCk7XG4gIHJlcXVlc3RBbmltYXRpb25GcmFtZShhbmltYXRlKTtcbn1cblxuLy8gRXZlbnQgaGFuZGxlcnNcbmZ1bmN0aW9uIGF0dGFjaEV2ZW50TGlzdGVuZXJzKCkge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybjtcblxuICBjb25zdCBtb3VzZU1vdmVIYW5kbGVyID0gKGU6IE1vdXNlRXZlbnQpID0+IHtcbiAgICBtb3VzZVggPSBlLmNsaWVudFg7XG4gICAgbW91c2VZID0gZS5jbGllbnRZO1xuICB9O1xuXG4gIGNvbnN0IG1vdXNlRW50ZXJIYW5kbGVyID0gKGU6IE1vdXNlRXZlbnQpID0+IHtcbiAgICAvLyBJbml0aWFsaXplIG1vdXNlIHBvc2l0aW9uIHdoZW4gZW50ZXJpbmcgdGhlIHBhZ2VcbiAgICBtb3VzZVggPSBlLmNsaWVudFg7XG4gICAgbW91c2VZID0gZS5jbGllbnRZO1xuICAgIGxhc3RNb3VzZVggPSBtb3VzZVg7XG4gICAgbGFzdE1vdXNlWSA9IG1vdXNlWTtcbiAgfTtcblxuICBjb25zdCB0b3VjaE1vdmVIYW5kbGVyID0gKGU6IFRvdWNoRXZlbnQpID0+IHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgaWYgKGUudG91Y2hlcy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCB0b3VjaCA9IGUudG91Y2hlc1swXTtcbiAgICAgIG1vdXNlWCA9IHRvdWNoLmNsaWVudFg7XG4gICAgICBtb3VzZVkgPSB0b3VjaC5jbGllbnRZO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCB0b3VjaFN0YXJ0SGFuZGxlciA9IChlOiBUb3VjaEV2ZW50KSA9PiB7XG4gICAgaWYgKGUudG91Y2hlcy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCB0b3VjaCA9IGUudG91Y2hlc1swXTtcbiAgICAgIG1vdXNlWCA9IHRvdWNoLmNsaWVudFg7XG4gICAgICBtb3VzZVkgPSB0b3VjaC5jbGllbnRZO1xuICAgICAgbGFzdE1vdXNlWCA9IG1vdXNlWDtcbiAgICAgIGxhc3RNb3VzZVkgPSBtb3VzZVk7XG4gICAgfVxuICB9O1xuXG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgbW91c2VNb3ZlSGFuZGxlcik7XG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWVudGVyXCIsIG1vdXNlRW50ZXJIYW5kbGVyKTtcbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCB0b3VjaE1vdmVIYW5kbGVyLCB7IHBhc3NpdmU6IGZhbHNlIH0pO1xuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCB0b3VjaFN0YXJ0SGFuZGxlciwgeyBwYXNzaXZlOiB0cnVlIH0pO1xufVxuXG4vLyBNYWluIGluaXRpYWxpemF0aW9uIGZ1bmN0aW9uXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaW5pdFBvbGFyb2lkQ3Vyc29yKCkge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybjtcbiAgXG4gIGlmIChwb2xhcm9pZEluaXRpYWxpemVkKSB7XG4gICAgY29uc29sZS5sb2coJ1BvbGFyb2lkIGN1cnNvciBhbHJlYWR5IGluaXRpYWxpemVkJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc29sZS5sb2coJ0luaXRpYWxpemluZyBwb2xhcm9pZCBjdXJzb3IgZWZmZWN0Li4uJyk7XG5cbiAgLy8gQ3JlYXRlIGNvbnRhaW5lciBmb3IgcG9sYXJvaWRzXG4gIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBjb250YWluZXIuaWQgPSAncG9sYXJvaWQtY29udGFpbmVyJztcbiAgY29udGFpbmVyLnN0eWxlLmNzc1RleHQgPSBgXG4gICAgcG9zaXRpb246IGZpeGVkO1xuICAgIHRvcDogMDtcbiAgICBsZWZ0OiAwO1xuICAgIHdpZHRoOiAxMDB2dztcbiAgICBoZWlnaHQ6IDEwMHZoO1xuICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICAgIHotaW5kZXg6IDEwMDA7XG4gIGA7XG4gIFxuICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XG5cbiAgLy8gSW5pdGlhbGl6ZSBtb3VzZSBwb3NpdGlvbiB0byBjZW50ZXIsIGJ1dCB3aWxsIGJlIHVwZGF0ZWQgb24gZmlyc3QgbW91c2UgbW92ZVxuICBtb3VzZVggPSB3aW5kb3cuaW5uZXJXaWR0aCAvIDI7XG4gIG1vdXNlWSA9IHdpbmRvdy5pbm5lckhlaWdodCAvIDI7XG4gIGxhc3RNb3VzZVggPSBtb3VzZVg7XG4gIGxhc3RNb3VzZVkgPSBtb3VzZVk7XG5cbiAgLy8gR2V0IGFjdHVhbCBtb3VzZSBwb3NpdGlvbiBpZiBhdmFpbGFibGVcbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgKGUpID0+IHtcbiAgICBpZiAobW91c2VYID09PSB3aW5kb3cuaW5uZXJXaWR0aCAvIDIgJiYgbW91c2VZID09PSB3aW5kb3cuaW5uZXJIZWlnaHQgLyAyKSB7XG4gICAgICAvLyBGaXJzdCBtb3VzZSBtb3ZlIC0gaW5pdGlhbGl6ZSBwcm9wZXJseVxuICAgICAgbW91c2VYID0gZS5jbGllbnRYO1xuICAgICAgbW91c2VZID0gZS5jbGllbnRZO1xuICAgICAgbGFzdE1vdXNlWCA9IG1vdXNlWDtcbiAgICAgIGxhc3RNb3VzZVkgPSBtb3VzZVk7XG4gICAgfVxuICB9LCB7IG9uY2U6IHRydWUgfSk7XG5cbiAgLy8gQXR0YWNoIGV2ZW50IGxpc3RlbmVycyBpbW1lZGlhdGVseVxuICBhdHRhY2hFdmVudExpc3RlbmVycygpO1xuXG4gIC8vIFByZWxvYWQgcGhvdG9zIGJlZm9yZSBzdGFydGluZyB0aGUgZWZmZWN0XG4gIHRyeSB7XG4gICAgYXdhaXQgcHJlbG9hZFBob3RvcyhwaG90b0xpc3QpO1xuICAgIHBob3Rvc0xvYWRlZCA9IHRydWU7XG4gIH0gY2F0Y2ggKF8pIHtcbiAgICBwaG90b3NMb2FkZWQgPSB0cnVlOyAvLyBkb24ndCBibG9jayBpbiBjYXNlIG9mIHVuZXhwZWN0ZWQgZXJyb3JzXG4gIH1cblxuICAvLyBTdGFydCBhbmltYXRpb24gbG9vcCBvbmx5IGFmdGVyIHBob3RvcyBhcmUgbG9hZGVkXG4gIGFuaW1hdGUoKTtcblxuICBwb2xhcm9pZEluaXRpYWxpemVkID0gdHJ1ZTtcbiAgY29uc29sZS5sb2coJ1BvbGFyb2lkIGN1cnNvciBlZmZlY3QgaW5pdGlhbGl6ZWQgc3VjY2Vzc2Z1bGx5IScpO1xufVxuXG4vLyBDbGVhbnVwIGZ1bmN0aW9uXG5leHBvcnQgZnVuY3Rpb24gY2xlYW51cFBvbGFyb2lkQ3Vyc29yKCkge1xuICBpZiAoY29udGFpbmVyICYmIGNvbnRhaW5lci5wYXJlbnROb2RlKSB7XG4gICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChjb250YWluZXIpO1xuICB9XG4gIFxuICBwb2xhcm9pZHMuZm9yRWFjaChwb2xhcm9pZCA9PiB7XG4gICAgaWYgKHBvbGFyb2lkLmVsZW1lbnQucGFyZW50Tm9kZSkge1xuICAgICAgcG9sYXJvaWQuZWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHBvbGFyb2lkLmVsZW1lbnQpO1xuICAgIH1cbiAgfSk7XG4gIFxuICBwb2xhcm9pZHMgPSBbXTtcbiAgY29udGFpbmVyID0gbnVsbDtcbiAgcG9sYXJvaWRJbml0aWFsaXplZCA9IGZhbHNlO1xufVxuIl0sIm5hbWVzIjpbInBvbGFyb2lkSW5pdGlhbGl6ZWQiLCJwaG90b3NMb2FkZWQiLCJjb250YWluZXIiLCJwb2xhcm9pZHMiLCJtb3VzZVgiLCJtb3VzZVkiLCJsYXN0TW91c2VYIiwibGFzdE1vdXNlWSIsInNwYXduVGltZXIiLCJ3YXNNb3VzZU1vdmluZyIsInJlc3VtZURlbGF5IiwiUkVTVU1FX0RFTEFZX0ZSQU1FUyIsInJlc3VtZVVudGlsTXMiLCJpZGxlRnJhbWVzIiwiSURMRV9BUk1fRlJBTUVTIiwicGhvdG9MaXN0IiwicHJlbG9hZFBob3RvcyIsInVybHMiLCJsb2FkZXJzIiwibWFwIiwic3JjIiwiUHJvbWlzZSIsInJlc29sdmUiLCJpbWciLCJJbWFnZSIsIm9ubG9hZCIsIm9uZXJyb3IiLCJhbGwiLCJjb25maWciLCJtYXhQb2xhcm9pZHMiLCJwb2xhcm9pZExpZmUiLCJzcGF3bkludGVydmFsIiwiZmFkZU91dER1cmF0aW9uIiwibWluTW92ZW1lbnRUaHJlc2hvbGQiLCJwb2xhcm9pZFNpemUiLCJwaG90b0luZGV4IiwiZ2V0TmV4dFBob3RvIiwibGVuZ3RoIiwiY3JlYXRlUG9sYXJvaWRFbGVtZW50IiwieCIsInkiLCJlbGVtZW50IiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiaW1hZ2UiLCJjbGFzc05hbWUiLCJpbm5lckhUTUwiLCJyb3RhdGlvbiIsIk1hdGgiLCJyYW5kb20iLCJzY2FsZSIsInN0eWxlIiwiY3NzVGV4dCIsImxlZnQiLCJ0b3AiLCJwb2xhcm9pZEVsZW1lbnQiLCJvcGFjaXR5IiwibGlmZSIsIm1heExpZmUiLCJ2eCIsInZ5IiwiYXBwZW5kQ2hpbGQiLCJ1cGRhdGVQb2xhcm9pZHMiLCJpIiwicG9sYXJvaWQiLCJ0b1N0cmluZyIsInBhcmVudE5vZGUiLCJyZW1vdmVDaGlsZCIsInNwbGljZSIsImR4IiwiZHkiLCJtb3ZlbWVudCIsInNxcnQiLCJpc01vdmluZyIsInBlcmZvcm1hbmNlIiwibm93Iiwic3Bhd25EaXN0YW5jZSIsInNwYXduQW5nbGUiLCJQSSIsInJpbmdYIiwiY29zIiwicmluZ1kiLCJzaW4iLCJwdXNoIiwib2xkZXN0Iiwic2hpZnQiLCJhbmltYXRlIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiYXR0YWNoRXZlbnRMaXN0ZW5lcnMiLCJtb3VzZU1vdmVIYW5kbGVyIiwiZSIsImNsaWVudFgiLCJjbGllbnRZIiwibW91c2VFbnRlckhhbmRsZXIiLCJ0b3VjaE1vdmVIYW5kbGVyIiwicHJldmVudERlZmF1bHQiLCJ0b3VjaGVzIiwidG91Y2giLCJ0b3VjaFN0YXJ0SGFuZGxlciIsImFkZEV2ZW50TGlzdGVuZXIiLCJwYXNzaXZlIiwiaW5pdFBvbGFyb2lkQ3Vyc29yIiwiY29uc29sZSIsImxvZyIsImlkIiwiYm9keSIsIndpbmRvdyIsImlubmVyV2lkdGgiLCJpbm5lckhlaWdodCIsIm9uY2UiLCJfIiwiY2xlYW51cFBvbGFyb2lkQ3Vyc29yIiwiZm9yRWFjaCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/lib/polaroid-cursor.ts\n"));

/***/ })

}]);